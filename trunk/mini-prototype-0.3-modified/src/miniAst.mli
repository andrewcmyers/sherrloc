(**************************************************************************)
(*  Mini, a type inference engine based on constraint solving.            *)
(*  Copyright (C) 2006. François Pottier, Yann Régis-Gianas               *)
(*  and Didier Rémy.                                                      *)
(*                                                                        *)
(*  This program is free software; you can redistribute it and/or modify  *)
(*  it under the terms of the GNU General Public License as published by  *)
(*  the Free Software Foundation; version 2 of the License.               *)
(*                                                                        *)
(*  This program is distributed in the hope that it will be useful, but   *)
(*  WITHOUT ANY WARRANTY; without even the implied warranty of            *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *)
(*  General Public License for more details.                              *)
(*                                                                        *)
(*  You should have received a copy of the GNU General Public License     *)
(*  along with this program; if not, write to the Free Software           *)
(*  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA         *)
(*  02110-1301 USA                                                        *)
(*                                                                        *)
(**************************************************************************)

(* $Id$ *)

(** The abstract syntax of MiniML programs.

    Abstract syntax trees are generated by the parser defined in 
    {!MiniSyntacticAnalysis}. 
*)

open Positions

(** A [program] in the Mini language is a sequence of toplevel bindings. *)
type program = 
    binding list

(** A [binding] is 
    {ul {- a set of value definition ({!MiniAst.value_definition}):
           {[ let v1 = exp1 and v2 = exp2 and ... and vn = expn v ]}}
        {- a set of mutually recursive definitions:
           {[ let rec v1 = exp1 and v2 = exp2 and ... and vn = expn v ]}}
        {- a type definition ({!MiniAst.type_definition}).}}
*)
and binding =
  | BindValue of position * value_definition list
  | BindRecValue of position * value_definition list
  | TypeDec of position * type_declaration list

(** An [expression] in Mini. Here is a description of the abstract
    syntax tree's nodes with their denotation in the concrete
    syntax:
    

    {4 Core ML}

    {L [EVar]}
    A variable is an identifier in the language \[azAZ\]\[azAZ_\]*.

    {L [ELambda]}
    Lambda expressions follow the syntax [\pattern. exp]. For
    example, [\x. x + 1] is the successor function. 

    {L [EApp]}
    Application is done by concatenation as in [id 0]. 

    {L [EBinding]}
    One can define binding locally using the {b let} keyword. 
    For instance: [let id = \x.x in id 0]. There is a syntactic
    sugar that expands: [let identifier pat1 ... patn = exp] into
    [let identifier = \pat1. ... \patn. exp]. Furthermore, a 
    set of rigid universally quantified type variables can be 
    introduced in the typing scope using the syntax:
    [let forall a1 ... an. id = exp]. 
    The user can refer to [a1 ... an] in [exp] and [id].

    {L [EPrimApp]}
    The Mini language has builtins like integers or predefined
    algebraic datatypes. See {!MiniAst.primitive}.
      
    {L [EForall]}
    Universally quantified type variables can be introduced using
    the syntax: [forall a.exp]. Such type variables can be used
    as rigid variables in type annotations, as in: 
    [let id = forall a. (\x. x : a -> a)]
    
    {L [EExist]}
    Existentially quantified type variables can be introduced using
    the syntax: [exists a.exp]. Such type variables can be used
    as rigid variables in type annotations, as in: 
    [let id = exists a. (\x. x : a -> a)]
    
    {L [ETypeConstraint]}
    Expression can be annotated by types. As an example:
    [let id = \x. x : int -> int].

    {4 Algebraic Datatypes}

    {L [EDCon]}
    Data constructors are used as usual function expression except
    that they must be fully applied. [Cons 0 Nil] is the application
    of the data constructor [Cons] to [0] and [Nil].
    
    {L [EDMatch]}
    A value whose type is an algebraic datatype can be matched against
    a set of [clause]'s patterns. The syntax of matching in Mini is
    {[match exp with clause_1 | clause_2 | ... | clause_n end]} 
    For instance, the following function computes the length of a list:
    {[let rec len l = 
      match exp with
        Nil => 0
      | Cons x xs => 1 + len xs
      end
    ]}
    
    {4 Record}

    {L [ERecordEmpty]}
    The syntax [{}] defines an empty record.

    {L [ERecordAccess]}
    The syntax [expression.l] is an access the label [l] of the
    record expression.

    {L [ERecordExtend]}
    A record can be defined by extension as in 
    [{ l_1 = exp_1 and l_2 = exp_2 and ... and l_n = exp_n }].

    {L [ERecordUpdate]}
    Record provides extension using the syntax
    [expression.l <- expression].

    {4 Misc}

    {L [EAssertFalse]}
    The user can use the syntax [assert false] to express 
    assumed dead code branches.

*)
and expression =
    
  (** Core ML. *)
  | EVar of position * name 
  | ELambda of position * pattern * expression
  | EApp of position * expression * expression
  | EBinding of position * binding * expression
  | EPrimApp of position * primitive * expression list
  | EForall of position * tname list * expression
  | EExists of position * tname list * expression
  
  (** Type annotations. *)
  | ETypeConstraint of position * expression * typ
  
  (** Algebraic datatypes. *) 
  | EDCon of position * dname * expression list
  | EMatch of position * expression * (clause list)

  (** Records. *)
  | ERecordEmpty of position
  | ERecordAccess of position * expression * lname
  | ERecordExtend of position * record_binding list * expression
  | ERecordUpdate of position * expression * lname * expression

  (** Misc. *)
  | EAssertFalse of position

(** Program identifiers. *)
and name = Constraint.sname =
  | SName of string
      
(** Type variable names. *)
and tname =
    MultiEquation.tname

(** Data constructors. *)
and dname =
    DName of string

(** Record labels. *)
and lname =
    CoreAlgebra.lname
  
(** Constant. *)
and primitive =
  | PIntegerConstant of int	
      (** Integer constant. *)
  | PCharConstant of char	
      (** Character constant. *)
  | PUnit			
      (** Unit constant. *)

(** Pattern matching clause. *)
and clause =
    position * pattern * expression

and record_binding =
    lname * expression

and type_declaration =
    position * kind * tname * type_definition

(** Type definitions. 

    {L [DAlgebraic]}
    Algebraic datatypes are defined by that way:
    {[type id : kind = 
          forall a1 ... an.  
              K1  : typ 
            | ... 
            | KN  : typ]}

    For example, here is the definition of polymorphic lists:
    {[type list : * -> * = forall a.
        Nil : list a
      | Cons : a -> list a -> list a
    ]}
*)
and type_definition =
  | DAlgebraic of (position * dname * tname list * typ) list

(** A value definition consists of a list of explicit universal
    quantifiers, a pattern, and an expression. *)
and value_definition =
    position * tname list * pattern * expression

and pattern =
  | PVar of position * name
  | PWildcard of position 
  | PAlias of position * name * pattern
  | PTypeConstraint of position * pattern * typ
  | PPrimitive of position * primitive
  | PData of position * dname * pattern list
  | PAnd of position * pattern list
  | POr of position * pattern list

and kind = 
  | KStar
  | KTimes of kind * kind
  | KArrow of kind * kind
  | KEmptyRow 

and typ =
  | TypVar of position * tname
  | TypApp of position * typ * typ list 
  | TypRowCons of position * (lname * typ) list * typ
  | TypRowUniform of position * typ


