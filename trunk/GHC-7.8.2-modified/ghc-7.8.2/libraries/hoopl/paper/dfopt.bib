@article{lerner-grove-chambers:2002,
  number = {1},
  bibdate = {Tue Feb 12 10:39:33 MST 2002},
  acknowledgement = {Acknowledge Nelson H. F. Beebe},
  author = {Sorin Lerner and David Grove and Craig Chambers},
  journal = {Conference Record of the 29th Annual ACM Symposium on Principles of Programming Languages, {\em in} SIGPLAN Notices},
  annote = {Proceedings of the 29th ACM SIGPLAN-SIGACT symposium on Principles of Programming Languages (POPL'02).},
  year = {2002},
  title = {Composing dataflow analyses and transformations},
  month = {January},
  coden = {SINODQ},
  xxxissn = {0362-1340},
  pages = {270--282},
  volume = {31},
}

@inproceedings{ramsey-dias:applicative-flow-graph,
  notselected = {1},
  refereed = {1},
  author = {Norman Ramsey and {Jo\~ao} Dias},
  pages = {101-122},
  accepted = {10},
  year = {2005},
  blurb = {A control-flow graph for doing classical imperative-style optimization in your functional compiler.},
  title = {An Applicative Control-Flow Graph Based on {Huet}'s Zipper},
  submitted = {21},
  booktitle = {ACM SIGPLAN Workshop on ML},
  topic = {zipcfg:compiler back ends:reusable code generation:pl infrastructure},
  base = {zipcfg},
  month = {September},
}

@article{whalley:isolation,
  number = {5},
  subject = {{\bf D.2.5}: Software, SOFTWARE ENGINEERING, Testing and Debugging, Debugging aids. {\bf D.3.4}: Software, PROGRAMMING LANGUAGES, Processors, Compilers. {\bf D.3.4}: Software, PROGRAMMING LANGUAGES, Processors, Optimization.},
  keywords = {algorithms; languages},
  author = {David B. Whalley},
  journal = {ACM Transactions on Programming Languages and Systems},
  year = {1994},
  xxxurl = {http://www.acm.org/pubs/toc/Abstracts/0164-0925/186103.html},
  abstract = {This paper describes a tool called \emph{vpoiso} that was developed to isolate errors automatically in the \emph{vpo} compiler system. The two general types of compiler errors isolated by this tool are optimization and nonoptimization errors. When isolating optimization errors, \emph{vpoiso} relies on the \emph{vpo} optimizer to identify sequences of changes, referred to as transformations, that result in semantically equivalent code and to provide the ability to stop performing \emph{improving} (or unnecessary) transformations after a specified number have been performed. A compilation of a typical program by \emph{% vpo} often results in thousands of \emph{improving} transformations being performed. The \emph{vpoiso} tool can automatically isolate the first \emph{ improving} transformation that causes incorrect output of the execution of the compiled programs by using a binary search that varies the number of \emph{% improving} transformation performed. Not only is the illegal transformation automatically isolated, but \emph{% vpoiso} also identifies the location and instant the transformation is performed in \emph{vpo}. Nonoptimization errors occur from problems in the front end, code generator, and \emph{necessary} transformations in the optimizer. If another compiler is available that can produce correct (but perhaps more inefficient) code, then \emph{vpoiso} can isolate nonoptimization errors to a single function. Automatic isolation of compiler errors facilitates retargeting a compiler to a new machine, maintenance of the compiler, and supporting experimentation with new optimizations.},
  title = {Automatic Isolation of Compiler Errors},
  month = {September},
  coden = {ATPSDT},
  xxxissn = {0164-0925},
  pages = {1648--1659},
  volume = {16},
}

@book{appel:modern,
  publisher = {Cambridge University Press},
  title = {Modern Compiler Implementation},
  address = {Cambridge, UK},
  author = {Andrew W. Appel},
  note = {Available in three editions: C, Java, and ML},
  year = {1998},
}

@techreport{cooper-harvey-kennedy:simple-dominance,
  institution = {Rice University},
  year = {2001},
  abstract = {The problem of finding the dominators in a control-flow graph has a long history in the literature. The original algorithms suffered from a large asymptotic complexity but were easy to understand. Subsequent work improved the time bound, but generally sacrificed both simplicity and ease of implementation. This paper returns to a simple formulation of dominance as a global data-flow problem. Some insights into the nature of dominance lead to an implementation of an O(N 2) algorithm that runs faster, in practice, than the classic Lengauer-Tarjan algorithm, which has a timebound of O(E âˆ— log(N)). Wecompare the algorithm to Lengauer-Tarjan because it is the best known and most widely used of the fast algorithms for dominance. Working from the same implementation insights, we also rederive (from earlier work on control dependence by Ferrante, et al.) amethod},
  location = {http://www.scientificcommons.org/42542735},
  author = {Keith D. Cooper and Timothy J. Harvey and Ken Kennedy},
  note = {Unpublished report available from \url{http://www.hipersoft.rice.edu/grads/publications/dom14.pdf}},
  title = {A Simple, Fast Dominance Algorithm},
}

@article{kam-ullman:global-iterative-analysis,
  number = {1},
  bibdate = {2003-11-20},
  bibsource = {DBLP, http://dblp.uni-trier.de/db/journals/jacm/jacm23.html#KamU76},
  author = {John B. Kam and Jeffrey D. Ullman},
  journal = {Journal of the ACM},
  year = {1976},
  volume = {23},
  xxxurl = {http://doi.acm.org/10.1145/321921.321938},
  pages = {158--171},
  title = {Global Data Flow Analysis and Iterative Algorithms},
}

@inproceedings{kildall:unified-optimization,
  title = {A unified approach to global program optimization},
  month = {October},
  booktitle = {Conference Record of the ACM Symposium on Principles of Programming Languages},
  author = {Gary A. Kildall},
  pages = {194--206},
  year = {1973},
}

@article{kam-ullman:monotone-flow-analysis,
  title = {Monotone Data Flow Analysis Frameworks},
  volume = {7},
  year = {1977},
  author = {John B. Kam and Jeffrey D. Ullman},
  journal = {Acta Informatica},
  pages = {305--317},
}

@inproceedings{cousot:abstract-interpretation:1977,
  xxxaddress = {Los Angeles, California},
  author = {Patrick Cousot and Radhia Cousot},
  annote = {Very theoretical.},
  title = {Abstract Interpretation: {A} Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints},
  month = {January},
  year = {1977},
  where = {filed with reprints},
  pages = {238--252},
  booktitle = {Conference Record of the 4th ACM Symposium on Principles of Programming Languages},
}

@inproceedings{cousot:systematic-analysis-frameworks,
  title = {Systematic Design of Program Analysis Frameworks},
  month = {January},
  year = {1979},
  author = {Patrick Cousot and Radhia Cousot},
  pages = {269--282},
  booktitle = {Conference Record of the 6th Annual ACM Symposium on Principles of Programming Languages},
}

@inproceedings{steffen:data-flow-analysis-model-checking:1991,
  xxxpublisher = {Springer-Verlag},
  xxxaddress = {London, UK},
  title = {Data Flow Analysis as Model Checking},
  pages = {346--365},
  year = {1991},
  booktitle = {TACS '91: Proceedings of the International Conference on Theoretical Aspects of Computer Software},
  xxxisbn = {3-540-54415-1},
  author = {Steffen, Bernhard},
}

@inproceedings{schmidt:data-flow-analysis-model-checking,
  bibdate = {Mon May 3 12:57:52 MDT 1999},
  xxxdress = {pub-ACM:adr},
  acknowledgement = {Nelson H. F. Beebe, University of Utah, Department of Mathematics, 110 LCB, 155 S 1400 E RM 233, Salt Lake City, UT 84112-0090, USA, Tel: +1 801 581 5254, FAX: +1 801 581 4148, e-mail: \path|beebe@math.utah.edu|, \path|beebe@acm.org|, \path|beebe@computer.org| (Internet), URL: \path|http://www.math.utah.edu/~beebe/|},
  subject = {{\bf D.3.4} Software, PROGRAMMING LANGUAGES, Processors, Optimization. {\bf D.2.2} Software, SOFTWARE ENGINEERING, Design Tools and Techniques, Flow charts. {\bf D.2.4} Software, SOFTWARE ENGINEERING, Software/Program Verification, Model checking. {\bf D.4.8} Software, OPERATING SYSTEMS, Performance, Modeling and prediction.},
  author = {David A. Schmidt},
  xxxpublisher = {ACM Press},
  keywords = {algorithms; verification},
  editor = {ACM},
  xxxurl = {http://www.acm.org:80/pubs/citations/proceedings/plan/268946/p38-schmidt/},
  title = {Data flow analysis is model checking of abstract interpretations},
  bibsource = {http://www.acm.org/pubs/toc/},
  year = {1998},
  xxxisbn = {0-89791-979-3},
  pages = {38--48},
  booktitle = {Conference Record of the 25th Annual ACM Symposium on Principles of Programming Languages},
}

@article{marlowe-ryder:properties-data-flow-frameworks,
  number = {2},
  xxxaddress = {Secaucus, NJ, USA},
  author = {Marlowe, Thomas J. and Ryder, Barbara G.},
  journal = {Acta Informatica},
  publisher = {Springer-Verlag New York, Inc.},
  year = {1990},
  volume = {28},
  doi = {http://dx.doi.org/10.1007/BF01237234},
  xxxissn = {0001-5903},
  pages = {121--163},
  title = {Properties of data flow frameworks: a unified model},
}

@book{muchnick:compiler-implementation,
  bibdate = {Thu Sep 11 07:11:02 1997},
  price = {US\$89.95},
  author = {Steven S. Muchnick},
  xxxisbn = {1-55860-320-4},
  publisher = {Morgan Kaufmann},
  year = {1997},
  address = {San Mateo, CA},
  lccn = {QA76.76.C65M8 1997},
  pages = {1004},
  title = {Advanced compiler design and implementation},
}

@inproceedings{hendren:soot:2000,
  xxxpublisher = {Springer-Verlag},
  xxxaddress = {London, UK},
  title = {Optimizing {Java} Bytecode Using the {Soot} Framework: Is It Feasible?},
  pages = {18--34},
  year = {2000},
  booktitle = {CC '00: Proceedings of the 9th International Conference on Compiler Construction},
  xxxisbn = {3-540-67263-X},
  author = {Vall\'{e}e-Rai, Raja and Gagnon, Etienne and Hendren, Laurie J. and Lam, Patrick and Pominville, Patrice and Sundaresan, Vijay},
}

@inproceedings{necula:cil:2002,
  xxxpublisher = {Springer-Verlag},
  xxxaddress = {London, UK},
  title = {{CIL}: Intermediate Language and Tools for Analysis and Transformation of {C}~Programs},
  pages = {213--228},
  year = {2002},
  booktitle = {CC '02: Proceedings of the 11th International Conference on Compiler Construction},
  xxxisbn = {3-540-43369-4},
  author = {Necula, George C. and McPeak, Scott and Rahul, Shree Prakash and Weimer, Westley},
}

@article{knoop:lazy-code-motion,
  number = {7},
  bibdate = {Fri Feb 14 18:40:11 MST 1997},
  bibsource = {Compendex database},
  affiliation = {Christian-Albrechts-Univ},
  xxxisbn = {0-89791-475-9},
  abstract = {We present a bit-vector algorithm for the optimal and economical placement of computations within flow graphs, which is as efficient as standard uni-directional analyses. The point of our algorithm is the decomposition of the bi-directional structure of the known placement algorithms into a sequence of a backward and a forward analysis, which directly implies the efficiency result. Moreover, the new compositional structure opens the algorithm for modification: two further uni-directional analysis components exclude any unnecessary code motion. This laziness of our algorithm minimizes the register pressure, which has drastic effects on the run-time behaviour of the optimized programs in practice, where an economical use of registers is essential.},
  volume = {27},
  conference = {Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation},
  xxxissn = {0362-1340},
  pages = {224--234},
  journalabr = {SIGPLAN Not},
  classification = {723.1},
  affiliationaddress = {Kiel, Ger},
  acknowledgement = {Acknowledge Nelson H. F. Beebe},
  sponsor = {ACM},
  lccn = {QA76.7.S53 1992},
  journal = {Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, {\em in} SIGPLAN Notices},
  meetingdate2 = {06/17--19/92},
  meetingdate = {Jun 17--19 1992},
  keywords = {Bit-vector data flow analyses; Code motion; Computer programming; Data flow analysis; Partial redundancy elimination; Program debugging; Program optimization},
  title = {Lazy code motion},
  meetingaddress = {San Francisco, CA, USA},
  conferenceyear = {1992},
  author = {Jens Knoop and Oliver Ruething and Bernhard Steffen},
  coden = {SINODQ},
  year = {1992},
}

@article{cocke-kennedy:operator-strength-reduction,
  number = {11},
  path = {john-cocke/strength-reduction.pdf},
  author = {Cocke, John and Kennedy, Ken},
  journal = {Communications of the ACM},
  xxxaddress = {New York, NY, USA},
  xxxpublisher = {ACM},
  year = {1977},
  volume = {20},
  doi = {http://doi.acm.org/10.1145/359863.359888},
  xxxissn = {0001-0782},
  pages = {850--856},
  title = {An Algorithm for Reduction of Operator Strength},
}

@unpublished{runciman:increasing-prs,
  note = {Reduceron Memo~50, \url{www.cs.york.ac.uk/fp/reduceron}},
  title = {Finding and increasing {PRS} candidates},
  month = {June},
  author = {Colin Runciman},
  year = {2010},
}

