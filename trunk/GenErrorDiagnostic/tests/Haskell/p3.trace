rn12
rn13
Tc2 (src)
Tc3
kcTyClGroup
  module ShouldFail
  class Foo a where
    op :: a -> a
env2 []
kcTyClGroup: initial kinds [(Foo, AThing k_a9q -> Constraint)]
env2 []
tc_lhs_type:
  a -> a
  Expected kind ‘*’
tc_lhs_type:
  a
  Expected a type
lk1 a
lk2 a AThing k_a9q
writeMetaTyVar k_a9q := *
tc_lhs_type:
  a
  Expected a type
lk1 a
lk2 a AThing k_a9q
Generalise kind
  Foo
  k_a9q -> Constraint
  []
  * -> Constraint
kcTyClGroup result [(Foo, * -> Constraint)]
tcTyAndCl generalized kinds [(Foo, * -> Constraint)]
tcTyAndCl-x
  class Foo a where
    op :: a -> a
env2 []
env2 [(a, Type variable ‘a’ = a)]
tcClassSigs 1 Foo
ClsSig 1 [op]
tc_lhs_type:
  a
  Expected a type
lk1 a
lk2 a Type variable ‘a’ = a
tc_lhs_type:
  a
  Expected a type
lk1 a
lk2 a Type variable ‘a’ = a
tcCheckHsTypeAndGen a -> a
ClsSig 2 [op]
tcClassSigs 2 Foo
tcClassDecl
  []
  [a]
  []
Starting validity check [Class ‘Foo’]
class op type forall a. Foo a => a -> a a -> a
checkValidType a -> a :: *
checkValidType done a -> a :: *
env2 []
tc_lhs_type:
  Foo
  Expected kind ‘k_a9w’
lk1 Foo
lk2 Foo Class ‘Foo’
writeMetaTyVar k_a9w := * -> Constraint
tc_lhs_type:
  [Int]
  The first argument of ‘Foo’ should have kind ‘*’
tc_lhs_type:
  Int
  Expected kind ‘*’
lk1 Int
lk2 Int Type constructor ‘Int’
tcLocalInstDecl Foo [Int]
env2 []
env2 []
env2 []
tcHsTyVarBndrs {
  Hs kind vars: []
  Hs type vars: [a]
  Kind vars: []
  Type vars: [a]
env2 [(a, Type variable ‘a’ = a)]
tc_lhs_type:
  Foo a
  Expected a constraint
tc_lhs_type:
  Foo
  Expected kind ‘k_a9z’
lk1 Foo
lk2 Foo Class ‘Foo’
writeMetaTyVar k_a9z := * -> Constraint
tc_lhs_type:
  a
  The first argument of ‘Foo’ should have kind ‘*’
lk1 a
lk2 a Type variable ‘a’ = a
writeMetaTyVar k_a9y := *
tc_lhs_type:
  Foo [a]
  Expected a constraint
tc_lhs_type:
  Foo
  Expected kind ‘k_a9A’
lk1 Foo
lk2 Foo Class ‘Foo’
writeMetaTyVar k_a9A := * -> Constraint
tc_lhs_type:
  [a]
  The first argument of ‘Foo’ should have kind ‘*’
tc_lhs_type:
  a
  Expected kind ‘*’
lk1 a
lk2 a Type variable ‘a’ = a
tcHsTyVarBndrs }
  Hs kind vars: []
  Hs type vars: [a]
  Kind vars: []
  Type vars: [a]
tcLocalInstDecl Foo a => Foo [a]
env2 [(a, Type variable ‘a’ = a)]
env2 [(a, Type variable ‘a’ = a)]
Adding instances:
  ShouldFail.$fFoo[] : instance [overlap ok] Foo [Int]
                         -- Defined at p3.hs:11:10
  ShouldFail.$fFoo[]0 : instance [overlap ok] Foo a => Foo [a]
                          -- Defined at p3.hs:10:10
addFamInsts
env2 []
tcDeriving
tcDeriving False
tcDeriving 1 []
Adding instances:
Tc3b
tcAmpMissingParentClassWarn/isInsts []
tcAmpMissingParentClassWarn/isInsts []
tcAmpFunctionWarn/wouldBeImported
tcAmpFunctionWarn/amp_prelude_functions Control.Monad.join []
tcAmpFunctionWarn/wouldBeImported
tcAmpFunctionWarn/amp_prelude_functions Control.Applicative.<*> []
tcAmpFunctionWarn/wouldBeImported
tcAmpFunctionWarn/amp_prelude_functions Control.Applicative.pure []
Tc4
Tc4a
env2 []
Tc5
env2 []
tcHsTyVarBndrs {
  Hs kind vars: []
  Hs type vars: [a]
  Kind vars: []
  Type vars: [a]
env2 [(a, Type variable ‘a’ = a)]
tc_lhs_type:
  Foo a
  Expected a constraint
tc_lhs_type:
  Foo
  Expected kind ‘k_ahG’
lk1 Foo
lk2 Foo Class ‘Foo’
writeMetaTyVar k_ahG := * -> Constraint
tc_lhs_type:
  a
  The first argument of ‘Foo’ should have kind ‘*’
lk1 a
lk2 a Type variable ‘a’ = a
writeMetaTyVar k_ahF := *
tc_lhs_type:
  [a] -> [a]
  Expected a type
tc_lhs_type:
  [a]
  Expected a type
tc_lhs_type:
  a
  Expected kind ‘*’
lk1 a
lk2 a Type variable ‘a’ = a
tc_lhs_type:
  [a]
  Expected a type
tc_lhs_type:
  a
  Expected kind ‘*’
lk1 a
lk2 a Type variable ‘a’ = a
tcHsTyVarBndrs }
  Hs kind vars: []
  Hs type vars: [a]
  Kind vars: []
  Type vars: [a]
tcCheckHsTypeAndGen Foo a => [a] -> [a]
checkValidType forall a. Foo a => [a] -> [a] :: *
Ambiguity check for forall a. Foo a => [a] -> [a]
tcGen
instCallConstraints [$dFoo_ahM]
u_tys 
  untch 1
  [a_ahK] -> [a_ahK] ~ [a] -> [a]
  a type equality [a_ahK] -> [a_ahK] ~ [a] -> [a]
u_tys 
  untch 1
  [a_ahK] ~ [a]
  a type equality [a_ahK] -> [a_ahK] ~ [a] -> [a]
u_tys 
  untch 1
  a_ahK ~ a
  a type equality [a_ahK] -> [a_ahK] ~ [a] -> [a]
uUnfilledVars trying to unify * with *
writeMetaTyVar a_ahK := a
u_tys yields no coercion
u_tys yields no coercion
u_tys 
  untch 1
  [a_ahK] ~ [a]
  a type equality [a_ahK] -> [a_ahK] ~ [a] -> [a]
u_tys 
  untch 1
  a_ahK ~ a
  a type equality [a_ahK] -> [a_ahK] ~ [a] -> [a]
u_tys yields no coercion
u_tys yields no coercion
u_tys yields no coercion
simplifyAmbiguityCheck {
  type =  forall a. Foo a => [a] -> [a]
  wanted =  WC {wc_impl = Implic {Untouchables = 1
                                  Skolems = a
                                  Flatten-skolems =
                                  No-eqs = False
                                  Given = $dFoo_ahJ :: Foo a
                                  Wanted = WC {wc_flat = [W] $dFoo_ahM :: Foo
                                                                            a_ahK [" the ambiguity check for ‘foo’ " p3.hs:13:8-26] (CNonCanonical)}
                                  Binds = EvBindsVar<ahN>
                                  the type signature for foo :: Foo a => [a] -> [a]}}
solveWantedsTcMWithEvBinds
  wanted= WC {wc_impl = Implic {Untouchables = 1
                                Skolems = a
                                Flatten-skolems =
                                No-eqs = False
                                Given = $dFoo_ahJ :: Foo a
                                Wanted = WC {wc_flat = [W] $dFoo_ahM :: Foo
                                                                          a_ahK [" the ambiguity check for ‘foo’ " p3.hs:13:8-26] (CNonCanonical)}
                                Binds = EvBindsVar<ahN>
                                the type signature for foo :: Foo a => [a] -> [a]}}
solveWanteds {
  WC {wc_impl = Implic {Untouchables = 1
                        Skolems = a
                        Flatten-skolems =
                        No-eqs = False
                        Given = $dFoo_ahJ :: Foo a
                        Wanted = WC {wc_flat = [W] $dFoo_ahM :: Foo
                                                                  a_ahK [" the ambiguity check for ‘foo’ " p3.hs:13:8-26] (CNonCanonical)}
                        Binds = EvBindsVar<ahN>
                        the type signature for foo :: Foo a => [a] -> [a]}}
solveFlats {
solveFlats end } {}
simpl_loop, iteration 1
solveNestedImplications starting {
  original inerts =  Equalities:
                     Type-function equalities:
                     No-eqs: True
                     Dictionaries:
                     Irreds:
                     Insolubles = {}
                     Solved dicts 0
                     Solved funeqs 0
  thinner_inerts  =  Equalities:
                     Type-function equalities:
                     No-eqs: True
                     Dictionaries:
                     Irreds:
                     Insolubles = {}
                     Solved dicts 0
                     Solved funeqs 0
solveImplication {
  Implic {Untouchables = 1
          Skolems = a
          Flatten-skolems =
          No-eqs = False
          Given = $dFoo_ahJ :: Foo a
          Wanted = WC {wc_flat = [W] $dFoo_ahM :: Foo
                                                    a_ahK [" the ambiguity check for ‘foo’ " p3.hs:13:8-26] (CNonCanonical)}
          Binds = EvBindsVar<ahN>
          the type signature for foo :: Foo a => [a] -> [a]}
Start solver pipeline {
  work item =  [G] $dFoo_ahJ :: Foo a [" the type signature for
                                           foo :: Foo a =>
                                                  [a] -> [a] " p3.hs:13:8-26] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [G] $dFoo_ahJ :: Foo a [" the type signature for
                                            foo :: Foo a =>
                                                   [a] -> [a] " p3.hs:13:8-26] (CNonCanonical)
canonicalize (non-canonical)
  [G] $dFoo_ahJ :: Foo a [" the type signature for
                              foo :: Foo a => [a] -> [a] " p3.hs:13:8-26] (CNonCanonical)
canEvNC:cls Foo [a]
canClass
  [G] $dFoo_ahJ :: Foo a Foo [a]
  Foo a
  Just [G] $dFoo_ahJ :: Foo a
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] $dFoo_ahJ :: Foo a [" the type signature for
                                            foo :: Foo a => [a] -> [a] " p3.hs:13:8-26] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] $dFoo_ahJ :: Foo a [" the type signature for
                                            foo :: Foo a => [a] -> [a] " p3.hs:13:8-26] (CDictCan)
doTopReact
  [G] $dFoo_ahJ :: Foo a [" the type signature for
                              foo :: Foo a => [a] -> [a] " p3.hs:13:8-26] (CDictCan)
end stage top-level reactions }
1[<C:0,F:0>] [G] $dFoo_ahJ :: Foo a: Kept as inert
End solver pipeline (not discharged) }
  final_item =  [G] $dFoo_ahJ :: Foo a [" the type signature for
                                            foo :: Foo a => [a] -> [a] " p3.hs:13:8-26] (CDictCan)
  a
  inerts     =  Equalities:
                Type-function equalities:
                No-eqs: True
                Dictionaries:
                Irreds:
                Insolubles = {}
                Solved dicts 0
                Solved funeqs 0
insertInertItemTcS {
  Trying to insert new inert item: [G] $dFoo_ahJ :: Foo
                                                      a [" the type signature for
                                                             foo :: Foo a =>
                                                                    [a]
                                                                    -> [a] " p3.hs:13:8-26] (CDictCan)
insertInertItemTcS }
solveWanteds {
  WC {wc_flat = [W] $dFoo_ahM :: Foo
                                   a_ahK [" the ambiguity check for ‘foo’ " p3.hs:13:8-26] (CNonCanonical)}
solveFlats {
Start solver pipeline {
  work item =  [W] $dFoo_ahM :: Foo
                                  a_ahK [" the ambiguity check for ‘foo’ " p3.hs:13:8-26] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [G] $dFoo_ahJ :: Foo a [" the type signature for
                                                         foo :: Foo a =>
                                                                [a]
                                                                -> [a] " p3.hs:13:8-26] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dFoo_ahM :: Foo
                                   a_ahK [" the ambiguity check for ‘foo’ " p3.hs:13:8-26] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dFoo_ahM :: Foo
                     a_ahK [" the ambiguity check for ‘foo’ " p3.hs:13:8-26] (CNonCanonical)
canEvNC:cls Foo [a_ahK]
Following filled tyvar a_ahK = a
canClass
  [W] $dFoo_ahM :: Foo a_ahK Foo [a_ahK]
  Foo a
  Just [W] $dFoo_ahM :: Foo a
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dFoo_ahM :: Foo
                                   a [" the ambiguity check for ‘foo’ " p3.hs:13:8-26] (CDictCan)
setEvBind
  ev = $dFoo_ahM
  tm  = $dFoo_ahJ
2[<C:0,F:0>] [W] $dFoo_ahM :: Foo a: Dict equal (keep)
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [G] $dFoo_ahJ :: Foo a [" the type signature for
                                                         foo :: Foo a =>
                                                                [a]
                                                                -> [a] " p3.hs:13:8-26] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
solveFlats end } {}
simpl_loop, iteration 1
solveWanteds }
  unsolved_flats   = {}
  unsolved_implics = {}
  current evbinds  = {$dFoo_ahM = $dFoo_ahJ}
  current tybinds  =
  final wc = WC {}
floatEqualities
  Flats = {}
  Floated eqs = {}
  Ty binds = []
solveImplication end }
  no_given_eqs = True
  floated_eqs = {}
  new_fsks = []
  res_implic = {}
  implication evbinds =  {}
solveNestedImplications end }
  all floated_eqs = {}
  unsolved_implics = {}
solveWanteds }
  unsolved_flats   = {}
  unsolved_implics = {}
  current evbinds  = {}
  current tybinds  =
  final wc = WC {}
Constraint solver steps = 2
End simplifyAmbiguityCheck }
reportUnsolved(ambig) {
reportUnsolved(ambig) }
Done ambiguity check for forall a. Foo a => [a] -> [a]
checkValidType done forall a. Foo a => [a] -> [a] :: *
env2
  [(foo,
    Identifier[foo::forall a. Foo a => [a] -> [a], <NotTopLevel>])]
------------------------------------------------
Bindings for { [foo]
Generalisation plan
  CheckGen foo :: Foo a => [a] -> [a]
                  [Nothing]
env2 []
tcMonoBinds
env2 []
tcRhs: fun bind
  foo
  [a] -> [a]
tcMatchesFun
  foo
  [a] -> [a]
tcGen
env2 [(x, Identifier[x::[a], <NotTopLevel>])]
tcBody [a]
Instantiating
  op with [a_ahT]
          [Foo a_ahT]
instCallConstraints [$dFoo_ahU]
utype_defer
  cobox_ahV
  a_ahT
  [a]
  a type equality a_ahT ~ [a]
  In the expression: op x
  In an equation for ‘foo’: foo x = op x
tcPolyExprNC a_ahT
tcGen
utype_defer
  cobox_ahW
  [a]
  a_ahT
  a type equality [a] ~ a_ahT
  In the first argument of ‘op’, namely ‘x’
  In the expression: op x
addInlinePrags
  foo
  []
csb2 [foo]
} End of bindings for
  [foo]
  NonRecursive
  foo forall a. Foo a => [a] -> [a]
env2
  [(foo, Identifier[foo::forall a. Foo a => [a] -> [a], <TopLevel>])]
Tc6
TIM2 [op :: a -> a]
env2 [(a, Type variable ‘a’ = a)]
env2 []
env2 []
tcInstMeth
  []
  {}
Adding warning:
  p3.hs:11:10: Warning:
      No explicit implementation for
        ‘op’
      In the instance declaration for ‘Foo [Int]’
tc_def op
tc_def: warn op
env2 [(a, Type variable ‘a’ = a)]
tcInstMeth
  []
  {}
Adding warning:
  p3.hs:10:10: Warning:
      No explicit implementation for
        ‘op’
      In the instance declaration for ‘Foo [a]’
tc_def op
tc_def: warn op
Tc7
End of tcVectDecls: LIE:
  WC {wc_impl = Implic {Untouchables = 1
                        Skolems = a
                        Flatten-skolems =
                        No-eqs = False
                        Given = $dFoo_ahR :: Foo a
                        Wanted = WC {wc_flat = [W] $dFoo_ahU :: Foo
                                                                  a_ahT [" a use of ‘op’ " p3.hs:14:9-10] (CNonCanonical)
                                               [W] cobox_ahV :: a_ahT ~ [a] [" a type equality a_ahT
                                                                                               ~
                                                                                               [a] " p3.hs:14:9-12] (CNonCanonical)
                                               [W] cobox_ahW :: [a] ~ a_ahT [" a type equality [a]
                                                                                               ~
                                                                                               a_ahT " p3.hs:14:12] (CNonCanonical)}
                        Binds = EvBindsVar<ahX>
                        the type signature for foo :: Foo a => [a] -> [a]}
                Implic {Untouchables = 1
                        Skolems = a
                        Flatten-skolems =
                        No-eqs = False
                        Given = $dFoo_ai2 :: Foo a
                        Wanted = WC {}
                        Binds = EvBindsVar<ai3>
                        the instance declaration}}
Tc7a
checkMain not Main ShouldFail
Tc8
simplifyTop {
  wanted =  WC {wc_impl = Implic {Untouchables = 1
                                  Skolems = a
                                  Flatten-skolems =
                                  No-eqs = False
                                  Given = $dFoo_ahR :: Foo a
                                  Wanted = WC {wc_flat = [W] $dFoo_ahU :: Foo
                                                                            a_ahT [" a use of ‘op’ " p3.hs:14:9-10] (CNonCanonical)
                                                         [W] cobox_ahV :: a_ahT
                                                                          ~ [a] [" a type equality a_ahT
                                                                                                   ~
                                                                                                   [a] " p3.hs:14:9-12] (CNonCanonical)
                                                         [W] cobox_ahW :: [a]
                                                                          ~ a_ahT [" a type equality [a]
                                                                                                     ~
                                                                                                     a_ahT " p3.hs:14:12] (CNonCanonical)}
                                  Binds = EvBindsVar<ahX>
                                  the type signature for foo :: Foo a => [a] -> [a]}
                          Implic {Untouchables = 1
                                  Skolems = a
                                  Flatten-skolems =
                                  No-eqs = False
                                  Given = $dFoo_ai2 :: Foo a
                                  Wanted = WC {}
                                  Binds = EvBindsVar<ai3>
                                  the instance declaration}}
solveWantedsTcMWithEvBinds
  wanted= WC {wc_impl = Implic {Untouchables = 1
                                Skolems = a
                                Flatten-skolems =
                                No-eqs = False
                                Given = $dFoo_ahR :: Foo a
                                Wanted = WC {wc_flat = [W] $dFoo_ahU :: Foo
                                                                          a_ahT [" a use of ‘op’ " p3.hs:14:9-10] (CNonCanonical)
                                                       [W] cobox_ahV :: a_ahT
                                                                        ~ [a] [" a type equality a_ahT
                                                                                                 ~
                                                                                                 [a] " p3.hs:14:9-12] (CNonCanonical)
                                                       [W] cobox_ahW :: [a]
                                                                        ~ a_ahT [" a type equality [a]
                                                                                                   ~
                                                                                                   a_ahT " p3.hs:14:12] (CNonCanonical)}
                                Binds = EvBindsVar<ahX>
                                the type signature for foo :: Foo a => [a] -> [a]}
                        Implic {Untouchables = 1
                                Skolems = a
                                Flatten-skolems =
                                No-eqs = False
                                Given = $dFoo_ai2 :: Foo a
                                Wanted = WC {}
                                Binds = EvBindsVar<ai3>
                                the instance declaration}}
solveWanteds {
  WC {wc_impl = Implic {Untouchables = 1
                        Skolems = a
                        Flatten-skolems =
                        No-eqs = False
                        Given = $dFoo_ahR :: Foo a
                        Wanted = WC {wc_flat = [W] $dFoo_ahU :: Foo
                                                                  a_ahT [" a use of ‘op’ " p3.hs:14:9-10] (CNonCanonical)
                                               [W] cobox_ahV :: a_ahT ~ [a] [" a type equality a_ahT
                                                                                               ~
                                                                                               [a] " p3.hs:14:9-12] (CNonCanonical)
                                               [W] cobox_ahW :: [a] ~ a_ahT [" a type equality [a]
                                                                                               ~
                                                                                               a_ahT " p3.hs:14:12] (CNonCanonical)}
                        Binds = EvBindsVar<ahX>
                        the type signature for foo :: Foo a => [a] -> [a]}
                Implic {Untouchables = 1
                        Skolems = a
                        Flatten-skolems =
                        No-eqs = False
                        Given = $dFoo_ai2 :: Foo a
                        Wanted = WC {}
                        Binds = EvBindsVar<ai3>
                        the instance declaration}}
solveFlats {
solveFlats end } {}
simpl_loop, iteration 1
solveNestedImplications starting {
  original inerts =  Equalities:
                     Type-function equalities:
                     No-eqs: True
                     Dictionaries:
                     Irreds:
                     Insolubles = {}
                     Solved dicts 0
                     Solved funeqs 0
  thinner_inerts  =  Equalities:
                     Type-function equalities:
                     No-eqs: True
                     Dictionaries:
                     Irreds:
                     Insolubles = {}
                     Solved dicts 0
                     Solved funeqs 0
solveImplication {
  Implic {Untouchables = 1
          Skolems = a
          Flatten-skolems =
          No-eqs = False
          Given = $dFoo_ahR :: Foo a
          Wanted = WC {wc_flat = [W] $dFoo_ahU :: Foo
                                                    a_ahT [" a use of ‘op’ " p3.hs:14:9-10] (CNonCanonical)
                                 [W] cobox_ahV :: a_ahT ~ [a] [" a type equality a_ahT
                                                                                 ~
                                                                                 [a] " p3.hs:14:9-12] (CNonCanonical)
                                 [W] cobox_ahW :: [a] ~ a_ahT [" a type equality [a]
                                                                                 ~
                                                                                 a_ahT " p3.hs:14:12] (CNonCanonical)}
          Binds = EvBindsVar<ahX>
          the type signature for foo :: Foo a => [a] -> [a]}
Start solver pipeline {
  work item =  [G] $dFoo_ahR :: Foo a [" the type signature for
                                           foo :: Foo a =>
                                                  [a] -> [a] " p3.hs:13:8-26] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [G] $dFoo_ahR :: Foo a [" the type signature for
                                            foo :: Foo a =>
                                                   [a] -> [a] " p3.hs:13:8-26] (CNonCanonical)
canonicalize (non-canonical)
  [G] $dFoo_ahR :: Foo a [" the type signature for
                              foo :: Foo a => [a] -> [a] " p3.hs:13:8-26] (CNonCanonical)
canEvNC:cls Foo [a]
canClass
  [G] $dFoo_ahR :: Foo a Foo [a]
  Foo a
  Just [G] $dFoo_ahR :: Foo a
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] $dFoo_ahR :: Foo a [" the type signature for
                                            foo :: Foo a => [a] -> [a] " p3.hs:13:8-26] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] $dFoo_ahR :: Foo a [" the type signature for
                                            foo :: Foo a => [a] -> [a] " p3.hs:13:8-26] (CDictCan)
doTopReact
  [G] $dFoo_ahR :: Foo a [" the type signature for
                              foo :: Foo a => [a] -> [a] " p3.hs:13:8-26] (CDictCan)
end stage top-level reactions }
1[<C:0,F:0>] [G] $dFoo_ahR :: Foo a: Kept as inert
End solver pipeline (not discharged) }
  final_item =  [G] $dFoo_ahR :: Foo a [" the type signature for
                                            foo :: Foo a => [a] -> [a] " p3.hs:13:8-26] (CDictCan)
  a
  inerts     =  Equalities:
                Type-function equalities:
                No-eqs: True
                Dictionaries:
                Irreds:
                Insolubles = {}
                Solved dicts 0
                Solved funeqs 0
insertInertItemTcS {
  Trying to insert new inert item: [G] $dFoo_ahR :: Foo
                                                      a [" the type signature for
                                                             foo :: Foo a =>
                                                                    [a]
                                                                    -> [a] " p3.hs:13:8-26] (CDictCan)
insertInertItemTcS }
solveWanteds {
  WC {wc_flat = [W] $dFoo_ahU :: Foo
                                   a_ahT [" a use of ‘op’ " p3.hs:14:9-10] (CNonCanonical)
                [W] cobox_ahV :: a_ahT ~ [a] [" a type equality a_ahT
                                                                ~
                                                                [a] " p3.hs:14:9-12] (CNonCanonical)
                [W] cobox_ahW :: [a] ~ a_ahT [" a type equality [a]
                                                                ~
                                                                a_ahT " p3.hs:14:12] (CNonCanonical)}
solveFlats {
Start solver pipeline {
  work item =  [W] cobox_ahV :: a_ahT ~ [a] [" a type equality a_ahT
                                                               ~
                                                               [a] " p3.hs:14:9-12] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [G] $dFoo_ahR :: Foo a [" the type signature for
                                                         foo :: Foo a =>
                                                                [a]
                                                                -> [a] " p3.hs:13:8-26] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ahV :: a_ahT ~ [a] [" a type equality a_ahT
                                                                ~
                                                                [a] " p3.hs:14:9-12] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ahV :: a_ahT ~ [a] [" a type equality a_ahT
                                                  ~
                                                  [a] " p3.hs:14:9-12] (CNonCanonical)
canEvNC:eq
  a_ahT
  [a]
can_eq_nc
  [W] cobox_ahV :: a_ahT ~ [a]
  a_ahT
  a_ahT
  [a]
  [a]
canEqTyVar
  a_ahT
  [a]
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ahV :: a_ahT ~ [a] [" a type equality a_ahT
                                                                ~
                                                                [a] " p3.hs:14:9-12] (CTyEqCan)
Sneaky unification:
  Unifies: a_ahT := [a]
  Coercion: a_ahT ~ [a]
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_ahT := [a]
setEvBind
  ev = cobox_ahV
  tm  = CO <[a]>_N
kickOutRewritable
  tv =  a_ahT
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
2[<C:0,F:0>] [W] cobox_ahV :: a_ahT ~ [a]: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [G] $dFoo_ahR :: Foo a [" the type signature for
                                                         foo :: Foo a =>
                                                                [a]
                                                                -> [a] " p3.hs:13:8-26] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ahW :: [a] ~ a_ahT [" a type equality [a]
                                                               ~
                                                               a_ahT " p3.hs:14:12] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [G] $dFoo_ahR :: Foo a [" the type signature for
                                                         foo :: Foo a =>
                                                                [a]
                                                                -> [a] " p3.hs:13:8-26] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ahW :: [a] ~ a_ahT [" a type equality [a]
                                                                ~
                                                                a_ahT " p3.hs:14:12] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ahW :: [a] ~ a_ahT [" a type equality [a]
                                                  ~
                                                  a_ahT " p3.hs:14:12] (CNonCanonical)
canEvNC:eq
  [a]
  a_ahT
can_eq_nc
  [W] cobox_ahW :: [a] ~ a_ahT
  [a]
  [a]
  a_ahT
  a_ahT
canEqTyVar
  a_ahT
  [a]
  Is-swapped
Following bound tyvar a_ahT = [a]
newWantedEvVar/cache miss [W] cobox_ai8 :: [a] ~ [a]
setEvBind
  ev = cobox_ahW
  tm  = CO Sym cobox_ai8
rewriteEqEvidence
  [W] cobox_ahW :: [a] ~ a_ahT
  [a]
  [a]
  Sym cobox_ai8
canEqTyVar2
  a_ahT
  [a]
  Is-swapped
  [a]
  <[a]>_N
can_eq_nc
  [W] cobox_ai8 :: [a] ~ [a]
  [a]
  [a]
  [a]
  [a]
newWantedEvVar/cache miss [W] cobox_ai9 :: a ~ a
setEvBind
  ev = cobox_ai8
  tm  = CO [cobox_ai9]_N
canEvNC:eq
  a
  a
can_eq_nc
  [W] cobox_ai9 :: a ~ a
  a
  a
  a
  a
canEqTyVar
  a
  a
  Not-swapped
setEvBind
  ev = cobox_ai9
  tm  = CO <a>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [G] $dFoo_ahR :: Foo a [" the type signature for
                                                         foo :: Foo a =>
                                                                [a]
                                                                -> [a] " p3.hs:13:8-26] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dFoo_ahU :: Foo
                                  a_ahT [" a use of ‘op’ " p3.hs:14:9-10] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [G] $dFoo_ahR :: Foo a [" the type signature for
                                                         foo :: Foo a =>
                                                                [a]
                                                                -> [a] " p3.hs:13:8-26] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dFoo_ahU :: Foo
                                   a_ahT [" a use of ‘op’ " p3.hs:14:9-10] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dFoo_ahU :: Foo
                     a_ahT [" a use of ‘op’ " p3.hs:14:9-10] (CNonCanonical)
canEvNC:cls Foo [a_ahT]
Following bound tyvar a_ahT = [a]
canClass
  [W] $dFoo_ahU :: Foo a_ahT Foo [a_ahT]
  Foo [a]
  Just [W] $dFoo_ahU :: Foo [a]
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dFoo_ahU :: Foo
                                   [a] [" a use of ‘op’ " p3.hs:14:9-10] (CDictCan)
addFuNDepWork
  inertItem = [G] $dFoo_ahR :: Foo a [" the type signature for
                                          foo :: Foo a => [a] -> [a] " p3.hs:13:8-26] (CDictCan)
  workItem  = [W] $dFoo_ahU :: Foo
                                 [a] [" a use of ‘op’ " p3.hs:14:9-10] (CDictCan)
  fundeps = []
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dFoo_ahU :: Foo
                                   [a] [" a use of ‘op’ " p3.hs:14:9-10] (CDictCan)
doTopReact
  [W] $dFoo_ahU :: Foo
                     [a] [" a use of ‘op’ " p3.hs:14:9-10] (CDictCan)
matchClassInst
  pred = Foo [a]
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries: [G] $dFoo_ahR :: Foo a [" the type signature for
                                                    foo :: Foo a =>
                                                           [a] -> [a] " p3.hs:13:8-26] (CDictCan)
          Irreds:
          Insolubles = {}
          Solved dicts 0
          Solved funeqs 0
  untouchables= 1
matchClass multiple matches, deferring choice
  dict Foo [a]
  matches [(instance [overlap ok] Foo a => Foo [a]
              -- Defined at p3.hs:10:10,
            [Just a])]
end stage top-level reactions }
4[<C:0,F:0>] [W] $dFoo_ahU :: Foo [a]: Kept as inert
End solver pipeline (not discharged) }
  final_item =  [W] $dFoo_ahU :: Foo
                                   [a] [" a use of ‘op’ " p3.hs:14:9-10] (CDictCan)
  a
  inerts     =  Equalities:
                Type-function equalities:
                No-eqs: True
                Dictionaries: [G] $dFoo_ahR :: Foo a [" the type signature for
                                                          foo :: Foo a =>
                                                                 [a]
                                                                 -> [a] " p3.hs:13:8-26] (CDictCan)
                Irreds:
                Insolubles = {}
                Solved dicts 0
                Solved funeqs 0
insertInertItemTcS {
  Trying to insert new inert item: [W] $dFoo_ahU :: Foo
                                                      [a] [" a use of ‘op’ " p3.hs:14:9-10] (CDictCan)
insertInertItemTcS }
solveFlats end } {}
simpl_loop, iteration 1
solveWanteds }
  unsolved_flats   = {[W] $dFoo_ahU :: Foo
                                         [a] [" a use of ‘op’ " p3.hs:14:9-10] (CDictCan)}
  unsolved_implics = {}
  current evbinds  = {cobox_ahV = CO <[a]>_N,
                      cobox_ahW = CO Sym cobox_ai8, cobox_ai8 = CO [cobox_ai9]_N,
                      cobox_ai9 = CO <a>_N}
  current tybinds  = (a_ahT, [a])
  final wc = WC {wc_flat = [W] $dFoo_ahU :: Foo
                                              [a] [" a use of ‘op’ " p3.hs:14:9-10] (CDictCan)}
floatEqualities
  Flats = {[W] $dFoo_ahU :: Foo
                              [a] [" a use of ‘op’ " p3.hs:14:9-10] (CDictCan)}
  Floated eqs = {}
  Ty binds = [(ahT, (a_ahT, [a]))]
solveImplication end }
  no_given_eqs = True
  floated_eqs = {}
  new_fsks = []
  res_implic = {Implic {Untouchables = 1
                        Skolems = a
                        Flatten-skolems =
                        No-eqs = True
                        Given = $dFoo_ahR :: Foo a
                        Wanted = WC {wc_flat = [W] $dFoo_ahU :: Foo
                                                                  [a] [" a use of ‘op’ " p3.hs:14:9-10] (CDictCan)}
                        Binds = EvBindsVar<ahX>
                        the type signature for foo :: Foo a => [a] -> [a]}}
  implication evbinds =  {}
solveImplication {
  Implic {Untouchables = 1
          Skolems = a
          Flatten-skolems =
          No-eqs = False
          Given = $dFoo_ai2 :: Foo a
          Wanted = WC {}
          Binds = EvBindsVar<ai3>
          the instance declaration}
Start solver pipeline {
  work item =  [G] $dFoo_ai2 :: Foo
                                  a [" the instance declaration " p3.hs:10:10-25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [G] $dFoo_ai2 :: Foo
                                   a [" the instance declaration " p3.hs:10:10-25] (CNonCanonical)
canonicalize (non-canonical)
  [G] $dFoo_ai2 :: Foo
                     a [" the instance declaration " p3.hs:10:10-25] (CNonCanonical)
canEvNC:cls Foo [a]
canClass
  [G] $dFoo_ai2 :: Foo a Foo [a]
  Foo a
  Just [G] $dFoo_ai2 :: Foo a
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [G] $dFoo_ai2 :: Foo
                                   a [" the instance declaration " p3.hs:10:10-25] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [G] $dFoo_ai2 :: Foo
                                   a [" the instance declaration " p3.hs:10:10-25] (CDictCan)
doTopReact
  [G] $dFoo_ai2 :: Foo
                     a [" the instance declaration " p3.hs:10:10-25] (CDictCan)
end stage top-level reactions }
5[<C:0,F:0>] [G] $dFoo_ai2 :: Foo a: Kept as inert
End solver pipeline (not discharged) }
  final_item =  [G] $dFoo_ai2 :: Foo
                                   a [" the instance declaration " p3.hs:10:10-25] (CDictCan)
  a
  inerts     =  Equalities:
                Type-function equalities:
                No-eqs: True
                Dictionaries:
                Irreds:
                Insolubles = {}
                Solved dicts 0
                Solved funeqs 0
insertInertItemTcS {
  Trying to insert new inert item: [G] $dFoo_ai2 :: Foo
                                                      a [" the instance declaration " p3.hs:10:10-25] (CDictCan)
insertInertItemTcS }
solveWanteds { WC {}
solveFlats {
solveFlats end } {}
simpl_loop, iteration 1
solveWanteds }
  unsolved_flats   = {}
  unsolved_implics = {}
  current evbinds  = {}
  current tybinds  = (a_ahT, [a])
  final wc = WC {}
floatEqualities
  Flats = {}
  Floated eqs = {}
  Ty binds = [(ahT, (a_ahT, [a]))]
solveImplication end }
  no_given_eqs = True
  floated_eqs = {}
  new_fsks = []
  res_implic = {}
  implication evbinds =  {}
solveNestedImplications end }
  all floated_eqs = {}
  unsolved_implics = {Implic {Untouchables = 1
                              Skolems = a
                              Flatten-skolems =
                              No-eqs = True
                              Given = $dFoo_ahR :: Foo a
                              Wanted = WC {wc_flat = [W] $dFoo_ahU :: Foo
                                                                        [a] [" a use of ‘op’ " p3.hs:14:9-10] (CDictCan)}
                              Binds = EvBindsVar<ahX>
                              the type signature for foo :: Foo a => [a] -> [a]}}
solveWanteds }
  unsolved_flats   = {}
  unsolved_implics = {Implic {Untouchables = 1
                              Skolems = a
                              Flatten-skolems =
                              No-eqs = True
                              Given = $dFoo_ahR :: Foo a
                              Wanted = WC {wc_flat = [W] $dFoo_ahU :: Foo
                                                                        [a] [" a use of ‘op’ " p3.hs:14:9-10] (CDictCan)}
                              Binds = EvBindsVar<ahX>
                              the type signature for foo :: Foo a => [a] -> [a]}}
  current evbinds  = {}
  current tybinds  = (a_ahT, [a])
  final wc = WC {wc_impl = Implic {Untouchables = 1
                                   Skolems = a
                                   Flatten-skolems =
                                   No-eqs = True
                                   Given = $dFoo_ahR :: Foo a
                                   Wanted = WC {wc_flat = [W] $dFoo_ahU :: Foo
                                                                             [a] [" a use of ‘op’ " p3.hs:14:9-10] (CDictCan)}
                                   Binds = EvBindsVar<ahX>
                                   the type signature for foo :: Foo a => [a] -> [a]}}
writeMetaTyVar a_ahT := [a]
Constraint solver steps = 5
End simplifyTop }
reportUnsolved {
reportUnsolved (before unflattening)
  WC {wc_impl = Implic {Untouchables = 1
                        Skolems = a
                        Flatten-skolems =
                        No-eqs = True
                        Given = $dFoo_ahR :: Foo a
                        Wanted = WC {wc_flat = [W] $dFoo_ahU :: Foo
                                                                  [a] [" a use of ‘op’ " p3.hs:14:9-10] (CNonCanonical)}
                        Binds = EvBindsVar<ahX>
                        the type signature for foo :: Foo a => [a] -> [a]}}
reportUnsolved (after unflattening):
  WC {wc_impl = Implic {Untouchables = 1
                        Skolems = a
                        Flatten-skolems =
                        No-eqs = True
                        Given = $dFoo_ahR :: Foo a
                        Wanted = WC {wc_flat = [W] $dFoo_ahU :: Foo
                                                                  [a] [" a use of ‘op’ " p3.hs:14:9-10] (CNonCanonical)}
                        Binds = EvBindsVar<ahX>
                        the type signature for foo :: Foo a => [a] -> [a]}}
reportFlats
  Flats = {}
  Suppress = False
tryReporters { []
tryReporters: no Utterly wrong
tryReporters: no Holes
tryReporters: no Skolem equalities
tryReporters: no Equalities
tryReporters: no Implicit params
tryReporters: no Irreds
tryReporters: no Dicts
tryReporters }
reportFlats
  Flats = {}
  Suppress = False
tryReporters { []
tryReporters: no Utterly wrong
tryReporters: no Holes
tryReporters: no Skolem equalities
tryReporters: no Equalities
tryReporters: no Implicit params
tryReporters: no Irreds
tryReporters: no Dicts
tryReporters }
reportFlats
  Flats = {}
  Suppress = False
tryReporters { []
tryReporters: no Utterly wrong
tryReporters: no Holes
tryReporters: no Skolem equalities
tryReporters: no Equalities
tryReporters: no Implicit params
tryReporters: no Irreds
tryReporters: no Dicts
tryReporters }
reportFlats
  Flats = {}
  Suppress = False
tryReporters { []
tryReporters: no Utterly wrong
tryReporters: no Holes
tryReporters: no Skolem equalities
tryReporters: no Equalities
tryReporters: no Implicit params
tryReporters: no Irreds
tryReporters: no Dicts
tryReporters }
reportFlats
  Flats = {}
  Suppress = False
tryReporters { []
tryReporters: no Utterly wrong
tryReporters: no Holes
tryReporters: no Skolem equalities
tryReporters: no Equalities
tryReporters: no Implicit params
tryReporters: no Irreds
tryReporters: no Dicts
tryReporters }
reportFlats
  Flats = {[W] $dFoo_ahU :: Foo
                              [a] [" a use of ‘op’ " p3.hs:14:9-10] (CNonCanonical)}
  Suppress = False
tryReporters {
  [[W] $dFoo_ahU :: Foo
                      [a] [" a use of ‘op’ " p3.hs:14:9-10] (CNonCanonical)]
tryReporters: no Utterly wrong
tryReporters: no Holes
tryReporters: no Skolem equalities
tryReporters: no Equalities
tryReporters: no Implicit params
tryReporters: no Irreds
tryReporters: yes
  Dicts [[W] $dFoo_ahU :: Foo
                            [a] [" a use of ‘op’ " p3.hs:14:9-10] (CNonCanonical)]
Adding error:
  p3.hs:14:9:
      Overlapping instances for Foo [a] arising from a use of ‘op’
      Matching instances:
        instance [overlap ok] Foo a => Foo [a] -- Defined at p3.hs:10:10
        instance [overlap ok] Foo [Int] -- Defined at p3.hs:11:10
      (The choice depends on the instantiation of ‘a’
       To pick the first instance above, use IncoherentInstances
       when compiling the other instance declarations)
      In the expression: op x
      In an equation for ‘foo’: foo x = op x
tryReporters }
reportUnsolved }
InstEnvs (External)
  instance Control.Applicative.Alternative []
    -- Defined in ‘Control.Applicative’
  instance Control.Monad.MonadPlus m =>
           Control.Applicative.Alternative
             (Control.Applicative.WrappedMonad m)
    -- Defined in ‘Control.Applicative’
  instance (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) =>
           Control.Applicative.Alternative
             (Control.Applicative.WrappedArrow a b)
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Alternative GHC.Conc.Sync.STM
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Alternative
             Text.ParserCombinators.ReadPrec.ReadPrec
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Alternative
             Text.ParserCombinators.ReadP.ReadP
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Alternative Maybe
    -- Defined in ‘Control.Applicative’
  instance Control.Arrow.ArrowPlus a =>
           Control.Applicative.Alternative (Control.Arrow.ArrowMonad a)
    -- Defined in ‘Control.Applicative’
  instance Enum GHC.Types.Word -- Defined in ‘GHC.Real’
  instance Integral a => Enum (GHC.Real.Ratio a)
    -- Defined in ‘GHC.Real’
  instance Enum Float -- Defined in ‘GHC.Float’
  instance Enum Double -- Defined in ‘GHC.Float’
  instance Eq a => Eq (Control.Applicative.ZipList a)
    -- Defined in ‘Control.Applicative’
  instance Eq a => Eq (GHC.Real.Ratio a) -- Defined in ‘GHC.Real’
  instance Floating Float -- Defined in ‘GHC.Float’
  instance Floating Double -- Defined in ‘GHC.Float’
  instance Integral a => Fractional (GHC.Real.Ratio a)
    -- Defined in ‘GHC.Real’
  instance Fractional Float -- Defined in ‘GHC.Float’
  instance Fractional Double -- Defined in ‘GHC.Float’
  instance Integral GHC.Types.Word -- Defined in ‘GHC.Real’
  instance Integral Integer -- Defined in ‘GHC.Real’
  instance Integral Int -- Defined in ‘GHC.Real’
  instance Monad m => Monad (Control.Applicative.WrappedMonad m)
    -- Defined in ‘Control.Applicative’
  instance Monad [] -- Defined in ‘GHC.Base’
  instance Monad IO -- Defined in ‘GHC.Base’
  instance Monad ((->) r) -- Defined in ‘GHC.Base’
  instance Functor Control.Applicative.ZipList
    -- Defined in ‘Control.Applicative’
  instance Monad m => Functor (Control.Applicative.WrappedMonad m)
    -- Defined in ‘Control.Applicative’
  instance Control.Arrow.Arrow a =>
           Functor (Control.Applicative.WrappedArrow a b)
    -- Defined in ‘Control.Applicative’
  instance Functor (Control.Applicative.Const m)
    -- Defined in ‘Control.Applicative’
  instance Functor [] -- Defined in ‘GHC.Base’
  instance Functor IO -- Defined in ‘GHC.Base’
  instance Functor ((->) r) -- Defined in ‘GHC.Base’
  instance Functor ((,) a) -- Defined in ‘GHC.Base’
  instance Integral a => Num (GHC.Real.Ratio a)
    -- Defined in ‘GHC.Real’
  instance Num Float -- Defined in ‘GHC.Float’
  instance Num Double -- Defined in ‘GHC.Float’
  instance Ord a => Ord (Control.Applicative.ZipList a)
    -- Defined in ‘Control.Applicative’
  instance Integral a => Ord (GHC.Real.Ratio a)
    -- Defined in ‘GHC.Real’
  instance Read a => Read (Control.Applicative.ZipList a)
    -- Defined in ‘Control.Applicative’
  instance Real GHC.Types.Word -- Defined in ‘GHC.Real’
  instance Integral a => Real (GHC.Real.Ratio a)
    -- Defined in ‘GHC.Real’
  instance Real Integer -- Defined in ‘GHC.Real’
  instance Real Int -- Defined in ‘GHC.Real’
  instance Real Float -- Defined in ‘GHC.Float’
  instance Real Double -- Defined in ‘GHC.Float’
  instance RealFloat Float -- Defined in ‘GHC.Float’
  instance RealFloat Double -- Defined in ‘GHC.Float’
  instance Integral a => RealFrac (GHC.Real.Ratio a)
    -- Defined in ‘GHC.Real’
  instance RealFrac Float -- Defined in ‘GHC.Float’
  instance RealFrac Double -- Defined in ‘GHC.Float’
  instance Show a => Show (Control.Applicative.ZipList a)
    -- Defined in ‘Control.Applicative’
  instance (Integral a, Show a) => Show (GHC.Real.Ratio a)
    -- Defined in ‘GHC.Real’
  instance Show Float -- Defined in ‘GHC.Float’
  instance Show Double -- Defined in ‘GHC.Float’
  instance Data.Typeable.Internal.Typeable
             Control.Applicative.Applicative
    -- Defined in ‘Control.Applicative’
  instance Data.Typeable.Internal.Typeable
             Control.Applicative.Alternative
    -- Defined in ‘Control.Applicative’
  instance Control.Monad.MonadPlus [] -- Defined in ‘Control.Monad’
  instance Control.Monad.MonadPlus Maybe
    -- Defined in ‘Control.Monad’
  instance Control.Applicative.Applicative []
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative
             Control.Applicative.ZipList
    -- Defined in ‘Control.Applicative’
  instance Monad m =>
           Control.Applicative.Applicative
             (Control.Applicative.WrappedMonad m)
    -- Defined in ‘Control.Applicative’
  instance Control.Arrow.Arrow a =>
           Control.Applicative.Applicative
             (Control.Applicative.WrappedArrow a b)
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative GHC.Conc.Sync.STM
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative (GHC.ST.ST s)
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative
             (base:Control.Monad.ST.Lazy.Imp.ST s)
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative
             Text.ParserCombinators.ReadPrec.ReadPrec
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative
             Text.ParserCombinators.ReadP.ReadP
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative Data.Proxy.Proxy
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative Maybe
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative IO
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative (Either e)
    -- Defined in ‘Control.Applicative’
  instance Data.Monoid.Monoid m =>
           Control.Applicative.Applicative (Control.Applicative.Const m)
    -- Defined in ‘Control.Applicative’
  instance Control.Arrow.Arrow a =>
           Control.Applicative.Applicative (Control.Arrow.ArrowMonad a)
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative ((->) a)
    -- Defined in ‘Control.Applicative’
  instance Data.Monoid.Monoid a =>
           Control.Applicative.Applicative ((,) a)
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Generic (Control.Applicative.ZipList a)
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Generic
             (Control.Applicative.WrappedMonad m a)
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Generic
             (Control.Applicative.WrappedArrow a b c)
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Generic (Control.Applicative.Const a b)
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Generic1 Control.Applicative.ZipList
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Generic1 (Control.Applicative.WrappedMonad m)
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Generic1
             (Control.Applicative.WrappedArrow a b)
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Generic1 (Control.Applicative.Const a)
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Datatype Control.Applicative.D1ZipList
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Datatype Control.Applicative.D1WrappedMonad
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Datatype Control.Applicative.D1WrappedArrow
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Datatype Control.Applicative.D1Const
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Constructor Control.Applicative.C1_0ZipList
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Constructor
             Control.Applicative.C1_0WrappedMonad
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Constructor
             Control.Applicative.C1_0WrappedArrow
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Constructor Control.Applicative.C1_0Const
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Selector Control.Applicative.S1_0_0ZipList
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Selector
             Control.Applicative.S1_0_0WrappedMonad
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Selector
             Control.Applicative.S1_0_0WrappedArrow
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Selector Control.Applicative.S1_0_0Const
    -- Defined in ‘Control.Applicative’
  instance Data.Monoid.Monoid a =>
           Data.Monoid.Monoid (Control.Applicative.Const a b)
    -- Defined in ‘Control.Applicative’
InstEnvs (Internal)
  instance [overlap ok] Foo a => Foo [a] -- Defined at p3.hs:10:10
  instance [overlap ok] Foo [Int] -- Defined at p3.hs:11:10
famInstEnvs (External)
  type GHC.Generics.Rep Char
    == GHC.Generics.D1
         GHC.Generics.D_Char
         (GHC.Generics.C1
            GHC.Generics.C_Char
            (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 Char)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep Double
    == GHC.Generics.D1
         GHC.Generics.D_Double
         (GHC.Generics.C1
            GHC.Generics.C_Double
            (GHC.Generics.S1
               GHC.Generics.NoSelector (GHC.Generics.Rec0 Double)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep Float
    == GHC.Generics.D1
         GHC.Generics.D_Float
         (GHC.Generics.C1
            GHC.Generics.C_Float
            (GHC.Generics.S1
               GHC.Generics.NoSelector (GHC.Generics.Rec0 Float)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep Int
    == GHC.Generics.D1
         GHC.Generics.D_Int
         (GHC.Generics.C1
            GHC.Generics.C_Int
            (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 Int)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (Data.Proxy.Proxy t)
    == GHC.Generics.D1
         GHC.Generics.D1Proxy
         (GHC.Generics.C1 GHC.Generics.C1_0Proxy GHC.Generics.U1)
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (a, b, c, d, e, f, g)
    == GHC.Generics.D1
         GHC.Generics.D1(,,,,,,)
         (GHC.Generics.C1
            GHC.Generics.C1_0(,,,,,,)
            ((GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
              GHC.Generics.:*: (GHC.Generics.S1
                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 b)
                                GHC.Generics.:*: GHC.Generics.S1
                                                   GHC.Generics.NoSelector (GHC.Generics.Rec0 c)))
             GHC.Generics.:*: ((GHC.Generics.S1
                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 d)
                                GHC.Generics.:*: GHC.Generics.S1
                                                   GHC.Generics.NoSelector (GHC.Generics.Rec0 e))
                               GHC.Generics.:*: (GHC.Generics.S1
                                                   GHC.Generics.NoSelector (GHC.Generics.Rec0 f)
                                                 GHC.Generics.:*: GHC.Generics.S1
                                                                    GHC.Generics.NoSelector
                                                                    (GHC.Generics.Rec0 g)))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (a, b, c, d, e, f)
    == GHC.Generics.D1
         GHC.Generics.D1(,,,,,)
         (GHC.Generics.C1
            GHC.Generics.C1_0(,,,,,)
            ((GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
              GHC.Generics.:*: (GHC.Generics.S1
                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 b)
                                GHC.Generics.:*: GHC.Generics.S1
                                                   GHC.Generics.NoSelector (GHC.Generics.Rec0 c)))
             GHC.Generics.:*: (GHC.Generics.S1
                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 d)
                               GHC.Generics.:*: (GHC.Generics.S1
                                                   GHC.Generics.NoSelector (GHC.Generics.Rec0 e)
                                                 GHC.Generics.:*: GHC.Generics.S1
                                                                    GHC.Generics.NoSelector
                                                                    (GHC.Generics.Rec0 f)))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (a, b, c, d, e)
    == GHC.Generics.D1
         GHC.Generics.D1(,,,,)
         (GHC.Generics.C1
            GHC.Generics.C1_0(,,,,)
            ((GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
              GHC.Generics.:*: GHC.Generics.S1
                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 b))
             GHC.Generics.:*: (GHC.Generics.S1
                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 c)
                               GHC.Generics.:*: (GHC.Generics.S1
                                                   GHC.Generics.NoSelector (GHC.Generics.Rec0 d)
                                                 GHC.Generics.:*: GHC.Generics.S1
                                                                    GHC.Generics.NoSelector
                                                                    (GHC.Generics.Rec0 e)))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (a, b, c, d)
    == GHC.Generics.D1
         GHC.Generics.D1(,,,)
         (GHC.Generics.C1
            GHC.Generics.C1_0(,,,)
            ((GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
              GHC.Generics.:*: GHC.Generics.S1
                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 b))
             GHC.Generics.:*: (GHC.Generics.S1
                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 c)
                               GHC.Generics.:*: GHC.Generics.S1
                                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 d))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (a, b, c)
    == GHC.Generics.D1
         GHC.Generics.D1(,,)
         (GHC.Generics.C1
            GHC.Generics.C1_0(,,)
            (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
             GHC.Generics.:*: (GHC.Generics.S1
                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 b)
                               GHC.Generics.:*: GHC.Generics.S1
                                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 c))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (a, b)
    == GHC.Generics.D1
         GHC.Generics.D1(,)
         (GHC.Generics.C1
            GHC.Generics.C1_0(,)
            (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
             GHC.Generics.:*: GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 b)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep ()
    == GHC.Generics.D1
         GHC.Generics.D1()
         (GHC.Generics.C1 GHC.Generics.C1_0() GHC.Generics.U1)
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep Ordering
    == GHC.Generics.D1
         GHC.Generics.D1Ordering
         (GHC.Generics.C1 GHC.Generics.C1_0Ordering GHC.Generics.U1
          GHC.Generics.:+: (GHC.Generics.C1
                              GHC.Generics.C1_1Ordering GHC.Generics.U1
                            GHC.Generics.:+: GHC.Generics.C1
                                               GHC.Generics.C1_2Ordering GHC.Generics.U1))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep Bool
    == GHC.Generics.D1
         GHC.Generics.D1Bool
         (GHC.Generics.C1 GHC.Generics.C1_0Bool GHC.Generics.U1
          GHC.Generics.:+: GHC.Generics.C1
                             GHC.Generics.C1_1Bool GHC.Generics.U1)
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (Either a b)
    == GHC.Generics.D1
         GHC.Generics.D1Either
         (GHC.Generics.C1
            GHC.Generics.C1_0Either
            (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a))
          GHC.Generics.:+: GHC.Generics.C1
                             GHC.Generics.C1_1Either
                             (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 b)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (Maybe a)
    == GHC.Generics.D1
         GHC.Generics.D1Maybe
         (GHC.Generics.C1 GHC.Generics.C1_0Maybe GHC.Generics.U1
          GHC.Generics.:+: GHC.Generics.C1
                             GHC.Generics.C1_1Maybe
                             (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep [a]
    == GHC.Generics.D1
         GHC.Generics.D1[]
         (GHC.Generics.C1 GHC.Generics.C1_0[] GHC.Generics.U1
          GHC.Generics.:+: GHC.Generics.C1
                             GHC.Generics.C1_1[]
                             (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
                              GHC.Generics.:*: GHC.Generics.S1
                                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 [a])))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (GHC.Generics.U1 p)
    == GHC.Generics.D1
         GHC.Generics.D1U1
         (GHC.Generics.C1 GHC.Generics.C1_0U1 GHC.Generics.U1)
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (GHC.Generics.Par1 p)
    == GHC.Generics.D1
         GHC.Generics.D1Par1
         (GHC.Generics.C1
            GHC.Generics.C1_0Par1
            (GHC.Generics.S1 GHC.Generics.S1_0_0Par1 (GHC.Generics.Rec0 p)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (GHC.Generics.Rec1 f p)
    == GHC.Generics.D1
         GHC.Generics.D1Rec1
         (GHC.Generics.C1
            GHC.Generics.C1_0Rec1
            (GHC.Generics.S1
               GHC.Generics.S1_0_0Rec1 (GHC.Generics.Rec0 (f p))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (GHC.Generics.K1 i c p)
    == GHC.Generics.D1
         GHC.Generics.D1K1
         (GHC.Generics.C1
            GHC.Generics.C1_0K1
            (GHC.Generics.S1 GHC.Generics.S1_0_0K1 (GHC.Generics.Rec0 c)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (GHC.Generics.M1 i c f p)
    == GHC.Generics.D1
         GHC.Generics.D1M1
         (GHC.Generics.C1
            GHC.Generics.C1_0M1
            (GHC.Generics.S1 GHC.Generics.S1_0_0M1 (GHC.Generics.Rec0 (f p))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep ((GHC.Generics.:+:) f g p)
    == GHC.Generics.D1
         GHC.Generics.D1:+:
         (GHC.Generics.C1
            GHC.Generics.C1_0:+:
            (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 (f p)))
          GHC.Generics.:+: GHC.Generics.C1
                             GHC.Generics.C1_1:+:
                             (GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 (g p))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep ((GHC.Generics.:*:) f g p)
    == GHC.Generics.D1
         GHC.Generics.D1:*:
         (GHC.Generics.C1
            GHC.Generics.C1_0:*:
            (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 (f p))
             GHC.Generics.:*: GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 (g p))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep ((GHC.Generics.:.:) f g p)
    == GHC.Generics.D1
         GHC.Generics.D1:.:
         (GHC.Generics.C1
            GHC.Generics.C1_0:.:
            (GHC.Generics.S1
               GHC.Generics.S1_0_0:.: (GHC.Generics.Rec0 (f (g p)))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep GHC.Generics.Associativity
    == GHC.Generics.D1
         GHC.Generics.D1Associativity
         (GHC.Generics.C1 GHC.Generics.C1_0Associativity GHC.Generics.U1
          GHC.Generics.:+: (GHC.Generics.C1
                              GHC.Generics.C1_1Associativity GHC.Generics.U1
                            GHC.Generics.:+: GHC.Generics.C1
                                               GHC.Generics.C1_2Associativity GHC.Generics.U1))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep GHC.Generics.Fixity
    == GHC.Generics.D1
         GHC.Generics.D1Fixity
         (GHC.Generics.C1 GHC.Generics.C1_0Fixity GHC.Generics.U1
          GHC.Generics.:+: GHC.Generics.C1
                             GHC.Generics.C1_1Fixity
                             (GHC.Generics.S1
                                GHC.Generics.NoSelector
                                (GHC.Generics.Rec0 GHC.Generics.Associativity)
                              GHC.Generics.:*: GHC.Generics.S1
                                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 Int)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep GHC.Generics.Arity
    == GHC.Generics.D1
         GHC.Generics.D1Arity
         (GHC.Generics.C1 GHC.Generics.C1_0Arity GHC.Generics.U1
          GHC.Generics.:+: GHC.Generics.C1
                             GHC.Generics.C1_1Arity
                             (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 Int)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (Data.Monoid.Dual a)
    == GHC.Generics.D1
         Data.Monoid.D1Dual
         (GHC.Generics.C1
            Data.Monoid.C1_0Dual
            (GHC.Generics.S1 Data.Monoid.S1_0_0Dual (GHC.Generics.Rec0 a)))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep (Data.Monoid.Endo a)
    == GHC.Generics.D1
         Data.Monoid.D1Endo
         (GHC.Generics.C1
            Data.Monoid.C1_0Endo
            (GHC.Generics.S1
               Data.Monoid.S1_0_0Endo (GHC.Generics.Rec0 (a -> a))))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep Data.Monoid.All
    == GHC.Generics.D1
         Data.Monoid.D1All
         (GHC.Generics.C1
            Data.Monoid.C1_0All
            (GHC.Generics.S1 Data.Monoid.S1_0_0All (GHC.Generics.Rec0 Bool)))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep Data.Monoid.Any
    == GHC.Generics.D1
         Data.Monoid.D1Any
         (GHC.Generics.C1
            Data.Monoid.C1_0Any
            (GHC.Generics.S1 Data.Monoid.S1_0_0Any (GHC.Generics.Rec0 Bool)))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep (Data.Monoid.Sum a)
    == GHC.Generics.D1
         Data.Monoid.D1Sum
         (GHC.Generics.C1
            Data.Monoid.C1_0Sum
            (GHC.Generics.S1 Data.Monoid.S1_0_0Sum (GHC.Generics.Rec0 a)))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep (Data.Monoid.Product a)
    == GHC.Generics.D1
         Data.Monoid.D1Product
         (GHC.Generics.C1
            Data.Monoid.C1_0Product
            (GHC.Generics.S1 Data.Monoid.S1_0_0Product (GHC.Generics.Rec0 a)))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep (Data.Monoid.First a)
    == GHC.Generics.D1
         Data.Monoid.D1First
         (GHC.Generics.C1
            Data.Monoid.C1_0First
            (GHC.Generics.S1
               Data.Monoid.S1_0_0First (GHC.Generics.Rec0 (Maybe a))))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep (Data.Monoid.Last a)
    == GHC.Generics.D1
         Data.Monoid.D1Last
         (GHC.Generics.C1
            Data.Monoid.C1_0Last
            (GHC.Generics.S1
               Data.Monoid.S1_0_0Last (GHC.Generics.Rec0 (Maybe a))))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep (Control.Applicative.Const a b)
    == GHC.Generics.D1
         Control.Applicative.D1Const
         (GHC.Generics.C1
            Control.Applicative.C1_0Const
            (GHC.Generics.S1
               Control.Applicative.S1_0_0Const (GHC.Generics.Rec0 a)))
    -- Defined in ‘Control.Applicative’
  type GHC.Generics.Rep (Control.Applicative.WrappedMonad m a)
    == GHC.Generics.D1
         Control.Applicative.D1WrappedMonad
         (GHC.Generics.C1
            Control.Applicative.C1_0WrappedMonad
            (GHC.Generics.S1
               Control.Applicative.S1_0_0WrappedMonad (GHC.Generics.Rec0 (m a))))
    -- Defined in ‘Control.Applicative’
  type GHC.Generics.Rep (Control.Applicative.WrappedArrow a b c)
    == GHC.Generics.D1
         Control.Applicative.D1WrappedArrow
         (GHC.Generics.C1
            Control.Applicative.C1_0WrappedArrow
            (GHC.Generics.S1
               Control.Applicative.S1_0_0WrappedArrow
               (GHC.Generics.Rec0 (a b c))))
    -- Defined in ‘Control.Applicative’
  type GHC.Generics.Rep (Control.Applicative.ZipList a)
    == GHC.Generics.D1
         Control.Applicative.D1ZipList
         (GHC.Generics.C1
            Control.Applicative.C1_0ZipList
            (GHC.Generics.S1
               Control.Applicative.S1_0_0ZipList (GHC.Generics.Rec0 [a])))
    -- Defined in ‘Control.Applicative’
  type GHC.Generics.Rep1 ((,,,,,,) a b c d e f)
    == GHC.Generics.D1
         GHC.Generics.D1(,,,,,,)
         (GHC.Generics.C1
            GHC.Generics.C1_0(,,,,,,)
            ((GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
              GHC.Generics.:*: (GHC.Generics.S1
                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 b)
                                GHC.Generics.:*: GHC.Generics.S1
                                                   GHC.Generics.NoSelector (GHC.Generics.Rec0 c)))
             GHC.Generics.:*: ((GHC.Generics.S1
                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 d)
                                GHC.Generics.:*: GHC.Generics.S1
                                                   GHC.Generics.NoSelector (GHC.Generics.Rec0 e))
                               GHC.Generics.:*: (GHC.Generics.S1
                                                   GHC.Generics.NoSelector (GHC.Generics.Rec0 f)
                                                 GHC.Generics.:*: GHC.Generics.S1
                                                                    GHC.Generics.NoSelector
                                                                    GHC.Generics.Par1))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 ((,,,,,) a b c d e)
    == GHC.Generics.D1
         GHC.Generics.D1(,,,,,)
         (GHC.Generics.C1
            GHC.Generics.C1_0(,,,,,)
            ((GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
              GHC.Generics.:*: (GHC.Generics.S1
                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 b)
                                GHC.Generics.:*: GHC.Generics.S1
                                                   GHC.Generics.NoSelector (GHC.Generics.Rec0 c)))
             GHC.Generics.:*: (GHC.Generics.S1
                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 d)
                               GHC.Generics.:*: (GHC.Generics.S1
                                                   GHC.Generics.NoSelector (GHC.Generics.Rec0 e)
                                                 GHC.Generics.:*: GHC.Generics.S1
                                                                    GHC.Generics.NoSelector
                                                                    GHC.Generics.Par1))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 ((,,,,) a b c d)
    == GHC.Generics.D1
         GHC.Generics.D1(,,,,)
         (GHC.Generics.C1
            GHC.Generics.C1_0(,,,,)
            ((GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
              GHC.Generics.:*: GHC.Generics.S1
                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 b))
             GHC.Generics.:*: (GHC.Generics.S1
                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 c)
                               GHC.Generics.:*: (GHC.Generics.S1
                                                   GHC.Generics.NoSelector (GHC.Generics.Rec0 d)
                                                 GHC.Generics.:*: GHC.Generics.S1
                                                                    GHC.Generics.NoSelector
                                                                    GHC.Generics.Par1))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 ((,,,) a b c)
    == GHC.Generics.D1
         GHC.Generics.D1(,,,)
         (GHC.Generics.C1
            GHC.Generics.C1_0(,,,)
            ((GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
              GHC.Generics.:*: GHC.Generics.S1
                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 b))
             GHC.Generics.:*: (GHC.Generics.S1
                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 c)
                               GHC.Generics.:*: GHC.Generics.S1
                                                  GHC.Generics.NoSelector GHC.Generics.Par1)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 ((,,) a b)
    == GHC.Generics.D1
         GHC.Generics.D1(,,)
         (GHC.Generics.C1
            GHC.Generics.C1_0(,,)
            (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
             GHC.Generics.:*: (GHC.Generics.S1
                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 b)
                               GHC.Generics.:*: GHC.Generics.S1
                                                  GHC.Generics.NoSelector GHC.Generics.Par1)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 ((,) a)
    == GHC.Generics.D1
         GHC.Generics.D1(,)
         (GHC.Generics.C1
            GHC.Generics.C1_0(,)
            (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
             GHC.Generics.:*: GHC.Generics.S1
                                GHC.Generics.NoSelector GHC.Generics.Par1))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 (Either a)
    == GHC.Generics.D1
         GHC.Generics.D1Either
         (GHC.Generics.C1
            GHC.Generics.C1_0Either
            (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a))
          GHC.Generics.:+: GHC.Generics.C1
                             GHC.Generics.C1_1Either
                             (GHC.Generics.S1 GHC.Generics.NoSelector GHC.Generics.Par1))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 Maybe
    == GHC.Generics.D1
         GHC.Generics.D1Maybe
         (GHC.Generics.C1 GHC.Generics.C1_0Maybe GHC.Generics.U1
          GHC.Generics.:+: GHC.Generics.C1
                             GHC.Generics.C1_1Maybe
                             (GHC.Generics.S1 GHC.Generics.NoSelector GHC.Generics.Par1))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 []
    == GHC.Generics.D1
         GHC.Generics.D1[]
         (GHC.Generics.C1 GHC.Generics.C1_0[] GHC.Generics.U1
          GHC.Generics.:+: GHC.Generics.C1
                             GHC.Generics.C1_1[]
                             (GHC.Generics.S1 GHC.Generics.NoSelector GHC.Generics.Par1
                              GHC.Generics.:*: GHC.Generics.S1
                                                 GHC.Generics.NoSelector (GHC.Generics.Rec1 [])))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 Data.Monoid.Dual
    == GHC.Generics.D1
         Data.Monoid.D1Dual
         (GHC.Generics.C1
            Data.Monoid.C1_0Dual
            (GHC.Generics.S1 Data.Monoid.S1_0_0Dual GHC.Generics.Par1))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep1 Data.Monoid.Sum
    == GHC.Generics.D1
         Data.Monoid.D1Sum
         (GHC.Generics.C1
            Data.Monoid.C1_0Sum
            (GHC.Generics.S1 Data.Monoid.S1_0_0Sum GHC.Generics.Par1))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep1 Data.Monoid.Product
    == GHC.Generics.D1
         Data.Monoid.D1Product
         (GHC.Generics.C1
            Data.Monoid.C1_0Product
            (GHC.Generics.S1 Data.Monoid.S1_0_0Product GHC.Generics.Par1))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep1 Data.Monoid.First
    == GHC.Generics.D1
         Data.Monoid.D1First
         (GHC.Generics.C1
            Data.Monoid.C1_0First
            (GHC.Generics.S1
               Data.Monoid.S1_0_0First (GHC.Generics.Rec1 Maybe)))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep1 Data.Monoid.Last
    == GHC.Generics.D1
         Data.Monoid.D1Last
         (GHC.Generics.C1
            Data.Monoid.C1_0Last
            (GHC.Generics.S1 Data.Monoid.S1_0_0Last (GHC.Generics.Rec1 Maybe)))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep1 (Control.Applicative.Const a)
    == GHC.Generics.D1
         Control.Applicative.D1Const
         (GHC.Generics.C1
            Control.Applicative.C1_0Const
            (GHC.Generics.S1
               Control.Applicative.S1_0_0Const (GHC.Generics.Rec0 a)))
    -- Defined in ‘Control.Applicative’
  type GHC.Generics.Rep1 (Control.Applicative.WrappedMonad m)
    == GHC.Generics.D1
         Control.Applicative.D1WrappedMonad
         (GHC.Generics.C1
            Control.Applicative.C1_0WrappedMonad
            (GHC.Generics.S1
               Control.Applicative.S1_0_0WrappedMonad (GHC.Generics.Rec1 m)))
    -- Defined in ‘Control.Applicative’
  type GHC.Generics.Rep1 (Control.Applicative.WrappedArrow a b)
    == GHC.Generics.D1
         Control.Applicative.D1WrappedArrow
         (GHC.Generics.C1
            Control.Applicative.C1_0WrappedArrow
            (GHC.Generics.S1
               Control.Applicative.S1_0_0WrappedArrow (GHC.Generics.Rec1 (a b))))
    -- Defined in ‘Control.Applicative’
  type GHC.Generics.Rep1 Control.Applicative.ZipList
    == GHC.Generics.D1
         Control.Applicative.D1ZipList
         (GHC.Generics.C1
            Control.Applicative.C1_0ZipList
            (GHC.Generics.S1
               Control.Applicative.S1_0_0ZipList (GHC.Generics.Rec1 [])))
    -- Defined in ‘Control.Applicative’
  type instance a Data.Type.Equality.== b
    == Data.Either.EqEither a b
    -- Defined in ‘Data.Either’
famInstEnvs (Internal)
originalCts (simplifyTop)
  fvars =  [(ahT, a_ahT)]
  wanted =  WC {wc_impl = Implic {Untouchables = 1
                                  Skolems = a
                                  Flatten-skolems =
                                  No-eqs = False
                                  Given = $dFoo_ahR :: Foo a
                                  Wanted = WC {wc_flat = [W] $dFoo_ahU :: Foo
                                                                            a_ahT [" a use of ‘op’ " p3.hs:14:9-10] (CNonCanonical)
                                                         [W] cobox_ahV :: a_ahT
                                                                          ~ [a] [" a type equality a_ahT
                                                                                                   ~
                                                                                                   [a] " p3.hs:14:9-12] (CNonCanonical)
                                                         [W] cobox_ahW :: [a]
                                                                          ~ a_ahT [" a type equality [a]
                                                                                                     ~
                                                                                                     a_ahT " p3.hs:14:12] (CNonCanonical)}
                                  Binds = EvBindsVar<ahX>
                                  the type signature for foo :: Foo a => [a] -> [a]}
                          Implic {Untouchables = 1
                                  Skolems = a
                                  Flatten-skolems =
                                  No-eqs = False
                                  Given = $dFoo_ai2 :: Foo a
                                  Wanted = WC {}
                                  Binds = EvBindsVar<ai3>
                                  the instance declaration}}
Tc9

p3.hs:14:9:
    Overlapping instances for Foo [a] arising from a use of ‘op’
    Matching instances:
      instance [overlap ok] Foo a => Foo [a] -- Defined at p3.hs:10:10
      instance [overlap ok] Foo [Int] -- Defined at p3.hs:11:10
    (The choice depends on the instantiation of ‘a’
     To pick the first instance above, use IncoherentInstances
     when compiling the other instance declarations)
    In the expression: op x
    In an equation for ‘foo’: foo x = op x
