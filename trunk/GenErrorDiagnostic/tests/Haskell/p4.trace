rn12
rn13
Tc2 (src)
Tc3
kcTyClGroup
  module Main
  type FlatVector = UArray Int Double
kcTyClGroup: initial kinds []
env2 []
kcd1 FlatVector []
tc_lhs_type:
  UArray Int Double
  Expected kind ‘k_ajz’
tc_lhs_type:
  UArray
  Expected kind ‘k_ajA’
lk1 UArray
lk2 UArray Type constructor ‘UArray’
writeMetaTyVar k_ajA := * -> * -> *
tc_lhs_type:
  Int
  The first argument of ‘UArray’ should have kind ‘*’
lk1 Int
lk2 Int Type constructor ‘Int’
tc_lhs_type:
  Double
  The second argument of ‘UArray’ should have kind ‘*’
lk1 Double
lk2 Double Type constructor ‘Double’
writeMetaTyVar k_ajz := *
kcd2 FlatVector
Generalise kind
  FlatVector
  k_ajz
  []
  *
kcTyClGroup result [(FlatVector, *)]
tcTyAndCl generalized kinds [(FlatVector, *)]
tcTyAndCl-x type FlatVector = UArray Int Double
env2 []
env2 []
tc-syn
  FlatVector
  [(r9A, AThing *)]
tc_lhs_type:
  UArray Int Double
  Expected kind ‘*’
tc_lhs_type:
  UArray
  Expected kind ‘k_ajJ’
lk1 UArray
lk2 UArray Type constructor ‘UArray’
writeMetaTyVar k_ajJ := * -> * -> *
tc_lhs_type:
  Int
  The first argument of ‘UArray’ should have kind ‘*’
lk1 Int
lk2 Int Type constructor ‘Int’
tc_lhs_type:
  Double
  The second argument of ‘UArray’ should have kind ‘*’
lk1 Double
lk2 Double Type constructor ‘Double’
Starting validity check [Type constructor ‘FlatVector’]
checkValidType UArray Int Double :: *
checkValidType done UArray Int Double :: *
env2 []
kcTyClGroup
  module Main
  type Vector a = Array Int a
kcTyClGroup: initial kinds []
env2 []
kcd1 Vector [a]
tc_lhs_type:
  Array Int a
  Expected kind ‘k_ajL’
tc_lhs_type:
  Array
  Expected kind ‘k_ajM’
lk1 Array
lk2 Array Type constructor ‘Array’
writeMetaTyVar k_ajM := * -> * -> *
tc_lhs_type:
  Int
  The first argument of ‘Array’ should have kind ‘*’
lk1 Int
lk2 Int Type constructor ‘Int’
tc_lhs_type:
  a
  The second argument of ‘Array’ should have kind ‘*’
lk1 a
lk2 a AThing k_ajK
writeMetaTyVar k_ajK := *
writeMetaTyVar k_ajL := *
kcd2 Vector
Generalise kind
  Vector
  k_ajK -> k_ajL
  []
  * -> *
kcTyClGroup result [(Vector, * -> *)]
tcTyAndCl generalized kinds [(Vector, * -> *)]
tcTyAndCl-x type Vector a = Array Int a
env2 []
env2 [(a, Type variable ‘a’ = a)]
tc-syn
  Vector
  [(a9F, Type variable ‘a’ = a), (r8Q, AThing * -> *)]
tc_lhs_type:
  Array Int a
  Expected kind ‘*’
tc_lhs_type:
  Array
  Expected kind ‘k_ajV’
lk1 Array
lk2 Array Type constructor ‘Array’
writeMetaTyVar k_ajV := * -> * -> *
tc_lhs_type:
  Int
  The first argument of ‘Array’ should have kind ‘*’
lk1 Int
lk2 Int Type constructor ‘Int’
tc_lhs_type:
  a
  The second argument of ‘Array’ should have kind ‘*’
lk1 a
lk2 a Type variable ‘a’ = a
Starting validity check [Type constructor ‘Vector’]
checkValidType Array Int a :: *
checkValidType done Array Int a :: *
env2 []
Adding instances:
addFamInsts
env2 []
tcDeriving
tcDeriving False
tcDeriving 1 []
Adding instances:
Tc3b
tcAmpMissingParentClassWarn/isInsts []
tcAmpMissingParentClassWarn/isInsts []
tcAmpFunctionWarn/wouldBeImported
tcAmpFunctionWarn/amp_prelude_functions Control.Monad.join []
tcAmpFunctionWarn/wouldBeImported
tcAmpFunctionWarn/amp_prelude_functions Control.Applicative.<*> []
tcAmpFunctionWarn/wouldBeImported
tcAmpFunctionWarn/amp_prelude_functions Control.Applicative.pure []
Tc4
Tc4a
env2 []
Tc5
env2 []
tcHsTyVarBndrs {
  Hs kind vars: []
  Hs type vars: [a]
  Kind vars: []
  Type vars: [a]
env2 [(a, Type variable ‘a’ = a)]
tc_lhs_type:
  (Int, Int) -> [a] -> Vector a
  Expected a type
tc_lhs_type:
  (Int, Int)
  Expected a type
tc_lhs_type:
  Int
  Expected kind ‘k_aqd’
lk1 Int
lk2 Int Type constructor ‘Int’
writeMetaTyVar k_aqd := *
tc_lhs_type:
  Int
  Expected kind ‘k_aqe’
lk1 Int
lk2 Int Type constructor ‘Int’
writeMetaTyVar k_aqe := *
tc_lhs_type:
  [a] -> Vector a
  Expected a type
tc_lhs_type:
  [a]
  Expected a type
tc_lhs_type:
  a
  Expected kind ‘*’
lk1 a
lk2 a Type variable ‘a’ = a
writeMetaTyVar k_aqc := *
tc_lhs_type:
  Vector a
  Expected a type
tc_lhs_type:
  Vector
  Expected kind ‘k_aqf’
lk1 Vector
lk2 Vector Type constructor ‘Vector’
writeMetaTyVar k_aqf := * -> *
tc_lhs_type:
  a
  The first argument of ‘Vector’ should have kind ‘*’
lk1 a
lk2 a Type variable ‘a’ = a
tcHsTyVarBndrs }
  Hs kind vars: []
  Hs type vars: [a]
  Kind vars: []
  Type vars: [a]
tcCheckHsTypeAndGen (Int, Int) -> [a] -> Vector a
checkValidType forall a. (Int, Int) -> [a] -> Vector a :: *
Ambiguity check for forall a. (Int, Int) -> [a] -> Vector a
tcGen
u_tys 
  untch 1
  (Int, Int) -> [a_aqi] -> Vector a_aqi
  ~
  (Int, Int) -> [a] -> Vector a
  a type equality (Int, Int) -> [a_aqi] -> Vector a_aqi
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys 
  untch 1
  (Int, Int) ~ (Int, Int)
  a type equality (Int, Int) -> [a_aqi] -> Vector a_aqi
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys 
  untch 1
  Int ~ Int
  a type equality (Int, Int) -> [a_aqi] -> Vector a_aqi
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys yields no coercion
u_tys 
  untch 1
  Int ~ Int
  a type equality (Int, Int) -> [a_aqi] -> Vector a_aqi
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys yields no coercion
u_tys yields no coercion
u_tys 
  untch 1
  [a_aqi] -> Vector a_aqi ~ [a] -> Vector a
  a type equality (Int, Int) -> [a_aqi] -> Vector a_aqi
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys 
  untch 1
  [a_aqi] ~ [a]
  a type equality (Int, Int) -> [a_aqi] -> Vector a_aqi
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys 
  untch 1
  a_aqi ~ a
  a type equality (Int, Int) -> [a_aqi] -> Vector a_aqi
                  ~
                  (Int, Int) -> [a] -> Vector a
uUnfilledVars trying to unify * with *
writeMetaTyVar a_aqi := a
u_tys yields no coercion
u_tys yields no coercion
u_tys 
  untch 1
  Vector a_aqi ~ Vector a
  a type equality (Int, Int) -> [a_aqi] -> Vector a_aqi
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys 
  untch 1
  Int ~ Int
  a type equality (Int, Int) -> [a_aqi] -> Vector a_aqi
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys yields no coercion
u_tys 
  untch 1
  a_aqi ~ a
  a type equality (Int, Int) -> [a_aqi] -> Vector a_aqi
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys yields no coercion
u_tys yields no coercion
u_tys yields no coercion
u_tys yields no coercion
simplifyAmbiguityCheck {
  type =  forall a. (Int, Int) -> [a] -> Vector a
  wanted =  WC {}
solveWantedsTcMWithEvBinds wanted= WC {}
solveWanteds { WC {}
solveFlats {
solveFlats end } {}
simpl_loop, iteration 1
solveWanteds }
  unsolved_flats   = {}
  unsolved_implics = {}
  current evbinds  = {}
  current tybinds  =
  final wc = WC {}
End simplifyAmbiguityCheck }
reportUnsolved(ambig) {
reportUnsolved(ambig) }
Done ambiguity check for forall a. (Int, Int) -> [a] -> Vector a
checkValidType done forall a. (Int, Int) -> [a] -> Vector a :: *
tc_lhs_type:
  (Int, Int)
  Expected a type
tc_lhs_type:
  Int
  Expected kind ‘k_aqn’
lk1 Int
lk2 Int Type constructor ‘Int’
writeMetaTyVar k_aqn := *
tc_lhs_type:
  Int
  Expected kind ‘k_aqo’
lk1 Int
lk2 Int Type constructor ‘Int’
writeMetaTyVar k_aqo := *
tc_lhs_type:
  [Double] -> FlatVector
  Expected a type
tc_lhs_type:
  [Double]
  Expected a type
tc_lhs_type:
  Double
  Expected kind ‘*’
lk1 Double
lk2 Double Type constructor ‘Double’
tc_lhs_type:
  FlatVector
  Expected a type
lk1 FlatVector
lk2 FlatVector Type constructor ‘FlatVector’
tcCheckHsTypeAndGen (Int, Int) -> [Double] -> FlatVector
checkValidType (Int, Int) -> [Double] -> FlatVector :: *
checkValidType done (Int, Int) -> [Double] -> FlatVector :: *
tc_lhs_type:
  IO
  Expected kind ‘k_aqp’
lk1 IO
lk2 IO Type constructor ‘IO’
writeMetaTyVar k_aqp := * -> *
tc_lhs_type:
  ()
  The first argument of ‘IO’ should have kind ‘*’
tcCheckHsTypeAndGen IO ()
checkValidType IO () :: *
checkValidType done IO () :: *
env2
  [(listVector,
    Identifier[listVector::forall a.
                           (Int, Int) -> [a] -> Vector a, <NotTopLevel>]),
   (listFlatVector,
    Identifier[listFlatVector::(Int, Int)
                               -> [Double] -> FlatVector, <NotTopLevel>]),
   (main, Identifier[main::IO (), <NotTopLevel>])]
------------------------------------------------
Bindings for { [listVector]
Generalisation plan
  CheckGen listVector :: (Int, Int) -> [a] -> Vector a
                         [Nothing]
env2 []
tcMonoBinds
env2 []
tcRhs: fun bind
  listVector
  (Int, Int) -> [a] -> Vector a
tcMatchesFun
  listVector
  (Int, Int) -> [a] -> Vector a
tcGen
tcBody (Int, Int) -> [a] -> Vector a
Instantiating
  listArray with [i_aqY, e_aqZ, a_ar0]
                 [Data.Array.Base.IArray a_ar0 e_aqZ, GHC.Arr.Ix i_aqY]
instCallConstraints [$dIArray_ar1, $dIx_ar2]
utype_defer
  cobox_ar3
  (i_aqY, i_aqY) -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
  (Int, Int) -> [a] -> Vector a
  a type equality (i_aqY, i_aqY) -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                  ~
                  (Int, Int) -> [a] -> Vector a
  In the expression: listArray
  In an equation for ‘listVector’: listVector = listArray
addInlinePrags
  listVector
  []
csb2 [listVector]
} End of bindings for
  [listVector]
  NonRecursive
  listVector forall a. (Int, Int) -> [a] -> Vector a
env2
  [(listVector,
    Identifier[listVector::forall a.
                           (Int, Int) -> [a] -> Vector a, <TopLevel>])]
------------------------------------------------
Bindings for { [listFlatVector]
Generalisation plan
  CheckGen listFlatVector :: (Int, Int) -> [Double] -> FlatVector
                             []
env2 []
tcMonoBinds
env2 []
tcRhs: fun bind
  listFlatVector
  (Int, Int) -> [Double] -> FlatVector
tcMatchesFun
  listFlatVector
  (Int, Int) -> [Double] -> FlatVector
tcGen
tcBody (Int, Int) -> [Double] -> FlatVector
Instantiating
  listArray with [i_ar6, e_ar7, a_ar8]
                 [Data.Array.Base.IArray a_ar8 e_ar7, GHC.Arr.Ix i_ar6]
instCallConstraints [$dIArray_ar9, $dIx_ara]
utype_defer
  cobox_arb
  (i_ar6, i_ar6) -> [e_ar7] -> a_ar8 i_ar6 e_ar7
  (Int, Int) -> [Double] -> FlatVector
  a type equality (i_ar6, i_ar6) -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                  ~
                  (Int, Int) -> [Double] -> FlatVector
  In the expression: listArray
  In an equation for ‘listFlatVector’: listFlatVector = listArray
addInlinePrags
  listFlatVector
  []
csb2 [listFlatVector]
} End of bindings for
  [listFlatVector]
  NonRecursive
  listFlatVector (Int, Int) -> [Double] -> FlatVector
env2
  [(listFlatVector,
    Identifier[listFlatVector::(Int, Int)
                               -> [Double] -> FlatVector, <TopLevel>])]
------------------------------------------------
Bindings for { [main]
Generalisation plan
  CheckGen main :: IO ()
                   []
env2 []
tcMonoBinds
env2 []
tcRhs: fun bind
  main
  IO ()
tcMatchesFun
  main
  IO ()
tcGen
tcBody IO ()
tc_lhs_type:
  FlatVector
  Expected kind ‘*’
lk1 FlatVector
lk2 FlatVector Type constructor ‘FlatVector’
tcCheckHsTypeAndGen [FlatVector]
checkValidType [FlatVector] :: *
checkValidType done [FlatVector] :: *
tc_lhs_type:
  Vector
  Expected kind ‘k_ard’
lk1 Vector
lk2 Vector Type constructor ‘Vector’
writeMetaTyVar k_ard := * -> *
tc_lhs_type:
  FlatVector
  The first argument of ‘Vector’ should have kind ‘*’
lk1 FlatVector
lk2 FlatVector Type constructor ‘FlatVector’
tcCheckHsTypeAndGen Vector FlatVector
checkValidType Vector FlatVector :: *
checkValidType done Vector FlatVector :: *
env2
  [(help, Identifier[help::[FlatVector], <NotTopLevel>]),
   (tmp, Identifier[tmp::Vector FlatVector, <NotTopLevel>])]
------------------------------------------------
Bindings for { [sL]
Generalisation plan InferGen True True
tcMatchesFun
  sL
  t_are
tcGen
tcBody t_are
utype_defer
  cobox_arh
  [t_arg]
  t_are
  a type equality [t_arg] ~ t_are
  In the expression: [1, 4, 6, 3, 2, 5]
  In an equation for ‘sL’: sL = [1, 4, 6, 3, 2, 5]
  In the expression:
    do { let sL = [1, 4, 6, 3, 2, 5]
             dim = length sL
             help :: [FlatVector]
             help = [listFlatVector (1, s) [0 | i <- [1 .. s]] | s <- sL]
             tmp :: Vector FlatVector
             tmp = listVector (1, dim) help;
         v <- thaw tmp;
         return () }
tcPolyExpr t_arg
tcPolyExprNC t_arg
tcGen
Instantiating
  fromInteger with [a_atN]
                   [Num a_atN]
instCallConstraints [$dNum_atO]
utype_defer
  cobox_atP
  Integer -> a_atN
  Integer -> t_arg
  a type equality Integer -> a_atN ~ Integer -> t_arg
  In the expression: 1
  In the expression: [1, 4, 6, 3, 2, 5]
  In an equation for ‘sL’: sL = [1, 4, 6, 3, 2, 5]
tcPolyExpr t_arg
tcPolyExprNC t_arg
tcGen
Instantiating
  fromInteger with [a_atQ]
                   [Num a_atQ]
instCallConstraints [$dNum_atR]
utype_defer
  cobox_atS
  Integer -> a_atQ
  Integer -> t_arg
  a type equality Integer -> a_atQ ~ Integer -> t_arg
  In the expression: 4
  In the expression: [1, 4, 6, 3, 2, 5]
  In an equation for ‘sL’: sL = [1, 4, 6, 3, 2, 5]
tcPolyExpr t_arg
tcPolyExprNC t_arg
tcGen
Instantiating
  fromInteger with [a_atT]
                   [Num a_atT]
instCallConstraints [$dNum_atU]
utype_defer
  cobox_atV
  Integer -> a_atT
  Integer -> t_arg
  a type equality Integer -> a_atT ~ Integer -> t_arg
  In the expression: 6
  In the expression: [1, 4, 6, 3, 2, 5]
  In an equation for ‘sL’: sL = [1, 4, 6, 3, 2, 5]
tcPolyExpr t_arg
tcPolyExprNC t_arg
tcGen
Instantiating
  fromInteger with [a_atW]
                   [Num a_atW]
instCallConstraints [$dNum_atX]
utype_defer
  cobox_atY
  Integer -> a_atW
  Integer -> t_arg
  a type equality Integer -> a_atW ~ Integer -> t_arg
  In the expression: 3
  In the expression: [1, 4, 6, 3, 2, 5]
  In an equation for ‘sL’: sL = [1, 4, 6, 3, 2, 5]
tcPolyExpr t_arg
tcPolyExprNC t_arg
tcGen
Instantiating
  fromInteger with [a_atZ]
                   [Num a_atZ]
instCallConstraints [$dNum_au0]
utype_defer
  cobox_au1
  Integer -> a_atZ
  Integer -> t_arg
  a type equality Integer -> a_atZ ~ Integer -> t_arg
  In the expression: 2
  In the expression: [1, 4, 6, 3, 2, 5]
  In an equation for ‘sL’: sL = [1, 4, 6, 3, 2, 5]
tcPolyExpr t_arg
tcPolyExprNC t_arg
tcGen
Instantiating
  fromInteger with [a_au2]
                   [Num a_au2]
instCallConstraints [$dNum_au3]
utype_defer
  cobox_au4
  Integer -> a_au2
  Integer -> t_arg
  a type equality Integer -> a_au2 ~ Integer -> t_arg
  In the expression: 5
  In the expression: [1, 4, 6, 3, 2, 5]
  In an equation for ‘sL’: sL = [1, 4, 6, 3, 2, 5]
simplifyInfer call
  [(sL, t_are)]
  WC {wc_flat = [W] cobox_arh :: [t_arg]
                                 ~ t_are [" a type equality [t_arg]
                                                            ~
                                                            t_are " p4.hs:13:20-32] (CNonCanonical)
                [W] $dNum_atO :: Num
                                   a_atN [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                [W] cobox_atP :: (Integer -> a_atN)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atN
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:21] (CNonCanonical)
                [W] $dNum_atR :: Num
                                   a_atQ [" the literal ‘4’ " p4.hs:13:23] (CNonCanonical)
                [W] cobox_atS :: (Integer -> a_atQ)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atQ
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:23] (CNonCanonical)
                [W] $dNum_atU :: Num
                                   a_atT [" the literal ‘6’ " p4.hs:13:25] (CNonCanonical)
                [W] cobox_atV :: (Integer -> a_atT)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atT
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:25] (CNonCanonical)
                [W] $dNum_atX :: Num
                                   a_atW [" the literal ‘3’ " p4.hs:13:27] (CNonCanonical)
                [W] cobox_atY :: (Integer -> a_atW)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atW
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:27] (CNonCanonical)
                [W] $dNum_au0 :: Num
                                   a_atZ [" the literal ‘2’ " p4.hs:13:29] (CNonCanonical)
                [W] cobox_au1 :: (Integer -> a_atZ)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atZ
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:29] (CNonCanonical)
                [W] $dNum_au3 :: Num
                                   a_au2 [" the literal ‘5’ " p4.hs:13:31] (CNonCanonical)
                [W] cobox_au4 :: (Integer -> a_au2)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_au2
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:31] (CNonCanonical)}
simplifyInfer {
  binds = [(sL, t_are)]
  closed = True
  apply_mr = True
  (unzonked) wanted = WC {wc_flat = [W] cobox_arh :: [t_arg]
                                                     ~ t_are [" a type equality [t_arg]
                                                                                ~
                                                                                t_are " p4.hs:13:20-32] (CNonCanonical)
                                    [W] $dNum_atO :: Num
                                                       a_atN [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                                    [W] cobox_atP :: (Integer -> a_atN)
                                                     ~ (Integer -> t_arg) [" a type equality Integer
                                                                                             -> a_atN
                                                                                             ~
                                                                                             Integer
                                                                                             -> t_arg " p4.hs:13:21] (CNonCanonical)
                                    [W] $dNum_atR :: Num
                                                       a_atQ [" the literal ‘4’ " p4.hs:13:23] (CNonCanonical)
                                    [W] cobox_atS :: (Integer -> a_atQ)
                                                     ~ (Integer -> t_arg) [" a type equality Integer
                                                                                             -> a_atQ
                                                                                             ~
                                                                                             Integer
                                                                                             -> t_arg " p4.hs:13:23] (CNonCanonical)
                                    [W] $dNum_atU :: Num
                                                       a_atT [" the literal ‘6’ " p4.hs:13:25] (CNonCanonical)
                                    [W] cobox_atV :: (Integer -> a_atT)
                                                     ~ (Integer -> t_arg) [" a type equality Integer
                                                                                             -> a_atT
                                                                                             ~
                                                                                             Integer
                                                                                             -> t_arg " p4.hs:13:25] (CNonCanonical)
                                    [W] $dNum_atX :: Num
                                                       a_atW [" the literal ‘3’ " p4.hs:13:27] (CNonCanonical)
                                    [W] cobox_atY :: (Integer -> a_atW)
                                                     ~ (Integer -> t_arg) [" a type equality Integer
                                                                                             -> a_atW
                                                                                             ~
                                                                                             Integer
                                                                                             -> t_arg " p4.hs:13:27] (CNonCanonical)
                                    [W] $dNum_au0 :: Num
                                                       a_atZ [" the literal ‘2’ " p4.hs:13:29] (CNonCanonical)
                                    [W] cobox_au1 :: (Integer -> a_atZ)
                                                     ~ (Integer -> t_arg) [" a type equality Integer
                                                                                             -> a_atZ
                                                                                             ~
                                                                                             Integer
                                                                                             -> t_arg " p4.hs:13:29] (CNonCanonical)
                                    [W] $dNum_au3 :: Num
                                                       a_au2 [" the literal ‘5’ " p4.hs:13:31] (CNonCanonical)
                                    [W] cobox_au4 :: (Integer -> a_au2)
                                                     ~ (Integer -> t_arg) [" a type equality Integer
                                                                                             -> a_au2
                                                                                             ~
                                                                                             Integer
                                                                                             -> t_arg " p4.hs:13:31] (CNonCanonical)}
solveWantedsTcMWithEvBinds
  wanted= WC {wc_flat = [W] cobox_arh :: [t_arg]
                                         ~ t_are [" a type equality [t_arg]
                                                                    ~
                                                                    t_are " p4.hs:13:20-32] (CNonCanonical)
                        [W] $dNum_atO :: Num
                                           a_atN [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                        [W] cobox_atP :: (Integer -> a_atN)
                                         ~ (Integer -> t_arg) [" a type equality Integer -> a_atN
                                                                                 ~
                                                                                 Integer
                                                                                 -> t_arg " p4.hs:13:21] (CNonCanonical)
                        [W] $dNum_atR :: Num
                                           a_atQ [" the literal ‘4’ " p4.hs:13:23] (CNonCanonical)
                        [W] cobox_atS :: (Integer -> a_atQ)
                                         ~ (Integer -> t_arg) [" a type equality Integer -> a_atQ
                                                                                 ~
                                                                                 Integer
                                                                                 -> t_arg " p4.hs:13:23] (CNonCanonical)
                        [W] $dNum_atU :: Num
                                           a_atT [" the literal ‘6’ " p4.hs:13:25] (CNonCanonical)
                        [W] cobox_atV :: (Integer -> a_atT)
                                         ~ (Integer -> t_arg) [" a type equality Integer -> a_atT
                                                                                 ~
                                                                                 Integer
                                                                                 -> t_arg " p4.hs:13:25] (CNonCanonical)
                        [W] $dNum_atX :: Num
                                           a_atW [" the literal ‘3’ " p4.hs:13:27] (CNonCanonical)
                        [W] cobox_atY :: (Integer -> a_atW)
                                         ~ (Integer -> t_arg) [" a type equality Integer -> a_atW
                                                                                 ~
                                                                                 Integer
                                                                                 -> t_arg " p4.hs:13:27] (CNonCanonical)
                        [W] $dNum_au0 :: Num
                                           a_atZ [" the literal ‘2’ " p4.hs:13:29] (CNonCanonical)
                        [W] cobox_au1 :: (Integer -> a_atZ)
                                         ~ (Integer -> t_arg) [" a type equality Integer -> a_atZ
                                                                                 ~
                                                                                 Integer
                                                                                 -> t_arg " p4.hs:13:29] (CNonCanonical)
                        [W] $dNum_au3 :: Num
                                           a_au2 [" the literal ‘5’ " p4.hs:13:31] (CNonCanonical)
                        [W] cobox_au4 :: (Integer -> a_au2)
                                         ~ (Integer -> t_arg) [" a type equality Integer -> a_au2
                                                                                 ~
                                                                                 Integer
                                                                                 -> t_arg " p4.hs:13:31] (CNonCanonical)}
solveWanteds {
  WC {wc_flat = [W] cobox_arh :: [t_arg]
                                 ~ t_are [" a type equality [t_arg]
                                                            ~
                                                            t_are " p4.hs:13:20-32] (CNonCanonical)
                [W] $dNum_atO :: Num
                                   a_atN [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                [W] cobox_atP :: (Integer -> a_atN)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atN
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:21] (CNonCanonical)
                [W] $dNum_atR :: Num
                                   a_atQ [" the literal ‘4’ " p4.hs:13:23] (CNonCanonical)
                [W] cobox_atS :: (Integer -> a_atQ)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atQ
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:23] (CNonCanonical)
                [W] $dNum_atU :: Num
                                   a_atT [" the literal ‘6’ " p4.hs:13:25] (CNonCanonical)
                [W] cobox_atV :: (Integer -> a_atT)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atT
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:25] (CNonCanonical)
                [W] $dNum_atX :: Num
                                   a_atW [" the literal ‘3’ " p4.hs:13:27] (CNonCanonical)
                [W] cobox_atY :: (Integer -> a_atW)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atW
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:27] (CNonCanonical)
                [W] $dNum_au0 :: Num
                                   a_atZ [" the literal ‘2’ " p4.hs:13:29] (CNonCanonical)
                [W] cobox_au1 :: (Integer -> a_atZ)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atZ
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:29] (CNonCanonical)
                [W] $dNum_au3 :: Num
                                   a_au2 [" the literal ‘5’ " p4.hs:13:31] (CNonCanonical)
                [W] cobox_au4 :: (Integer -> a_au2)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_au2
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:31] (CNonCanonical)}
solveFlats {
Start solver pipeline {
  work item =  [W] cobox_arh :: [t_arg]
                                ~ t_are [" a type equality [t_arg]
                                                           ~
                                                           t_are " p4.hs:13:20-32] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_arh :: [t_arg]
                                 ~ t_are [" a type equality [t_arg]
                                                            ~
                                                            t_are " p4.hs:13:20-32] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_arh :: [t_arg] ~ t_are [" a type equality [t_arg]
                                                      ~
                                                      t_are " p4.hs:13:20-32] (CNonCanonical)
canEvNC:eq
  [t_arg]
  t_are
can_eq_nc
  [W] cobox_arh :: [t_arg] ~ t_are
  [t_arg]
  [t_arg]
  t_are
  t_are
canEqTyVar
  t_are
  [t_arg]
  Is-swapped
newWantedEvVar/cache miss [W] cobox_au6 :: t_are ~ [t_arg]
setEvBind
  ev = cobox_arh
  tm  = CO Sym cobox_au6
rewriteEqEvidence
  [W] cobox_arh :: [t_arg] ~ t_are
  t_are
  [t_arg]
  Sym cobox_au6
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_au6 :: t_are
                                 ~ [t_arg] [" a type equality [t_arg]
                                                              ~
                                                              t_are " p4.hs:13:20-32] (CTyEqCan)
Sneaky unification:
  Unifies: t_are := [t_arg]
  Coercion: t_are ~ [t_arg]
  Left Kind is: OpenKind
  Right Kind is: *
setWantedTyBind t_are := [t_arg]
setEvBind
  ev = cobox_au6
  tm  = CO <[t_arg]>_N
kickOutRewritable
  tv =  t_are
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
1[<C:0,F:0>] [W] cobox_au6 :: t_are ~ [t_arg]: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_atP :: (Integer -> a_atN)
                                ~ (Integer -> t_arg) [" a type equality Integer -> a_atN
                                                                        ~
                                                                        Integer
                                                                        -> t_arg " p4.hs:13:21] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_atP :: (Integer -> a_atN)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atN
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:21] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_atP :: (Integer -> a_atN)
                   ~ (Integer -> t_arg) [" a type equality Integer -> a_atN
                                                           ~
                                                           Integer
                                                           -> t_arg " p4.hs:13:21] (CNonCanonical)
canEvNC:eq
  Integer -> a_atN
  Integer -> t_arg
can_eq_nc
  [W] cobox_atP :: (Integer -> a_atN) ~ (Integer -> t_arg)
  Integer -> a_atN
  Integer -> a_atN
  Integer -> t_arg
  Integer -> t_arg
newWantedEvVar/cache miss [W] cobox_au7 :: Integer ~ Integer
newWantedEvVar/cache miss [W] cobox_au8 :: a_atN ~ t_arg
setEvBind
  ev = cobox_atP
  tm  = CO cobox_au7 -> cobox_au8
canEvNC:eq
  Integer
  Integer
can_eq_nc
  [W] cobox_au7 :: Integer ~ Integer
  Integer
  Integer
  Integer
  Integer
setEvBind
  ev = cobox_au7
  tm  = CO <Integer>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_au8 :: a_atN
                                ~ t_arg [" a type equality Integer -> a_atN
                                                           ~
                                                           Integer
                                                           -> t_arg " p4.hs:13:21] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_au8 :: a_atN
                                 ~ t_arg [" a type equality Integer -> a_atN
                                                            ~
                                                            Integer
                                                            -> t_arg " p4.hs:13:21] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_au8 :: a_atN ~ t_arg [" a type equality Integer -> a_atN
                                                    ~
                                                    Integer -> t_arg " p4.hs:13:21] (CNonCanonical)
canEvNC:eq
  a_atN
  t_arg
can_eq_nc
  [W] cobox_au8 :: a_atN ~ t_arg
  a_atN
  a_atN
  t_arg
  t_arg
canEqTyVar
  a_atN
  t_arg
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_au8 :: a_atN
                                 ~ t_arg [" a type equality Integer -> a_atN
                                                            ~
                                                            Integer
                                                            -> t_arg " p4.hs:13:21] (CTyEqCan)
Sneaky unification:
  Unifies: t_arg := a_atN
  Coercion: t_arg ~ a_atN
  Left Kind is: *
  Right Kind is: *
setWantedTyBind t_arg := a_atN
setEvBind
  ev = cobox_au8
  tm  = CO <a_atN>_N
kickOutRewritable
  tv =  t_arg
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
3[<C:0,F:0>] [W] cobox_au8 :: a_atN ~ t_arg: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_atS :: (Integer -> a_atQ)
                                ~ (Integer -> t_arg) [" a type equality Integer -> a_atQ
                                                                        ~
                                                                        Integer
                                                                        -> t_arg " p4.hs:13:23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_atS :: (Integer -> a_atQ)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atQ
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_atS :: (Integer -> a_atQ)
                   ~ (Integer -> t_arg) [" a type equality Integer -> a_atQ
                                                           ~
                                                           Integer
                                                           -> t_arg " p4.hs:13:23] (CNonCanonical)
canEvNC:eq
  Integer -> a_atQ
  Integer -> t_arg
can_eq_nc
  [W] cobox_atS :: (Integer -> a_atQ) ~ (Integer -> t_arg)
  Integer -> a_atQ
  Integer -> a_atQ
  Integer -> t_arg
  Integer -> t_arg
newWantedEvVar/cache miss [W] cobox_au9 :: Integer ~ Integer
newWantedEvVar/cache miss [W] cobox_aua :: a_atQ ~ t_arg
setEvBind
  ev = cobox_atS
  tm  = CO cobox_au9 -> cobox_aua
canEvNC:eq
  Integer
  Integer
can_eq_nc
  [W] cobox_au9 :: Integer ~ Integer
  Integer
  Integer
  Integer
  Integer
setEvBind
  ev = cobox_au9
  tm  = CO <Integer>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_aua :: a_atQ
                                ~ t_arg [" a type equality Integer -> a_atQ
                                                           ~
                                                           Integer
                                                           -> t_arg " p4.hs:13:23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_aua :: a_atQ
                                 ~ t_arg [" a type equality Integer -> a_atQ
                                                            ~
                                                            Integer
                                                            -> t_arg " p4.hs:13:23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_aua :: a_atQ ~ t_arg [" a type equality Integer -> a_atQ
                                                    ~
                                                    Integer -> t_arg " p4.hs:13:23] (CNonCanonical)
canEvNC:eq
  a_atQ
  t_arg
can_eq_nc
  [W] cobox_aua :: a_atQ ~ t_arg
  a_atQ
  a_atQ
  t_arg
  t_arg
canEqTyVar
  a_atQ
  t_arg
  Not-swapped
Following bound tyvar t_arg = a_atN
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_aua :: a_atQ
                                 ~ a_atN [" a type equality Integer -> a_atQ
                                                            ~
                                                            Integer
                                                            -> t_arg " p4.hs:13:23] (CTyEqCan)
Sneaky unification:
  Unifies: a_atN := a_atQ
  Coercion: a_atN ~ a_atQ
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_atN := a_atQ
setEvBind
  ev = cobox_aua
  tm  = CO <a_atQ>_N
kickOutRewritable
  tv =  a_atN
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
5[<C:0,F:0>] [W] cobox_aua :: a_atQ ~ a_atN: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_atV :: (Integer -> a_atT)
                                ~ (Integer -> t_arg) [" a type equality Integer -> a_atT
                                                                        ~
                                                                        Integer
                                                                        -> t_arg " p4.hs:13:25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_atV :: (Integer -> a_atT)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atT
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:25] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_atV :: (Integer -> a_atT)
                   ~ (Integer -> t_arg) [" a type equality Integer -> a_atT
                                                           ~
                                                           Integer
                                                           -> t_arg " p4.hs:13:25] (CNonCanonical)
canEvNC:eq
  Integer -> a_atT
  Integer -> t_arg
can_eq_nc
  [W] cobox_atV :: (Integer -> a_atT) ~ (Integer -> t_arg)
  Integer -> a_atT
  Integer -> a_atT
  Integer -> t_arg
  Integer -> t_arg
newWantedEvVar/cache miss [W] cobox_aub :: Integer ~ Integer
newWantedEvVar/cache miss [W] cobox_auc :: a_atT ~ t_arg
setEvBind
  ev = cobox_atV
  tm  = CO cobox_aub -> cobox_auc
canEvNC:eq
  Integer
  Integer
can_eq_nc
  [W] cobox_aub :: Integer ~ Integer
  Integer
  Integer
  Integer
  Integer
setEvBind
  ev = cobox_aub
  tm  = CO <Integer>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_auc :: a_atT
                                ~ t_arg [" a type equality Integer -> a_atT
                                                           ~
                                                           Integer
                                                           -> t_arg " p4.hs:13:25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_auc :: a_atT
                                 ~ t_arg [" a type equality Integer -> a_atT
                                                            ~
                                                            Integer
                                                            -> t_arg " p4.hs:13:25] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_auc :: a_atT ~ t_arg [" a type equality Integer -> a_atT
                                                    ~
                                                    Integer -> t_arg " p4.hs:13:25] (CNonCanonical)
canEvNC:eq
  a_atT
  t_arg
can_eq_nc
  [W] cobox_auc :: a_atT ~ t_arg
  a_atT
  a_atT
  t_arg
  t_arg
canEqTyVar
  a_atT
  t_arg
  Not-swapped
Following bound tyvar t_arg = a_atN
Following bound tyvar a_atN = a_atQ
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_auc :: a_atT
                                 ~ a_atQ [" a type equality Integer -> a_atT
                                                            ~
                                                            Integer
                                                            -> t_arg " p4.hs:13:25] (CTyEqCan)
Sneaky unification:
  Unifies: a_atQ := a_atT
  Coercion: a_atQ ~ a_atT
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_atQ := a_atT
setEvBind
  ev = cobox_auc
  tm  = CO <a_atT>_N
kickOutRewritable
  tv =  a_atQ
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
7[<C:0,F:0>] [W] cobox_auc :: a_atT ~ a_atQ: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_atY :: (Integer -> a_atW)
                                ~ (Integer -> t_arg) [" a type equality Integer -> a_atW
                                                                        ~
                                                                        Integer
                                                                        -> t_arg " p4.hs:13:27] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_atY :: (Integer -> a_atW)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atW
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:27] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_atY :: (Integer -> a_atW)
                   ~ (Integer -> t_arg) [" a type equality Integer -> a_atW
                                                           ~
                                                           Integer
                                                           -> t_arg " p4.hs:13:27] (CNonCanonical)
canEvNC:eq
  Integer -> a_atW
  Integer -> t_arg
can_eq_nc
  [W] cobox_atY :: (Integer -> a_atW) ~ (Integer -> t_arg)
  Integer -> a_atW
  Integer -> a_atW
  Integer -> t_arg
  Integer -> t_arg
newWantedEvVar/cache miss [W] cobox_aud :: Integer ~ Integer
newWantedEvVar/cache miss [W] cobox_aue :: a_atW ~ t_arg
setEvBind
  ev = cobox_atY
  tm  = CO cobox_aud -> cobox_aue
canEvNC:eq
  Integer
  Integer
can_eq_nc
  [W] cobox_aud :: Integer ~ Integer
  Integer
  Integer
  Integer
  Integer
setEvBind
  ev = cobox_aud
  tm  = CO <Integer>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_aue :: a_atW
                                ~ t_arg [" a type equality Integer -> a_atW
                                                           ~
                                                           Integer
                                                           -> t_arg " p4.hs:13:27] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_aue :: a_atW
                                 ~ t_arg [" a type equality Integer -> a_atW
                                                            ~
                                                            Integer
                                                            -> t_arg " p4.hs:13:27] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_aue :: a_atW ~ t_arg [" a type equality Integer -> a_atW
                                                    ~
                                                    Integer -> t_arg " p4.hs:13:27] (CNonCanonical)
canEvNC:eq
  a_atW
  t_arg
can_eq_nc
  [W] cobox_aue :: a_atW ~ t_arg
  a_atW
  a_atW
  t_arg
  t_arg
canEqTyVar
  a_atW
  t_arg
  Not-swapped
Following bound tyvar t_arg = a_atN
Following bound tyvar a_atN = a_atQ
Following bound tyvar a_atQ = a_atT
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_aue :: a_atW
                                 ~ a_atT [" a type equality Integer -> a_atW
                                                            ~
                                                            Integer
                                                            -> t_arg " p4.hs:13:27] (CTyEqCan)
Sneaky unification:
  Unifies: a_atT := a_atW
  Coercion: a_atT ~ a_atW
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_atT := a_atW
setEvBind
  ev = cobox_aue
  tm  = CO <a_atW>_N
kickOutRewritable
  tv =  a_atT
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
9[<C:0,F:0>] [W] cobox_aue :: a_atW ~ a_atT: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_au1 :: (Integer -> a_atZ)
                                ~ (Integer -> t_arg) [" a type equality Integer -> a_atZ
                                                                        ~
                                                                        Integer
                                                                        -> t_arg " p4.hs:13:29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_au1 :: (Integer -> a_atZ)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atZ
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_au1 :: (Integer -> a_atZ)
                   ~ (Integer -> t_arg) [" a type equality Integer -> a_atZ
                                                           ~
                                                           Integer
                                                           -> t_arg " p4.hs:13:29] (CNonCanonical)
canEvNC:eq
  Integer -> a_atZ
  Integer -> t_arg
can_eq_nc
  [W] cobox_au1 :: (Integer -> a_atZ) ~ (Integer -> t_arg)
  Integer -> a_atZ
  Integer -> a_atZ
  Integer -> t_arg
  Integer -> t_arg
newWantedEvVar/cache miss [W] cobox_auf :: Integer ~ Integer
newWantedEvVar/cache miss [W] cobox_aug :: a_atZ ~ t_arg
setEvBind
  ev = cobox_au1
  tm  = CO cobox_auf -> cobox_aug
canEvNC:eq
  Integer
  Integer
can_eq_nc
  [W] cobox_auf :: Integer ~ Integer
  Integer
  Integer
  Integer
  Integer
setEvBind
  ev = cobox_auf
  tm  = CO <Integer>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_aug :: a_atZ
                                ~ t_arg [" a type equality Integer -> a_atZ
                                                           ~
                                                           Integer
                                                           -> t_arg " p4.hs:13:29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_aug :: a_atZ
                                 ~ t_arg [" a type equality Integer -> a_atZ
                                                            ~
                                                            Integer
                                                            -> t_arg " p4.hs:13:29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_aug :: a_atZ ~ t_arg [" a type equality Integer -> a_atZ
                                                    ~
                                                    Integer -> t_arg " p4.hs:13:29] (CNonCanonical)
canEvNC:eq
  a_atZ
  t_arg
can_eq_nc
  [W] cobox_aug :: a_atZ ~ t_arg
  a_atZ
  a_atZ
  t_arg
  t_arg
canEqTyVar
  a_atZ
  t_arg
  Not-swapped
Following bound tyvar t_arg = a_atN
Following bound tyvar a_atN = a_atQ
Following bound tyvar a_atQ = a_atT
Following bound tyvar a_atT = a_atW
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_aug :: a_atZ
                                 ~ a_atW [" a type equality Integer -> a_atZ
                                                            ~
                                                            Integer
                                                            -> t_arg " p4.hs:13:29] (CTyEqCan)
Sneaky unification:
  Unifies: a_atW := a_atZ
  Coercion: a_atW ~ a_atZ
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_atW := a_atZ
setEvBind
  ev = cobox_aug
  tm  = CO <a_atZ>_N
kickOutRewritable
  tv =  a_atW
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
11[<C:0,F:0>] [W] cobox_aug :: a_atZ ~ a_atW: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_au4 :: (Integer -> a_au2)
                                ~ (Integer -> t_arg) [" a type equality Integer -> a_au2
                                                                        ~
                                                                        Integer
                                                                        -> t_arg " p4.hs:13:31] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_au4 :: (Integer -> a_au2)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_au2
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:31] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_au4 :: (Integer -> a_au2)
                   ~ (Integer -> t_arg) [" a type equality Integer -> a_au2
                                                           ~
                                                           Integer
                                                           -> t_arg " p4.hs:13:31] (CNonCanonical)
canEvNC:eq
  Integer -> a_au2
  Integer -> t_arg
can_eq_nc
  [W] cobox_au4 :: (Integer -> a_au2) ~ (Integer -> t_arg)
  Integer -> a_au2
  Integer -> a_au2
  Integer -> t_arg
  Integer -> t_arg
newWantedEvVar/cache miss [W] cobox_auh :: Integer ~ Integer
newWantedEvVar/cache miss [W] cobox_aui :: a_au2 ~ t_arg
setEvBind
  ev = cobox_au4
  tm  = CO cobox_auh -> cobox_aui
canEvNC:eq
  Integer
  Integer
can_eq_nc
  [W] cobox_auh :: Integer ~ Integer
  Integer
  Integer
  Integer
  Integer
setEvBind
  ev = cobox_auh
  tm  = CO <Integer>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_aui :: a_au2
                                ~ t_arg [" a type equality Integer -> a_au2
                                                           ~
                                                           Integer
                                                           -> t_arg " p4.hs:13:31] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_aui :: a_au2
                                 ~ t_arg [" a type equality Integer -> a_au2
                                                            ~
                                                            Integer
                                                            -> t_arg " p4.hs:13:31] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_aui :: a_au2 ~ t_arg [" a type equality Integer -> a_au2
                                                    ~
                                                    Integer -> t_arg " p4.hs:13:31] (CNonCanonical)
canEvNC:eq
  a_au2
  t_arg
can_eq_nc
  [W] cobox_aui :: a_au2 ~ t_arg
  a_au2
  a_au2
  t_arg
  t_arg
canEqTyVar
  a_au2
  t_arg
  Not-swapped
Following bound tyvar t_arg = a_atN
Following bound tyvar a_atN = a_atQ
Following bound tyvar a_atQ = a_atT
Following bound tyvar a_atT = a_atW
Following bound tyvar a_atW = a_atZ
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_aui :: a_au2
                                 ~ a_atZ [" a type equality Integer -> a_au2
                                                            ~
                                                            Integer
                                                            -> t_arg " p4.hs:13:31] (CTyEqCan)
Sneaky unification:
  Unifies: a_atZ := a_au2
  Coercion: a_atZ ~ a_au2
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_atZ := a_au2
setEvBind
  ev = cobox_aui
  tm  = CO <a_au2>_N
kickOutRewritable
  tv =  a_atZ
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
13[<C:0,F:0>] [W] cobox_aui :: a_au2 ~ a_atZ: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dNum_atO :: Num
                                  a_atN [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_atO :: Num
                                   a_atN [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_atO :: Num
                     a_atN [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
canEvNC:cls Num [a_atN]
Following bound tyvar a_atN = a_atQ
Following bound tyvar a_atQ = a_atT
Following bound tyvar a_atT = a_atW
Following bound tyvar a_atW = a_atZ
Following bound tyvar a_atZ = a_au2
canClass
  [W] $dNum_atO :: Num a_atN Num [a_atN]
  Num a_au2
  Just [W] $dNum_atO :: Num a_au2
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_atO :: Num
                                   a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dNum_atO :: Num
                                   a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
doTopReact
  [W] $dNum_atO :: Num
                     a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
matchClassInst
  pred = Num a_au2
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 0
          Solved funeqs 0
  untouchables= 0
matchClass not matching dict Num a_au2
end stage top-level reactions }
14[<C:0,F:0>] [W] $dNum_atO :: Num a_au2: Kept as inert
End solver pipeline (not discharged) }
  final_item =  [W] $dNum_atO :: Num
                                   a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
  a_au2
  inerts     =  Equalities:
                Type-function equalities:
                No-eqs: True
                Dictionaries:
                Irreds:
                Insolubles = {}
                Solved dicts 0
                Solved funeqs 0
insertInertItemTcS {
  Trying to insert new inert item: [W] $dNum_atO :: Num
                                                      a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
insertInertItemTcS }
Start solver pipeline {
  work item =  [W] $dNum_atR :: Num
                                  a_atQ [" the literal ‘4’ " p4.hs:13:23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_atO :: Num
                                                a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_atR :: Num
                                   a_atQ [" the literal ‘4’ " p4.hs:13:23] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_atR :: Num
                     a_atQ [" the literal ‘4’ " p4.hs:13:23] (CNonCanonical)
canEvNC:cls Num [a_atQ]
Following bound tyvar a_atQ = a_atT
Following bound tyvar a_atT = a_atW
Following bound tyvar a_atW = a_atZ
Following bound tyvar a_atZ = a_au2
canClass
  [W] $dNum_atR :: Num a_atQ Num [a_atQ]
  Num a_au2
  Just [W] $dNum_atR :: Num a_au2
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_atR :: Num
                                   a_au2 [" the literal ‘4’ " p4.hs:13:23] (CDictCan)
setEvBind
  ev = $dNum_atR
  tm  = $dNum_atO
15[<C:0,F:0>] [W] $dNum_atR :: Num a_au2: Dict equal (keep)
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_atO :: Num
                                                a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dNum_atU :: Num
                                  a_atT [" the literal ‘6’ " p4.hs:13:25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_atO :: Num
                                                a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_atU :: Num
                                   a_atT [" the literal ‘6’ " p4.hs:13:25] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_atU :: Num
                     a_atT [" the literal ‘6’ " p4.hs:13:25] (CNonCanonical)
canEvNC:cls Num [a_atT]
Following bound tyvar a_atT = a_atW
Following bound tyvar a_atW = a_atZ
Following bound tyvar a_atZ = a_au2
canClass
  [W] $dNum_atU :: Num a_atT Num [a_atT]
  Num a_au2
  Just [W] $dNum_atU :: Num a_au2
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_atU :: Num
                                   a_au2 [" the literal ‘6’ " p4.hs:13:25] (CDictCan)
setEvBind
  ev = $dNum_atU
  tm  = $dNum_atO
16[<C:0,F:0>] [W] $dNum_atU :: Num a_au2: Dict equal (keep)
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_atO :: Num
                                                a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dNum_atX :: Num
                                  a_atW [" the literal ‘3’ " p4.hs:13:27] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_atO :: Num
                                                a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_atX :: Num
                                   a_atW [" the literal ‘3’ " p4.hs:13:27] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_atX :: Num
                     a_atW [" the literal ‘3’ " p4.hs:13:27] (CNonCanonical)
canEvNC:cls Num [a_atW]
Following bound tyvar a_atW = a_atZ
Following bound tyvar a_atZ = a_au2
canClass
  [W] $dNum_atX :: Num a_atW Num [a_atW]
  Num a_au2
  Just [W] $dNum_atX :: Num a_au2
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_atX :: Num
                                   a_au2 [" the literal ‘3’ " p4.hs:13:27] (CDictCan)
setEvBind
  ev = $dNum_atX
  tm  = $dNum_atO
17[<C:0,F:0>] [W] $dNum_atX :: Num a_au2: Dict equal (keep)
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_atO :: Num
                                                a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dNum_au0 :: Num
                                  a_atZ [" the literal ‘2’ " p4.hs:13:29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_atO :: Num
                                                a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_au0 :: Num
                                   a_atZ [" the literal ‘2’ " p4.hs:13:29] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_au0 :: Num
                     a_atZ [" the literal ‘2’ " p4.hs:13:29] (CNonCanonical)
canEvNC:cls Num [a_atZ]
Following bound tyvar a_atZ = a_au2
canClass
  [W] $dNum_au0 :: Num a_atZ Num [a_atZ]
  Num a_au2
  Just [W] $dNum_au0 :: Num a_au2
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_au0 :: Num
                                   a_au2 [" the literal ‘2’ " p4.hs:13:29] (CDictCan)
setEvBind
  ev = $dNum_au0
  tm  = $dNum_atO
18[<C:0,F:0>] [W] $dNum_au0 :: Num a_au2: Dict equal (keep)
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_atO :: Num
                                                a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dNum_au3 :: Num
                                  a_au2 [" the literal ‘5’ " p4.hs:13:31] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_atO :: Num
                                                a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_au3 :: Num
                                   a_au2 [" the literal ‘5’ " p4.hs:13:31] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_au3 :: Num
                     a_au2 [" the literal ‘5’ " p4.hs:13:31] (CNonCanonical)
canEvNC:cls Num [a_au2]
canClass
  [W] $dNum_au3 :: Num a_au2 Num [a_au2]
  Num a_au2
  Just [W] $dNum_au3 :: Num a_au2
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_au3 :: Num
                                   a_au2 [" the literal ‘5’ " p4.hs:13:31] (CDictCan)
setEvBind
  ev = $dNum_au3
  tm  = $dNum_atO
19[<C:0,F:0>] [W] $dNum_au3 :: Num a_au2: Dict equal (keep)
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_atO :: Num
                                                a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
solveFlats end } {}
simpl_loop, iteration 1
solveWanteds }
  unsolved_flats   = {[W] $dNum_atO :: Num
                                         a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)}
  unsolved_implics = {}
  current evbinds  = {cobox_arh = CO Sym cobox_au6,
                      cobox_atP = CO cobox_au7 -> cobox_au8, $dNum_atR = $dNum_atO,
                      cobox_atS = CO cobox_au9 -> cobox_aua, $dNum_atU = $dNum_atO,
                      cobox_atV = CO cobox_aub -> cobox_auc, $dNum_atX = $dNum_atO,
                      cobox_atY = CO cobox_aud -> cobox_aue, $dNum_au0 = $dNum_atO,
                      cobox_au1 = CO cobox_auf -> cobox_aug, $dNum_au3 = $dNum_atO,
                      cobox_au4 = CO cobox_auh -> cobox_aui, cobox_au6 = CO <[t_arg]>_N,
                      cobox_au7 = CO <Integer>_N, cobox_au8 = CO <a_atN>_N,
                      cobox_au9 = CO <Integer>_N, cobox_aua = CO <a_atQ>_N,
                      cobox_aub = CO <Integer>_N, cobox_auc = CO <a_atT>_N,
                      cobox_aud = CO <Integer>_N, cobox_aue = CO <a_atW>_N,
                      cobox_auf = CO <Integer>_N, cobox_aug = CO <a_atZ>_N,
                      cobox_auh = CO <Integer>_N, cobox_aui = CO <a_au2>_N}
  current tybinds  = (t_are, [t_arg])
                     (t_arg, a_atN)
                     (a_atN, a_atQ)
                     (a_atQ, a_atT)
                     (a_atT, a_atW)
                     (a_atW, a_atZ)
                     (a_atZ, a_au2)
  final wc = WC {wc_flat = [W] $dNum_atO :: Num
                                              a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)}
writeMetaTyVar t_are := [t_arg]
writeMetaTyVar t_arg := a_atN
writeMetaTyVar a_atN := a_atQ
writeMetaTyVar a_atQ := a_atT
writeMetaTyVar a_atT := a_atW
writeMetaTyVar a_atW := a_atZ
writeMetaTyVar a_atZ := a_au2
Constraint solver steps = 19
Start solver pipeline {
  work item =  [W] $dNum_atO :: Num
                                  a_au2 [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_atO :: Num
                                   a_au2 [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_atO :: Num
                     a_au2 [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
canEvNC:cls Num [a_au2]
canClass
  [W] $dNum_atO :: Num a_au2 Num [a_au2]
  Num a_au2
  Just [W] $dNum_atO :: Num a_au2
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_atO :: Num
                                   a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dNum_atO :: Num
                                   a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
doTopReact
  [W] $dNum_atO :: Num
                     a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
matchClassInst
  pred = Num a_au2
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 0
          Solved funeqs 0
  untouchables= 0
matchClass not matching dict Num a_au2
end stage top-level reactions }
1[<C:0,F:0>] [W] $dNum_atO :: Num a_au2: Kept as inert
End solver pipeline (not discharged) }
  final_item =  [W] $dNum_atO :: Num
                                   a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
  a_au2
  inerts     =  Equalities:
                Type-function equalities:
                No-eqs: True
                Dictionaries:
                Irreds:
                Insolubles = {}
                Solved dicts 0
                Solved funeqs 0
insertInertItemTcS {
  Trying to insert new inert item: [W] $dNum_atO :: Num
                                                      a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
insertInertItemTcS }
Constraint solver steps = 1
simplifyWithApprox
  quant_pred_candidates = [Num a_au2]
  gbl_tvs= []
  zonked_tau_tvs= [(au2, a_au2)]
  pbound = [Num a_au2]
  bbound = []
  poly_qtvs = [(au2, a_au2)]
  constrained_tvs = [(au2, a_au2)]
  mr_bites = True
  qtvs = []
} simplifyInfer/no implication needed
addInlinePrags
  sL
  []
mkExport: check sig
  sL
  [a_au2]
  [a_au2]
u_tys 
  untch 0
  [a_au2] ~ [a_au2]
  a type equality [a_au2] ~ [a_au2]
u_tys 
  untch 0
  a_au2 ~ a_au2
  a type equality [a_au2] ~ [a_au2]
u_tys yields no coercion
u_tys yields no coercion
simplifyTop { wanted =  WC {}
solveWantedsTcMWithEvBinds wanted= WC {}
solveWanteds { WC {}
solveFlats {
solveFlats end } {}
simpl_loop, iteration 1
solveWanteds }
  unsolved_flats   = {}
  unsolved_implics = {}
  current evbinds  = {}
  current tybinds  =
  final wc = WC {}
End simplifyTop }
reportUnsolved {
reportUnsolved }
Binding:
  <NotTopLevel>
  [(sL, [a_au2])]
csb2 [sL]
} End of bindings for
  [sL]
  NonRecursive
  sL [a_au2]
env2 [(sL, Identifier[sL::[a_au2], <NotTopLevel>])]
------------------------------------------------
Bindings for { [dim]
Generalisation plan NoGen
addInlinePrags
  dim
  []
tcMatchesFun
  dim
  t_auG
tcGen
tcBody t_auG
Instantiating
  length with [a_auI]
              []
utype_defer
  cobox_auJ
  Int
  t_auG
  a type equality Int ~ t_auG
  In the expression: length sL
  In an equation for ‘dim’: dim = length sL
tcPolyExprNC [a_auI]
tcGen
utype_defer
  cobox_auK
  [a_au2]
  [a_auI]
  a type equality [a_au2] ~ [a_auI]
  In the first argument of ‘length’, namely ‘sL’
  In the expression: length sL
csb2 [dim]
} End of bindings for
  [dim]
  NonRecursive
  dim t_auG
env2 [(dim, Identifier[dim::t_auG, <NotTopLevel>])]
------------------------------------------------
Bindings for { [help]
Generalisation plan
  CheckGen help :: [FlatVector]
                   []
env2 []
tcMonoBinds
env2 []
tcRhs: fun bind
  help
  [FlatVector]
tcMatchesFun
  help
  [FlatVector]
tcGen
tcBody [FlatVector]
utype_defer
  cobox_auN
  [a_au2]
  [t_auM]
  a type equality [a_au2] ~ [t_auM]
  In the expression: sL
  In a stmt of a list comprehension: s <- sL
env2 [(s, Identifier[s::t_auM, <NotTopLevel>])]
utype_defer
  cobox_auO
  FlatVector
  FlatVector
  a type equality FlatVector ~ FlatVector
  In the expression: listFlatVector (1, s) [0 | i <- [1 .. s]]
  In the expression:
    [listFlatVector (1, s) [0 | i <- [1 .. s]] | s <- sL]
tcPolyExprNC (Int, Int)
tcGen
tcPolyExpr Int
tcPolyExprNC Int
tcGen
tcPolyExpr Int
tcPolyExprNC Int
tcGen
utype_defer
  cobox_auP
  t_auM
  Int
  a type equality t_auM ~ Int
  In the expression: s
  In the first argument of ‘listFlatVector’, namely ‘(1, s)’
tcPolyExprNC [Double]
tcGen
tcPolyExpr t_auQ
tcPolyExprNC t_auQ
tcGen
Instantiating
  fromInteger with [a_auR]
                   [Num a_auR]
instCallConstraints [$dNum_auS]
utype_defer
  cobox_auT
  Integer -> a_auR
  Integer -> t_auQ
  a type equality Integer -> a_auR ~ Integer -> t_auQ
  In the expression: 1
  In the expression: [1 .. s]
  In a stmt of a list comprehension: i <- [1 .. s]
tcPolyExpr t_auQ
tcPolyExprNC t_auQ
tcGen
utype_defer
  cobox_auU
  t_auM
  t_auQ
  a type equality t_auM ~ t_auQ
  In the expression: s
  In the expression: [1 .. s]
instCallConstraints [$dEnum_awR]
env2 [(i, Identifier[i::t_auQ, <NotTopLevel>])]
addInlinePrags
  help
  []
csb2 [help]
} End of bindings for
  [help]
  NonRecursive
  help [FlatVector]
env2 [(help, Identifier[help::[FlatVector], <TopLevel>])]
------------------------------------------------
Bindings for { [tmp]
Generalisation plan
  CheckGen tmp :: Vector FlatVector
                  []
env2 []
tcMonoBinds
env2 []
tcRhs: fun bind
  tmp
  Vector FlatVector
tcMatchesFun
  tmp
  Vector FlatVector
tcGen
tcBody Vector FlatVector
Instantiating
  listVector with [a_awT]
                  []
utype_defer
  cobox_awU
  Vector a_awT
  Vector FlatVector
  a type equality Vector a_awT ~ Vector FlatVector
  In the expression: listVector (1, dim) help
  In an equation for ‘tmp’: tmp = listVector (1, dim) help
tcPolyExprNC (Int, Int)
tcGen
tcPolyExpr Int
tcPolyExprNC Int
tcGen
tcPolyExpr Int
tcPolyExprNC Int
tcGen
utype_defer
  cobox_awV
  t_auG
  Int
  a type equality t_auG ~ Int
  In the expression: dim
  In the first argument of ‘listVector’, namely ‘(1, dim)’
tcPolyExprNC [a_awT]
tcGen
utype_defer
  cobox_awW
  [FlatVector]
  [a_awT]
  a type equality [FlatVector] ~ [a_awT]
  In the second argument of ‘listVector’, namely ‘help’
  In the expression: listVector (1, dim) help
addInlinePrags
  tmp
  []
csb2 [tmp]
} End of bindings for
  [tmp]
  NonRecursive
  tmp Vector FlatVector
env2 [(tmp, Identifier[tmp::Vector FlatVector, <TopLevel>])]
Instantiating
  >>= with [m_ax2]
           [Monad m_ax2]
instCallConstraints [$dMonad_ax3]
utype_defer
  cobox_ax7
  m_ax2 a_ax4 -> (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5
  t_awX -> (t_awY -> t_awZ) -> IO ()
  a type equality m_ax2 a_ax4
                  -> (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5
                  ~
                  t_awX -> (t_awY -> t_awZ) -> IO ()
  In a stmt of a 'do' block: v <- thaw tmp
  In the expression:
    do { let sL = [1, 4, 6, 3, 2, 5]
             dim = length sL
             help :: [FlatVector]
             help = [listFlatVector (1, s) [0 | i <- [1 .. s]] | s <- sL]
             tmp :: Vector FlatVector
             tmp = listVector (1, dim) help;
         v <- thaw tmp;
         return () }
  In an equation for ‘main’:
      main
        = do { let sL = [1, 4, 6, 3, 2, 5]
                   dim = length sL
                   help :: [FlatVector]
                   help = [listFlatVector (1, s) [0 | i <- [1 .. s]] | s <- sL]
                   tmp :: Vector FlatVector
                   tmp = listVector (1, dim) help;
               v <- thaw tmp;
               return () }
Instantiating
  thaw with [a_axr, i_axs, e_axt, m_axu, b_axv]
            [GHC.Arr.Ix i_axs, Data.Array.Base.IArray a_axr e_axt,
             Data.Array.Base.MArray b_axv e_axt m_axu]
instCallConstraints [$dIx_axw, $dIArray_axx, $dMArray_axy]
utype_defer
  cobox_axz
  m_axu (b_axv i_axs e_axt)
  t_awX
  a type equality m_axu (b_axv i_axs e_axt) ~ t_awX
  In a stmt of a 'do' block: v <- thaw tmp
  In the expression:
    do { let sL = [1, 4, 6, 3, 2, 5]
             dim = length sL
             help :: [FlatVector]
             help = [listFlatVector (1, s) [0 | i <- [1 .. s]] | s <- sL]
             tmp :: Vector FlatVector
             tmp = listVector (1, dim) help;
         v <- thaw tmp;
         return () }
tcPolyExprNC a_axr i_axs e_axt
tcGen
utype_defer
  cobox_axA
  Vector FlatVector
  a_axr i_axs e_axt
  a type equality Vector FlatVector ~ a_axr i_axs e_axt
  In the first argument of ‘thaw’, namely ‘tmp’
  In a stmt of a 'do' block: v <- thaw tmp
env2 [(v, Identifier[v::t_awY, <NotTopLevel>])]
Instantiating
  return with [m_axC]
              [Monad m_axC]
instCallConstraints [$dMonad_axD]
utype_defer
  cobox_axG
  m_axC a_axE
  t_awZ
  a type equality m_axC a_axE ~ t_awZ
  In a stmt of a 'do' block: return ()
  In the expression:
    do { let sL = [1, 4, 6, 3, 2, 5]
             dim = length sL
             help :: [FlatVector]
             help = [listFlatVector (1, s) [0 | i <- [1 .. s]] | s <- sL]
             tmp :: Vector FlatVector
             tmp = listVector (1, dim) help;
         v <- thaw tmp;
         return () }
tcPolyExprNC a_axE
tcGen
utype_defer
  cobox_axH
  ()
  a_axE
  a type equality () ~ a_axE
  In the first argument of ‘return’, namely ‘()’
  In a stmt of a 'do' block: return ()
addInlinePrags
  main
  []
csb2 [main]
} End of bindings for
  [main]
  NonRecursive
  main IO ()
env2 [(main, Identifier[main::IO (), <TopLevel>])]
Tc6
env2 []
Tc7
End of tcVectDecls: LIE:
  WC {wc_flat = [W] $dIArray_ar9 :: Data.Array.Base.IArray
                                      a_ar8
                                      e_ar7 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                [W] $dIx_ara :: GHC.Arr.Ix
                                  i_ar6 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                [W] cobox_arb :: ((i_ar6, i_ar6) -> [e_ar7] -> a_ar8 i_ar6 e_ar7)
                                 ~ ((Int, Int) -> [Double] -> FlatVector) [" a type equality (i_ar6,
                                                                                              i_ar6)
                                                                                             -> [e_ar7]
                                                                                             -> a_ar8 i_ar6 e_ar7
                                                                                             ~
                                                                                             (Int,
                                                                                              Int)
                                                                                             -> [Double]
                                                                                             -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
                [W] $dNum_atO :: Num
                                   a_au2 [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                [W] cobox_auJ :: Int ~ t_auG [" a type equality Int
                                                                ~
                                                                t_auG " p4.hs:14:21-29] (CNonCanonical)
                [W] cobox_auK :: [a_au2] ~ [a_auI] [" a type equality [a_au2]
                                                                      ~
                                                                      [a_auI] " p4.hs:14:28-29] (CNonCanonical)
                [W] cobox_auN :: [a_au2] ~ [t_auM] [" a type equality [a_au2]
                                                                      ~
                                                                      [t_auM] " p4.hs:16:61-62] (CNonCanonical)
                [W] cobox_auO :: FlatVector
                                 ~ FlatVector [" a type equality FlatVector
                                                                 ~
                                                                 FlatVector " p4.hs:16:23-56] (CNonCanonical)
                [W] cobox_auP :: t_auM ~ Int [" a type equality t_auM
                                                                ~
                                                                Int " p4.hs:16:41] (CNonCanonical)
                [W] $dNum_auS :: Num
                                   a_auR [" the literal ‘1’ " p4.hs:16:51] (CNonCanonical)
                [W] cobox_auT :: (Integer -> a_auR)
                                 ~ (Integer -> t_auQ) [" a type equality Integer -> a_auR
                                                                         ~
                                                                         Integer
                                                                         -> t_auQ " p4.hs:16:51] (CNonCanonical)
                [W] cobox_auU :: t_auM ~ t_auQ [" a type equality t_auM
                                                                  ~
                                                                  t_auQ " p4.hs:16:54] (CNonCanonical)
                [W] $dEnum_awR :: Enum
                                    t_auQ [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CNonCanonical)
                [W] cobox_awU :: Vector a_awT
                                 ~ Vector FlatVector [" a type equality Vector a_awT
                                                                        ~
                                                                        Vector
                                                                          FlatVector " p4.hs:18:21-43] (CNonCanonical)
                [W] cobox_awV :: t_auG ~ Int [" a type equality t_auG
                                                                ~
                                                                Int " p4.hs:18:35-37] (CNonCanonical)
                [W] cobox_awW :: [FlatVector]
                                 ~ [a_awT] [" a type equality [FlatVector]
                                                              ~
                                                              [a_awT] " p4.hs:18:40-43] (CNonCanonical)
                [W] $dMonad_ax3 :: Monad
                                     m_ax2 [" a do statement " p4.hs:19:11-23] (CNonCanonical)
                [W] cobox_ax7 :: (m_ax2 a_ax4
                                  -> (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5)
                                 ~ (t_awX
                                    -> (t_awY -> t_awZ) -> IO ()) [" a type equality m_ax2 a_ax4
                                                                                     -> (a_ax4
                                                                                         -> m_ax2 b_ax5)
                                                                                     -> m_ax2 b_ax5
                                                                                     ~
                                                                                     t_awX
                                                                                     -> (t_awY
                                                                                         -> t_awZ)
                                                                                     -> IO
                                                                                          () " p4.hs:19:11-23] (CNonCanonical)
                [W] $dIx_axw :: GHC.Arr.Ix
                                  i_axs [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                [W] $dIArray_axx :: Data.Array.Base.IArray
                                      a_axr
                                      e_axt [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                [W] $dMArray_axy :: Data.Array.Base.MArray
                                      b_axv
                                      e_axt
                                      m_axu [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                [W] cobox_axz :: m_axu (b_axv i_axs e_axt)
                                 ~ t_awX [" a type equality m_axu (b_axv i_axs e_axt)
                                                            ~
                                                            t_awX " p4.hs:19:16-23] (CNonCanonical)
                [W] cobox_axA :: Vector FlatVector
                                 ~ a_axr i_axs e_axt [" a type equality Vector FlatVector
                                                                        ~
                                                                        a_axr i_axs e_axt " p4.hs:19:21-23] (CNonCanonical)
                [W] $dMonad_axD :: Monad
                                     m_axC [" a use of ‘return’ " p4.hs:20:11-16] (CNonCanonical)
                [W] cobox_axG :: m_axC a_axE ~ t_awZ [" a type equality m_axC a_axE
                                                                        ~
                                                                        t_awZ " p4.hs:20:11-19] (CNonCanonical)
                [W] cobox_axH :: () ~ a_axE [" a type equality ()
                                                               ~
                                                               a_axE " p4.hs:20:18-19] (CNonCanonical)
      wc_impl = Implic {Untouchables = 1
                        Skolems = a
                        Flatten-skolems =
                        No-eqs = False
                        Given =
                        Wanted = WC {wc_flat = [W] $dIArray_ar1 :: Data.Array.Base.IArray
                                                                     a_ar0
                                                                     e_aqZ [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                               [W] $dIx_ar2 :: GHC.Arr.Ix
                                                                 i_aqY [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                               [W] cobox_ar3 :: ((i_aqY, i_aqY)
                                                                 -> [e_aqZ] -> a_ar0 i_aqY e_aqZ)
                                                                ~ ((Int, Int)
                                                                   -> [a]
                                                                   -> Vector
                                                                        a) [" a type equality (i_aqY,
                                                                                               i_aqY)
                                                                                              -> [e_aqZ]
                                                                                              -> a_ar0 i_aqY e_aqZ
                                                                                              ~
                                                                                              (Int,
                                                                                               Int)
                                                                                              -> [a]
                                                                                              -> Vector
                                                                                                   a " p4.hs:30:14-25] (CNonCanonical)}
                        Binds = EvBindsVar<ar4>
                        the type signature for
                          listVector :: (Int, Int) -> [a] -> Vector a}}
Tc7a
checkMain found Main main
utype_defer
  cobox_axJ
  IO ()
  IO t_axI
  a type equality IO () ~ IO t_axI
  In the expression: main
  When checking the type of the IO action ‘main’
Tc8
simplifyTop {
  wanted =  WC {wc_flat = [W] $dIArray_ar9 :: Data.Array.Base.IArray
                                                a_ar8
                                                e_ar7 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                          [W] $dIx_ara :: GHC.Arr.Ix
                                            i_ar6 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                          [W] cobox_arb :: ((i_ar6, i_ar6) -> [e_ar7] -> a_ar8 i_ar6 e_ar7)
                                           ~ ((Int, Int)
                                              -> [Double] -> FlatVector) [" a type equality (i_ar6,
                                                                                             i_ar6)
                                                                                            -> [e_ar7]
                                                                                            -> a_ar8 i_ar6 e_ar7
                                                                                            ~
                                                                                            (Int,
                                                                                             Int)
                                                                                            -> [Double]
                                                                                            -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
                          [W] $dNum_atO :: Num
                                             a_au2 [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                          [W] cobox_auJ :: Int ~ t_auG [" a type equality Int
                                                                          ~
                                                                          t_auG " p4.hs:14:21-29] (CNonCanonical)
                          [W] cobox_auK :: [a_au2] ~ [a_auI] [" a type equality [a_au2]
                                                                                ~
                                                                                [a_auI] " p4.hs:14:28-29] (CNonCanonical)
                          [W] cobox_auN :: [a_au2] ~ [t_auM] [" a type equality [a_au2]
                                                                                ~
                                                                                [t_auM] " p4.hs:16:61-62] (CNonCanonical)
                          [W] cobox_auO :: FlatVector
                                           ~ FlatVector [" a type equality FlatVector
                                                                           ~
                                                                           FlatVector " p4.hs:16:23-56] (CNonCanonical)
                          [W] cobox_auP :: t_auM ~ Int [" a type equality t_auM
                                                                          ~
                                                                          Int " p4.hs:16:41] (CNonCanonical)
                          [W] $dNum_auS :: Num
                                             a_auR [" the literal ‘1’ " p4.hs:16:51] (CNonCanonical)
                          [W] cobox_auT :: (Integer -> a_auR)
                                           ~ (Integer -> t_auQ) [" a type equality Integer -> a_auR
                                                                                   ~
                                                                                   Integer
                                                                                   -> t_auQ " p4.hs:16:51] (CNonCanonical)
                          [W] cobox_auU :: t_auM ~ t_auQ [" a type equality t_auM
                                                                            ~
                                                                            t_auQ " p4.hs:16:54] (CNonCanonical)
                          [W] $dEnum_awR :: Enum
                                              t_auQ [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CNonCanonical)
                          [W] cobox_awU :: Vector a_awT
                                           ~ Vector FlatVector [" a type equality Vector a_awT
                                                                                  ~
                                                                                  Vector
                                                                                    FlatVector " p4.hs:18:21-43] (CNonCanonical)
                          [W] cobox_awV :: t_auG ~ Int [" a type equality t_auG
                                                                          ~
                                                                          Int " p4.hs:18:35-37] (CNonCanonical)
                          [W] cobox_awW :: [FlatVector]
                                           ~ [a_awT] [" a type equality [FlatVector]
                                                                        ~
                                                                        [a_awT] " p4.hs:18:40-43] (CNonCanonical)
                          [W] $dMonad_ax3 :: Monad
                                               m_ax2 [" a do statement " p4.hs:19:11-23] (CNonCanonical)
                          [W] cobox_ax7 :: (m_ax2 a_ax4
                                            -> (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5)
                                           ~ (t_awX
                                              -> (t_awY -> t_awZ)
                                              -> IO ()) [" a type equality m_ax2 a_ax4
                                                                           -> (a_ax4 -> m_ax2 b_ax5)
                                                                           -> m_ax2 b_ax5
                                                                           ~
                                                                           t_awX
                                                                           -> (t_awY -> t_awZ)
                                                                           -> IO
                                                                                () " p4.hs:19:11-23] (CNonCanonical)
                          [W] $dIx_axw :: GHC.Arr.Ix
                                            i_axs [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                          [W] $dIArray_axx :: Data.Array.Base.IArray
                                                a_axr
                                                e_axt [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                          [W] $dMArray_axy :: Data.Array.Base.MArray
                                                b_axv
                                                e_axt
                                                m_axu [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                          [W] cobox_axz :: m_axu (b_axv i_axs e_axt)
                                           ~ t_awX [" a type equality m_axu (b_axv i_axs e_axt)
                                                                      ~
                                                                      t_awX " p4.hs:19:16-23] (CNonCanonical)
                          [W] cobox_axA :: Vector FlatVector
                                           ~ a_axr i_axs e_axt [" a type equality Vector FlatVector
                                                                                  ~
                                                                                  a_axr i_axs e_axt " p4.hs:19:21-23] (CNonCanonical)
                          [W] $dMonad_axD :: Monad
                                               m_axC [" a use of ‘return’ " p4.hs:20:11-16] (CNonCanonical)
                          [W] cobox_axG :: m_axC a_axE ~ t_awZ [" a type equality m_axC a_axE
                                                                                  ~
                                                                                  t_awZ " p4.hs:20:11-19] (CNonCanonical)
                          [W] cobox_axH :: () ~ a_axE [" a type equality ()
                                                                         ~
                                                                         a_axE " p4.hs:20:18-19] (CNonCanonical)
                          [W] cobox_axJ :: IO () ~ IO t_axI [" a type equality IO ()
                                                                               ~
                                                                               IO
                                                                                 t_axI " p4.hs:13:1] (CNonCanonical)
                wc_impl = Implic {Untouchables = 1
                                  Skolems = a
                                  Flatten-skolems =
                                  No-eqs = False
                                  Given =
                                  Wanted = WC {wc_flat = [W] $dIArray_ar1 :: Data.Array.Base.IArray
                                                                               a_ar0
                                                                               e_aqZ [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                                         [W] $dIx_ar2 :: GHC.Arr.Ix
                                                                           i_aqY [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                                         [W] cobox_ar3 :: ((i_aqY, i_aqY)
                                                                           -> [e_aqZ]
                                                                           -> a_ar0 i_aqY e_aqZ)
                                                                          ~ ((Int, Int)
                                                                             -> [a]
                                                                             -> Vector
                                                                                  a) [" a type equality (i_aqY,
                                                                                                         i_aqY)
                                                                                                        -> [e_aqZ]
                                                                                                        -> a_ar0 i_aqY e_aqZ
                                                                                                        ~
                                                                                                        (Int,
                                                                                                         Int)
                                                                                                        -> [a]
                                                                                                        -> Vector
                                                                                                             a " p4.hs:30:14-25] (CNonCanonical)}
                                  Binds = EvBindsVar<ar4>
                                  the type signature for
                                    listVector :: (Int, Int) -> [a] -> Vector a}}
solveWantedsTcMWithEvBinds
  wanted= WC {wc_flat = [W] $dIArray_ar9 :: Data.Array.Base.IArray
                                              a_ar8
                                              e_ar7 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                        [W] $dIx_ara :: GHC.Arr.Ix
                                          i_ar6 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                        [W] cobox_arb :: ((i_ar6, i_ar6) -> [e_ar7] -> a_ar8 i_ar6 e_ar7)
                                         ~ ((Int, Int)
                                            -> [Double] -> FlatVector) [" a type equality (i_ar6,
                                                                                           i_ar6)
                                                                                          -> [e_ar7]
                                                                                          -> a_ar8 i_ar6 e_ar7
                                                                                          ~
                                                                                          (Int, Int)
                                                                                          -> [Double]
                                                                                          -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
                        [W] $dNum_atO :: Num
                                           a_au2 [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                        [W] cobox_auJ :: Int ~ t_auG [" a type equality Int
                                                                        ~
                                                                        t_auG " p4.hs:14:21-29] (CNonCanonical)
                        [W] cobox_auK :: [a_au2] ~ [a_auI] [" a type equality [a_au2]
                                                                              ~
                                                                              [a_auI] " p4.hs:14:28-29] (CNonCanonical)
                        [W] cobox_auN :: [a_au2] ~ [t_auM] [" a type equality [a_au2]
                                                                              ~
                                                                              [t_auM] " p4.hs:16:61-62] (CNonCanonical)
                        [W] cobox_auO :: FlatVector
                                         ~ FlatVector [" a type equality FlatVector
                                                                         ~
                                                                         FlatVector " p4.hs:16:23-56] (CNonCanonical)
                        [W] cobox_auP :: t_auM ~ Int [" a type equality t_auM
                                                                        ~
                                                                        Int " p4.hs:16:41] (CNonCanonical)
                        [W] $dNum_auS :: Num
                                           a_auR [" the literal ‘1’ " p4.hs:16:51] (CNonCanonical)
                        [W] cobox_auT :: (Integer -> a_auR)
                                         ~ (Integer -> t_auQ) [" a type equality Integer -> a_auR
                                                                                 ~
                                                                                 Integer
                                                                                 -> t_auQ " p4.hs:16:51] (CNonCanonical)
                        [W] cobox_auU :: t_auM ~ t_auQ [" a type equality t_auM
                                                                          ~
                                                                          t_auQ " p4.hs:16:54] (CNonCanonical)
                        [W] $dEnum_awR :: Enum
                                            t_auQ [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CNonCanonical)
                        [W] cobox_awU :: Vector a_awT
                                         ~ Vector FlatVector [" a type equality Vector a_awT
                                                                                ~
                                                                                Vector
                                                                                  FlatVector " p4.hs:18:21-43] (CNonCanonical)
                        [W] cobox_awV :: t_auG ~ Int [" a type equality t_auG
                                                                        ~
                                                                        Int " p4.hs:18:35-37] (CNonCanonical)
                        [W] cobox_awW :: [FlatVector]
                                         ~ [a_awT] [" a type equality [FlatVector]
                                                                      ~
                                                                      [a_awT] " p4.hs:18:40-43] (CNonCanonical)
                        [W] $dMonad_ax3 :: Monad
                                             m_ax2 [" a do statement " p4.hs:19:11-23] (CNonCanonical)
                        [W] cobox_ax7 :: (m_ax2 a_ax4
                                          -> (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5)
                                         ~ (t_awX
                                            -> (t_awY -> t_awZ)
                                            -> IO ()) [" a type equality m_ax2 a_ax4
                                                                         -> (a_ax4 -> m_ax2 b_ax5)
                                                                         -> m_ax2 b_ax5
                                                                         ~
                                                                         t_awX
                                                                         -> (t_awY -> t_awZ)
                                                                         -> IO
                                                                              () " p4.hs:19:11-23] (CNonCanonical)
                        [W] $dIx_axw :: GHC.Arr.Ix
                                          i_axs [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                        [W] $dIArray_axx :: Data.Array.Base.IArray
                                              a_axr
                                              e_axt [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                        [W] $dMArray_axy :: Data.Array.Base.MArray
                                              b_axv
                                              e_axt
                                              m_axu [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                        [W] cobox_axz :: m_axu (b_axv i_axs e_axt)
                                         ~ t_awX [" a type equality m_axu (b_axv i_axs e_axt)
                                                                    ~
                                                                    t_awX " p4.hs:19:16-23] (CNonCanonical)
                        [W] cobox_axA :: Vector FlatVector
                                         ~ a_axr i_axs e_axt [" a type equality Vector FlatVector
                                                                                ~
                                                                                a_axr i_axs e_axt " p4.hs:19:21-23] (CNonCanonical)
                        [W] $dMonad_axD :: Monad
                                             m_axC [" a use of ‘return’ " p4.hs:20:11-16] (CNonCanonical)
                        [W] cobox_axG :: m_axC a_axE ~ t_awZ [" a type equality m_axC a_axE
                                                                                ~
                                                                                t_awZ " p4.hs:20:11-19] (CNonCanonical)
                        [W] cobox_axH :: () ~ a_axE [" a type equality ()
                                                                       ~
                                                                       a_axE " p4.hs:20:18-19] (CNonCanonical)
                        [W] cobox_axJ :: IO () ~ IO t_axI [" a type equality IO ()
                                                                             ~
                                                                             IO
                                                                               t_axI " p4.hs:13:1] (CNonCanonical)
              wc_impl = Implic {Untouchables = 1
                                Skolems = a
                                Flatten-skolems =
                                No-eqs = False
                                Given =
                                Wanted = WC {wc_flat = [W] $dIArray_ar1 :: Data.Array.Base.IArray
                                                                             a_ar0
                                                                             e_aqZ [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                                       [W] $dIx_ar2 :: GHC.Arr.Ix
                                                                         i_aqY [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                                       [W] cobox_ar3 :: ((i_aqY, i_aqY)
                                                                         -> [e_aqZ]
                                                                         -> a_ar0 i_aqY e_aqZ)
                                                                        ~ ((Int, Int)
                                                                           -> [a]
                                                                           -> Vector
                                                                                a) [" a type equality (i_aqY,
                                                                                                       i_aqY)
                                                                                                      -> [e_aqZ]
                                                                                                      -> a_ar0 i_aqY e_aqZ
                                                                                                      ~
                                                                                                      (Int,
                                                                                                       Int)
                                                                                                      -> [a]
                                                                                                      -> Vector
                                                                                                           a " p4.hs:30:14-25] (CNonCanonical)}
                                Binds = EvBindsVar<ar4>
                                the type signature for
                                  listVector :: (Int, Int) -> [a] -> Vector a}}
solveWanteds {
  WC {wc_flat = [W] $dIArray_ar9 :: Data.Array.Base.IArray
                                      a_ar8
                                      e_ar7 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                [W] $dIx_ara :: GHC.Arr.Ix
                                  i_ar6 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                [W] cobox_arb :: ((i_ar6, i_ar6) -> [e_ar7] -> a_ar8 i_ar6 e_ar7)
                                 ~ ((Int, Int) -> [Double] -> FlatVector) [" a type equality (i_ar6,
                                                                                              i_ar6)
                                                                                             -> [e_ar7]
                                                                                             -> a_ar8 i_ar6 e_ar7
                                                                                             ~
                                                                                             (Int,
                                                                                              Int)
                                                                                             -> [Double]
                                                                                             -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
                [W] $dNum_atO :: Num
                                   a_au2 [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                [W] cobox_auJ :: Int ~ t_auG [" a type equality Int
                                                                ~
                                                                t_auG " p4.hs:14:21-29] (CNonCanonical)
                [W] cobox_auK :: [a_au2] ~ [a_auI] [" a type equality [a_au2]
                                                                      ~
                                                                      [a_auI] " p4.hs:14:28-29] (CNonCanonical)
                [W] cobox_auN :: [a_au2] ~ [t_auM] [" a type equality [a_au2]
                                                                      ~
                                                                      [t_auM] " p4.hs:16:61-62] (CNonCanonical)
                [W] cobox_auO :: FlatVector
                                 ~ FlatVector [" a type equality FlatVector
                                                                 ~
                                                                 FlatVector " p4.hs:16:23-56] (CNonCanonical)
                [W] cobox_auP :: t_auM ~ Int [" a type equality t_auM
                                                                ~
                                                                Int " p4.hs:16:41] (CNonCanonical)
                [W] $dNum_auS :: Num
                                   a_auR [" the literal ‘1’ " p4.hs:16:51] (CNonCanonical)
                [W] cobox_auT :: (Integer -> a_auR)
                                 ~ (Integer -> t_auQ) [" a type equality Integer -> a_auR
                                                                         ~
                                                                         Integer
                                                                         -> t_auQ " p4.hs:16:51] (CNonCanonical)
                [W] cobox_auU :: t_auM ~ t_auQ [" a type equality t_auM
                                                                  ~
                                                                  t_auQ " p4.hs:16:54] (CNonCanonical)
                [W] $dEnum_awR :: Enum
                                    t_auQ [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CNonCanonical)
                [W] cobox_awU :: Vector a_awT
                                 ~ Vector FlatVector [" a type equality Vector a_awT
                                                                        ~
                                                                        Vector
                                                                          FlatVector " p4.hs:18:21-43] (CNonCanonical)
                [W] cobox_awV :: t_auG ~ Int [" a type equality t_auG
                                                                ~
                                                                Int " p4.hs:18:35-37] (CNonCanonical)
                [W] cobox_awW :: [FlatVector]
                                 ~ [a_awT] [" a type equality [FlatVector]
                                                              ~
                                                              [a_awT] " p4.hs:18:40-43] (CNonCanonical)
                [W] $dMonad_ax3 :: Monad
                                     m_ax2 [" a do statement " p4.hs:19:11-23] (CNonCanonical)
                [W] cobox_ax7 :: (m_ax2 a_ax4
                                  -> (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5)
                                 ~ (t_awX
                                    -> (t_awY -> t_awZ) -> IO ()) [" a type equality m_ax2 a_ax4
                                                                                     -> (a_ax4
                                                                                         -> m_ax2 b_ax5)
                                                                                     -> m_ax2 b_ax5
                                                                                     ~
                                                                                     t_awX
                                                                                     -> (t_awY
                                                                                         -> t_awZ)
                                                                                     -> IO
                                                                                          () " p4.hs:19:11-23] (CNonCanonical)
                [W] $dIx_axw :: GHC.Arr.Ix
                                  i_axs [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                [W] $dIArray_axx :: Data.Array.Base.IArray
                                      a_axr
                                      e_axt [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                [W] $dMArray_axy :: Data.Array.Base.MArray
                                      b_axv
                                      e_axt
                                      m_axu [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                [W] cobox_axz :: m_axu (b_axv i_axs e_axt)
                                 ~ t_awX [" a type equality m_axu (b_axv i_axs e_axt)
                                                            ~
                                                            t_awX " p4.hs:19:16-23] (CNonCanonical)
                [W] cobox_axA :: Vector FlatVector
                                 ~ a_axr i_axs e_axt [" a type equality Vector FlatVector
                                                                        ~
                                                                        a_axr i_axs e_axt " p4.hs:19:21-23] (CNonCanonical)
                [W] $dMonad_axD :: Monad
                                     m_axC [" a use of ‘return’ " p4.hs:20:11-16] (CNonCanonical)
                [W] cobox_axG :: m_axC a_axE ~ t_awZ [" a type equality m_axC a_axE
                                                                        ~
                                                                        t_awZ " p4.hs:20:11-19] (CNonCanonical)
                [W] cobox_axH :: () ~ a_axE [" a type equality ()
                                                               ~
                                                               a_axE " p4.hs:20:18-19] (CNonCanonical)
                [W] cobox_axJ :: IO () ~ IO t_axI [" a type equality IO ()
                                                                     ~
                                                                     IO
                                                                       t_axI " p4.hs:13:1] (CNonCanonical)
      wc_impl = Implic {Untouchables = 1
                        Skolems = a
                        Flatten-skolems =
                        No-eqs = False
                        Given =
                        Wanted = WC {wc_flat = [W] $dIArray_ar1 :: Data.Array.Base.IArray
                                                                     a_ar0
                                                                     e_aqZ [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                               [W] $dIx_ar2 :: GHC.Arr.Ix
                                                                 i_aqY [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                               [W] cobox_ar3 :: ((i_aqY, i_aqY)
                                                                 -> [e_aqZ] -> a_ar0 i_aqY e_aqZ)
                                                                ~ ((Int, Int)
                                                                   -> [a]
                                                                   -> Vector
                                                                        a) [" a type equality (i_aqY,
                                                                                               i_aqY)
                                                                                              -> [e_aqZ]
                                                                                              -> a_ar0 i_aqY e_aqZ
                                                                                              ~
                                                                                              (Int,
                                                                                               Int)
                                                                                              -> [a]
                                                                                              -> Vector
                                                                                                   a " p4.hs:30:14-25] (CNonCanonical)}
                        Binds = EvBindsVar<ar4>
                        the type signature for
                          listVector :: (Int, Int) -> [a] -> Vector a}}
solveFlats {
Start solver pipeline {
  work item =  [W] cobox_arb :: ((i_ar6, i_ar6)
                                 -> [e_ar7] -> a_ar8 i_ar6 e_ar7)
                                ~ ((Int, Int) -> [Double] -> FlatVector) [" a type equality (i_ar6,
                                                                                             i_ar6)
                                                                                            -> [e_ar7]
                                                                                            -> a_ar8 i_ar6 e_ar7
                                                                                            ~
                                                                                            (Int,
                                                                                             Int)
                                                                                            -> [Double]
                                                                                            -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_arb :: ((i_ar6, i_ar6)
                                  -> [e_ar7] -> a_ar8 i_ar6 e_ar7)
                                 ~ ((Int, Int) -> [Double] -> FlatVector) [" a type equality (i_ar6,
                                                                                              i_ar6)
                                                                                             -> [e_ar7]
                                                                                             -> a_ar8 i_ar6 e_ar7
                                                                                             ~
                                                                                             (Int,
                                                                                              Int)
                                                                                             -> [Double]
                                                                                             -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_arb :: ((i_ar6, i_ar6) -> [e_ar7] -> a_ar8 i_ar6 e_ar7)
                   ~ ((Int, Int) -> [Double] -> FlatVector) [" a type equality (i_ar6,
                                                                                i_ar6)
                                                                               -> [e_ar7]
                                                                               -> a_ar8 i_ar6 e_ar7
                                                                               ~
                                                                               (Int, Int)
                                                                               -> [Double]
                                                                               -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canEvNC:eq
  (i_ar6, i_ar6) -> [e_ar7] -> a_ar8 i_ar6 e_ar7
  (Int, Int) -> [Double] -> FlatVector
can_eq_nc
  [W] cobox_arb :: ((i_ar6, i_ar6) -> [e_ar7] -> a_ar8 i_ar6 e_ar7)
                   ~ ((Int, Int) -> [Double] -> FlatVector)
  (i_ar6, i_ar6) -> [e_ar7] -> a_ar8 i_ar6 e_ar7
  (i_ar6, i_ar6) -> [e_ar7] -> a_ar8 i_ar6 e_ar7
  (Int, Int) -> [Double] -> FlatVector
  (Int, Int) -> [Double] -> FlatVector
newWantedEvVar/cache miss
  [W] cobox_ay2 :: (i_ar6, i_ar6) ~ (Int, Int)
newWantedEvVar/cache miss
  [W] cobox_ay3 :: ([e_ar7] -> a_ar8 i_ar6 e_ar7)
                   ~ ([Double] -> FlatVector)
setEvBind
  ev = cobox_arb
  tm  = CO cobox_ay2 -> cobox_ay3
canEvNC:eq
  (i_ar6, i_ar6)
  (Int, Int)
can_eq_nc
  [W] cobox_ay2 :: (i_ar6, i_ar6) ~ (Int, Int)
  (i_ar6, i_ar6)
  (i_ar6, i_ar6)
  (Int, Int)
  (Int, Int)
newWantedEvVar/cache miss [W] cobox_ay4 :: i_ar6 ~ Int
newWantedEvVar/cache miss [W] cobox_ay5 :: i_ar6 ~ Int
setEvBind
  ev = cobox_ay2
  tm  = CO (cobox_ay4, cobox_ay5)_N
canEvNC:eq
  i_ar6
  Int
can_eq_nc
  [W] cobox_ay4 :: i_ar6 ~ Int
  i_ar6
  i_ar6
  Int
  Int
canEqTyVar
  i_ar6
  Int
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ay4 :: i_ar6
                                 ~ Int [" a type equality (i_ar6, i_ar6)
                                                          -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                          ~
                                                          (Int, Int)
                                                          -> [Double]
                                                          -> FlatVector " p4.hs:25:18-29] (CTyEqCan)
Sneaky unification:
  Unifies: i_ar6 := Int
  Coercion: i_ar6 ~ Int
  Left Kind is: *
  Right Kind is: *
setWantedTyBind i_ar6 := Int
setEvBind
  ev = cobox_ay4
  tm  = CO <Int>_N
kickOutRewritable
  tv =  i_ar6
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
1[<C:0,F:0>] [W] cobox_ay4 :: i_ar6 ~ Int: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ay5 :: i_ar6
                                ~ Int [" a type equality (i_ar6, i_ar6)
                                                         -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                         ~
                                                         (Int, Int)
                                                         -> [Double]
                                                         -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ay5 :: i_ar6
                                 ~ Int [" a type equality (i_ar6, i_ar6)
                                                          -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                          ~
                                                          (Int, Int)
                                                          -> [Double]
                                                          -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ay5 :: i_ar6 ~ Int [" a type equality (i_ar6, i_ar6)
                                                  -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                  ~
                                                  (Int, Int)
                                                  -> [Double]
                                                  -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canEvNC:eq
  i_ar6
  Int
can_eq_nc
  [W] cobox_ay5 :: i_ar6 ~ Int
  i_ar6
  i_ar6
  Int
  Int
canEqTyVar
  i_ar6
  Int
  Not-swapped
Following bound tyvar i_ar6 = Int
canEqTyVar2
  i_ar6
  Int
  Not-swapped
  Int
  <Int>_N
can_eq_nc
  [W] cobox_ay5 :: Int ~ Int
  Int
  Int
  Int
  Int
setEvBind
  ev = cobox_ay5
  tm  = CO <Int>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ay3 :: ([e_ar7] -> a_ar8 i_ar6 e_ar7)
                                ~ ([Double] -> FlatVector) [" a type equality (i_ar6, i_ar6)
                                                                              -> [e_ar7]
                                                                              -> a_ar8 i_ar6 e_ar7
                                                                              ~
                                                                              (Int, Int)
                                                                              -> [Double]
                                                                              -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ay3 :: ([e_ar7] -> a_ar8 i_ar6 e_ar7)
                                 ~ ([Double] -> FlatVector) [" a type equality (i_ar6, i_ar6)
                                                                               -> [e_ar7]
                                                                               -> a_ar8 i_ar6 e_ar7
                                                                               ~
                                                                               (Int, Int)
                                                                               -> [Double]
                                                                               -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ay3 :: ([e_ar7] -> a_ar8 i_ar6 e_ar7)
                   ~ ([Double] -> FlatVector) [" a type equality (i_ar6, i_ar6)
                                                                 -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                                 ~
                                                                 (Int, Int)
                                                                 -> [Double]
                                                                 -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canEvNC:eq
  [e_ar7] -> a_ar8 i_ar6 e_ar7
  [Double] -> FlatVector
can_eq_nc
  [W] cobox_ay3 :: ([e_ar7] -> a_ar8 i_ar6 e_ar7)
                   ~ ([Double] -> FlatVector)
  [e_ar7] -> a_ar8 i_ar6 e_ar7
  [e_ar7] -> a_ar8 i_ar6 e_ar7
  [Double] -> FlatVector
  [Double] -> FlatVector
newWantedEvVar/cache miss [W] cobox_ay6 :: [e_ar7] ~ [Double]
newWantedEvVar/cache miss
  [W] cobox_ay7 :: a_ar8 i_ar6 e_ar7 ~ FlatVector
setEvBind
  ev = cobox_ay3
  tm  = CO cobox_ay6 -> cobox_ay7
canEvNC:eq
  [e_ar7]
  [Double]
can_eq_nc
  [W] cobox_ay6 :: [e_ar7] ~ [Double]
  [e_ar7]
  [e_ar7]
  [Double]
  [Double]
newWantedEvVar/cache miss [W] cobox_ay8 :: e_ar7 ~ Double
setEvBind
  ev = cobox_ay6
  tm  = CO [cobox_ay8]_N
canEvNC:eq
  e_ar7
  Double
can_eq_nc
  [W] cobox_ay8 :: e_ar7 ~ Double
  e_ar7
  e_ar7
  Double
  Double
canEqTyVar
  e_ar7
  Double
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ay8 :: e_ar7
                                 ~ Double [" a type equality (i_ar6, i_ar6)
                                                             -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                             ~
                                                             (Int, Int)
                                                             -> [Double]
                                                             -> FlatVector " p4.hs:25:18-29] (CTyEqCan)
Sneaky unification:
  Unifies: e_ar7 := Double
  Coercion: e_ar7 ~ Double
  Left Kind is: *
  Right Kind is: *
setWantedTyBind e_ar7 := Double
setEvBind
  ev = cobox_ay8
  tm  = CO <Double>_N
kickOutRewritable
  tv =  e_ar7
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
3[<C:0,F:0>] [W] cobox_ay8 :: e_ar7 ~ Double: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ay7 :: a_ar8 i_ar6 e_ar7
                                ~ FlatVector [" a type equality (i_ar6, i_ar6)
                                                                -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                                ~
                                                                (Int, Int)
                                                                -> [Double]
                                                                -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ay7 :: a_ar8 i_ar6 e_ar7
                                 ~ FlatVector [" a type equality (i_ar6, i_ar6)
                                                                 -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                                 ~
                                                                 (Int, Int)
                                                                 -> [Double]
                                                                 -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ay7 :: a_ar8 i_ar6 e_ar7
                   ~ FlatVector [" a type equality (i_ar6, i_ar6)
                                                   -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                   ~
                                                   (Int, Int)
                                                   -> [Double]
                                                   -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canEvNC:eq
  a_ar8 i_ar6 e_ar7
  FlatVector
can_eq_nc
  [W] cobox_ay7 :: a_ar8 i_ar6 e_ar7 ~ FlatVector
  a_ar8 i_ar6 e_ar7
  a_ar8 i_ar6 e_ar7
  FlatVector
  FlatVector
can_eq_nc
  [W] cobox_ay7 :: a_ar8 i_ar6 e_ar7 ~ FlatVector
  a_ar8 i_ar6 e_ar7
  a_ar8 i_ar6 e_ar7
  UArray Int Double
  FlatVector
can_eq_app 1
  [W] cobox_ay7 :: a_ar8 i_ar6 e_ar7 ~ FlatVector
  Not-swapped
  a_ar8 i_ar6
  e_ar7
  UArray Int Double
Following bound tyvar i_ar6 = Int
flatten/appty
  a_ar8
  i_ar6
  a_ar8
  <a_ar8>_N
  Int
  <Int>_N
can_eq_app 2
  [W] cobox_ay7 :: a_ar8 i_ar6 e_ar7 ~ FlatVector
  a_ar8 Int
Following bound tyvar e_ar7 = Double
can_eq_app 3
  [W] cobox_ay7 :: a_ar8 i_ar6 e_ar7 ~ FlatVector
  a_ar8 Int Double
  <a_ar8 Int Double>_N
can_eq_app 4
  [W] cobox_ay7 :: a_ar8 i_ar6 e_ar7 ~ FlatVector
  a_ar8 Int Double
  <a_ar8 Int Double>_N
can_eq_nc
  [W] cobox_ay7 :: a_ar8 Int Double ~ FlatVector
  a_ar8 Int Double
  a_ar8 Int Double
  UArray Int Double
  FlatVector
can_eq_app 1
  [W] cobox_ay7 :: a_ar8 Int Double ~ FlatVector
  Not-swapped
  a_ar8 Int
  Double
  UArray Int Double
flatten/appty
  a_ar8
  Int
  a_ar8
  <a_ar8>_N
  Int
  <Int>_N
can_eq_app 2
  [W] cobox_ay7 :: a_ar8 Int Double ~ FlatVector
  a_ar8 Int
newWantedEvVar/cache miss [W] cobox_ay9 :: a_ar8 Int ~ UArray Int
newWantedEvVar/cache miss [W] cobox_aya :: Double ~ Double
setEvBind
  ev = cobox_ay7
  tm  = CO cobox_ay9 cobox_aya
canEvNC:eq
  a_ar8 Int
  UArray Int
can_eq_nc
  [W] cobox_ay9 :: a_ar8 Int ~ UArray Int
  a_ar8 Int
  a_ar8 Int
  UArray Int
  UArray Int
can_eq_app 1
  [W] cobox_ay9 :: a_ar8 Int ~ UArray Int
  Not-swapped
  a_ar8
  Int
  UArray Int
can_eq_app 2
  [W] cobox_ay9 :: a_ar8 Int ~ UArray Int
  a_ar8
newWantedEvVar/cache miss [W] cobox_ayb :: a_ar8 ~ UArray
newWantedEvVar/cache miss [W] cobox_ayc :: Int ~ Int
setEvBind
  ev = cobox_ay9
  tm  = CO cobox_ayb cobox_ayc
canEvNC:eq
  a_ar8
  UArray
can_eq_nc
  [W] cobox_ayb :: a_ar8 ~ UArray
  a_ar8
  a_ar8
  UArray
  UArray
canEqTyVar
  a_ar8
  UArray
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayb :: a_ar8
                                 ~ UArray [" a type equality (i_ar6, i_ar6)
                                                             -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                             ~
                                                             (Int, Int)
                                                             -> [Double]
                                                             -> FlatVector " p4.hs:25:18-29] (CTyEqCan)
Sneaky unification:
  Unifies: a_ar8 := UArray
  Coercion: a_ar8 ~ UArray
  Left Kind is: * -> * -> *
  Right Kind is: * -> * -> *
setWantedTyBind a_ar8 := UArray
setEvBind
  ev = cobox_ayb
  tm  = CO <UArray>_N
kickOutRewritable
  tv =  a_ar8
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
4[<C:0,F:0>] [W] cobox_ayb :: a_ar8 ~ UArray: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ayc :: Int ~ Int [" a type equality (i_ar6,
                                                              i_ar6)
                                                             -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                             ~
                                                             (Int, Int)
                                                             -> [Double]
                                                             -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ayc :: Int ~ Int [" a type equality (i_ar6,
                                                               i_ar6)
                                                              -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                              ~
                                                              (Int, Int)
                                                              -> [Double]
                                                              -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ayc :: Int ~ Int [" a type equality (i_ar6, i_ar6)
                                                -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                ~
                                                (Int, Int)
                                                -> [Double]
                                                -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canEvNC:eq
  Int
  Int
can_eq_nc
  [W] cobox_ayc :: Int ~ Int
  Int
  Int
  Int
  Int
setEvBind
  ev = cobox_ayc
  tm  = CO <Int>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_aya :: Double
                                ~ Double [" a type equality (i_ar6, i_ar6)
                                                            -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                            ~
                                                            (Int, Int)
                                                            -> [Double]
                                                            -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_aya :: Double
                                 ~ Double [" a type equality (i_ar6, i_ar6)
                                                             -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                             ~
                                                             (Int, Int)
                                                             -> [Double]
                                                             -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_aya :: Double ~ Double [" a type equality (i_ar6, i_ar6)
                                                      -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                      ~
                                                      (Int, Int)
                                                      -> [Double]
                                                      -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canEvNC:eq
  Double
  Double
can_eq_nc
  [W] cobox_aya :: Double ~ Double
  Double
  Double
  Double
  Double
setEvBind
  ev = cobox_aya
  tm  = CO <Double>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_auJ :: Int ~ t_auG [" a type equality Int
                                                               ~
                                                               t_auG " p4.hs:14:21-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_auJ :: Int ~ t_auG [" a type equality Int
                                                                ~
                                                                t_auG " p4.hs:14:21-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_auJ :: Int ~ t_auG [" a type equality Int
                                                  ~
                                                  t_auG " p4.hs:14:21-29] (CNonCanonical)
canEvNC:eq
  Int
  t_auG
can_eq_nc
  [W] cobox_auJ :: Int ~ t_auG
  Int
  Int
  t_auG
  t_auG
canEqTyVar
  t_auG
  Int
  Is-swapped
newWantedEvVar/cache miss [W] cobox_ayd :: t_auG ~ Int
setEvBind
  ev = cobox_auJ
  tm  = CO Sym cobox_ayd
rewriteEqEvidence
  [W] cobox_auJ :: Int ~ t_auG
  t_auG
  Int
  Sym cobox_ayd
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayd :: t_auG ~ Int [" a type equality Int
                                                                ~
                                                                t_auG " p4.hs:14:21-29] (CTyEqCan)
Sneaky unification:
  Unifies: t_auG := Int
  Coercion: t_auG ~ Int
  Left Kind is: OpenKind
  Right Kind is: *
setWantedTyBind t_auG := Int
setEvBind
  ev = cobox_ayd
  tm  = CO <Int>_N
kickOutRewritable
  tv =  t_auG
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
7[<C:0,F:0>] [W] cobox_ayd :: t_auG ~ Int: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_auK :: [a_au2]
                                ~ [a_auI] [" a type equality [a_au2]
                                                             ~
                                                             [a_auI] " p4.hs:14:28-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_auK :: [a_au2]
                                 ~ [a_auI] [" a type equality [a_au2]
                                                              ~
                                                              [a_auI] " p4.hs:14:28-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_auK :: [a_au2] ~ [a_auI] [" a type equality [a_au2]
                                                        ~
                                                        [a_auI] " p4.hs:14:28-29] (CNonCanonical)
canEvNC:eq
  [a_au2]
  [a_auI]
can_eq_nc
  [W] cobox_auK :: [a_au2] ~ [a_auI]
  [a_au2]
  [a_au2]
  [a_auI]
  [a_auI]
newWantedEvVar/cache miss [W] cobox_aye :: a_au2 ~ a_auI
setEvBind
  ev = cobox_auK
  tm  = CO [cobox_aye]_N
canEvNC:eq
  a_au2
  a_auI
can_eq_nc
  [W] cobox_aye :: a_au2 ~ a_auI
  a_au2
  a_au2
  a_auI
  a_auI
canEqTyVar
  a_au2
  a_auI
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_aye :: a_au2
                                 ~ a_auI [" a type equality [a_au2]
                                                            ~
                                                            [a_auI] " p4.hs:14:28-29] (CTyEqCan)
Sneaky unification:
  Unifies: a_auI := a_au2
  Coercion: a_auI ~ a_au2
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_auI := a_au2
setEvBind
  ev = cobox_aye
  tm  = CO <a_au2>_N
kickOutRewritable
  tv =  a_auI
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
8[<C:0,F:0>] [W] cobox_aye :: a_au2 ~ a_auI: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_auN :: [a_au2]
                                ~ [t_auM] [" a type equality [a_au2]
                                                             ~
                                                             [t_auM] " p4.hs:16:61-62] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_auN :: [a_au2]
                                 ~ [t_auM] [" a type equality [a_au2]
                                                              ~
                                                              [t_auM] " p4.hs:16:61-62] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_auN :: [a_au2] ~ [t_auM] [" a type equality [a_au2]
                                                        ~
                                                        [t_auM] " p4.hs:16:61-62] (CNonCanonical)
canEvNC:eq
  [a_au2]
  [t_auM]
can_eq_nc
  [W] cobox_auN :: [a_au2] ~ [t_auM]
  [a_au2]
  [a_au2]
  [t_auM]
  [t_auM]
newWantedEvVar/cache miss [W] cobox_ayf :: a_au2 ~ t_auM
setEvBind
  ev = cobox_auN
  tm  = CO [cobox_ayf]_N
canEvNC:eq
  a_au2
  t_auM
can_eq_nc
  [W] cobox_ayf :: a_au2 ~ t_auM
  a_au2
  a_au2
  t_auM
  t_auM
canEqTyVar
  a_au2
  t_auM
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayf :: a_au2
                                 ~ t_auM [" a type equality [a_au2]
                                                            ~
                                                            [t_auM] " p4.hs:16:61-62] (CTyEqCan)
Sneaky unification:
  Unifies: t_auM := a_au2
  Coercion: t_auM ~ a_au2
  Left Kind is: *
  Right Kind is: *
setWantedTyBind t_auM := a_au2
setEvBind
  ev = cobox_ayf
  tm  = CO <a_au2>_N
kickOutRewritable
  tv =  t_auM
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
9[<C:0,F:0>] [W] cobox_ayf :: a_au2 ~ t_auM: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_auO :: FlatVector
                                ~ FlatVector [" a type equality FlatVector
                                                                ~
                                                                FlatVector " p4.hs:16:23-56] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_auO :: FlatVector
                                 ~ FlatVector [" a type equality FlatVector
                                                                 ~
                                                                 FlatVector " p4.hs:16:23-56] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_auO :: FlatVector
                   ~ FlatVector [" a type equality FlatVector
                                                   ~
                                                   FlatVector " p4.hs:16:23-56] (CNonCanonical)
canEvNC:eq
  FlatVector
  FlatVector
can_eq_nc
  [W] cobox_auO :: FlatVector ~ FlatVector
  FlatVector
  FlatVector
  FlatVector
  FlatVector
can_eq_nc
  [W] cobox_auO :: FlatVector ~ FlatVector
  UArray Int Double
  FlatVector
  FlatVector
  FlatVector
can_eq_nc
  [W] cobox_auO :: FlatVector ~ FlatVector
  UArray Int Double
  FlatVector
  UArray Int Double
  FlatVector
newWantedEvVar/cache miss [W] cobox_ayg :: Int ~ Int
newWantedEvVar/cache miss [W] cobox_ayh :: Double ~ Double
setEvBind
  ev = cobox_auO
  tm  = CO UArray cobox_ayg cobox_ayh_N
canEvNC:eq
  Int
  Int
can_eq_nc
  [W] cobox_ayg :: Int ~ Int
  Int
  Int
  Int
  Int
setEvBind
  ev = cobox_ayg
  tm  = CO <Int>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ayh :: Double
                                ~ Double [" a type equality FlatVector
                                                            ~
                                                            FlatVector " p4.hs:16:23-56] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ayh :: Double
                                 ~ Double [" a type equality FlatVector
                                                             ~
                                                             FlatVector " p4.hs:16:23-56] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ayh :: Double ~ Double [" a type equality FlatVector
                                                      ~
                                                      FlatVector " p4.hs:16:23-56] (CNonCanonical)
canEvNC:eq
  Double
  Double
can_eq_nc
  [W] cobox_ayh :: Double ~ Double
  Double
  Double
  Double
  Double
setEvBind
  ev = cobox_ayh
  tm  = CO <Double>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_auP :: t_auM ~ Int [" a type equality t_auM
                                                               ~
                                                               Int " p4.hs:16:41] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_auP :: t_auM ~ Int [" a type equality t_auM
                                                                ~
                                                                Int " p4.hs:16:41] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_auP :: t_auM ~ Int [" a type equality t_auM
                                                  ~
                                                  Int " p4.hs:16:41] (CNonCanonical)
canEvNC:eq
  t_auM
  Int
can_eq_nc
  [W] cobox_auP :: t_auM ~ Int
  t_auM
  t_auM
  Int
  Int
canEqTyVar
  t_auM
  Int
  Not-swapped
Following bound tyvar t_auM = a_au2
canEqTyVar2
  t_auM
  Int
  Not-swapped
  a_au2
  <a_au2>_N
can_eq_nc
  [W] cobox_auP :: a_au2 ~ Int
  a_au2
  a_au2
  Int
  Int
canEqTyVar
  a_au2
  Int
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_auP :: a_au2 ~ Int [" a type equality t_auM
                                                                ~
                                                                Int " p4.hs:16:41] (CTyEqCan)
Sneaky unification:
  Unifies: a_au2 := Int
  Coercion: a_au2 ~ Int
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_au2 := Int
setEvBind
  ev = cobox_auP
  tm  = CO <Int>_N
kickOutRewritable
  tv =  a_au2
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
12[<C:0,F:0>] [W] cobox_auP :: a_au2 ~ Int: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_auT :: (Integer -> a_auR)
                                ~ (Integer -> t_auQ) [" a type equality Integer -> a_auR
                                                                        ~
                                                                        Integer
                                                                        -> t_auQ " p4.hs:16:51] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_auT :: (Integer -> a_auR)
                                 ~ (Integer -> t_auQ) [" a type equality Integer -> a_auR
                                                                         ~
                                                                         Integer
                                                                         -> t_auQ " p4.hs:16:51] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_auT :: (Integer -> a_auR)
                   ~ (Integer -> t_auQ) [" a type equality Integer -> a_auR
                                                           ~
                                                           Integer
                                                           -> t_auQ " p4.hs:16:51] (CNonCanonical)
canEvNC:eq
  Integer -> a_auR
  Integer -> t_auQ
can_eq_nc
  [W] cobox_auT :: (Integer -> a_auR) ~ (Integer -> t_auQ)
  Integer -> a_auR
  Integer -> a_auR
  Integer -> t_auQ
  Integer -> t_auQ
newWantedEvVar/cache miss [W] cobox_ayi :: Integer ~ Integer
newWantedEvVar/cache miss [W] cobox_ayj :: a_auR ~ t_auQ
setEvBind
  ev = cobox_auT
  tm  = CO cobox_ayi -> cobox_ayj
canEvNC:eq
  Integer
  Integer
can_eq_nc
  [W] cobox_ayi :: Integer ~ Integer
  Integer
  Integer
  Integer
  Integer
setEvBind
  ev = cobox_ayi
  tm  = CO <Integer>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ayj :: a_auR
                                ~ t_auQ [" a type equality Integer -> a_auR
                                                           ~
                                                           Integer
                                                           -> t_auQ " p4.hs:16:51] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ayj :: a_auR
                                 ~ t_auQ [" a type equality Integer -> a_auR
                                                            ~
                                                            Integer
                                                            -> t_auQ " p4.hs:16:51] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ayj :: a_auR ~ t_auQ [" a type equality Integer -> a_auR
                                                    ~
                                                    Integer -> t_auQ " p4.hs:16:51] (CNonCanonical)
canEvNC:eq
  a_auR
  t_auQ
can_eq_nc
  [W] cobox_ayj :: a_auR ~ t_auQ
  a_auR
  a_auR
  t_auQ
  t_auQ
canEqTyVar
  a_auR
  t_auQ
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayj :: a_auR
                                 ~ t_auQ [" a type equality Integer -> a_auR
                                                            ~
                                                            Integer
                                                            -> t_auQ " p4.hs:16:51] (CTyEqCan)
Sneaky unification:
  Unifies: t_auQ := a_auR
  Coercion: t_auQ ~ a_auR
  Left Kind is: *
  Right Kind is: *
setWantedTyBind t_auQ := a_auR
setEvBind
  ev = cobox_ayj
  tm  = CO <a_auR>_N
kickOutRewritable
  tv =  t_auQ
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
14[<C:0,F:0>] [W] cobox_ayj :: a_auR ~ t_auQ: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_auU :: t_auM
                                ~ t_auQ [" a type equality t_auM
                                                           ~
                                                           t_auQ " p4.hs:16:54] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_auU :: t_auM
                                 ~ t_auQ [" a type equality t_auM
                                                            ~
                                                            t_auQ " p4.hs:16:54] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_auU :: t_auM ~ t_auQ [" a type equality t_auM
                                                    ~
                                                    t_auQ " p4.hs:16:54] (CNonCanonical)
canEvNC:eq
  t_auM
  t_auQ
can_eq_nc
  [W] cobox_auU :: t_auM ~ t_auQ
  t_auM
  t_auM
  t_auQ
  t_auQ
canEqTyVar
  t_auM
  t_auQ
  Not-swapped
Following bound tyvar t_auM = a_au2
canEqTyVar2
  t_auM
  t_auQ
  Not-swapped
  a_au2
  <a_au2>_N
can_eq_nc
  [W] cobox_auU :: a_au2 ~ t_auQ
  a_au2
  a_au2
  t_auQ
  t_auQ
canEqTyVar
  a_au2
  t_auQ
  Not-swapped
Following bound tyvar a_au2 = Int
canEqTyVar2
  a_au2
  t_auQ
  Not-swapped
  Int
  <Int>_N
can_eq_nc
  [W] cobox_auU :: Int ~ t_auQ
  Int
  Int
  t_auQ
  t_auQ
canEqTyVar
  t_auQ
  Int
  Is-swapped
Following bound tyvar t_auQ = a_auR
newWantedEvVar/cache miss [W] cobox_ayk :: a_auR ~ Int
setEvBind
  ev = cobox_auU
  tm  = CO Sym cobox_ayk
rewriteEqEvidence
  [W] cobox_auU :: Int ~ t_auQ
  a_auR
  Int
  Sym cobox_ayk
canEqTyVar2
  t_auQ
  Int
  Is-swapped
  a_auR
  <a_auR>_N
can_eq_nc
  [W] cobox_ayk :: a_auR ~ Int
  a_auR
  a_auR
  Int
  Int
canEqTyVar
  a_auR
  Int
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayk :: a_auR ~ Int [" a type equality t_auM
                                                                ~
                                                                t_auQ " p4.hs:16:54] (CTyEqCan)
Sneaky unification:
  Unifies: a_auR := Int
  Coercion: a_auR ~ Int
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_auR := Int
setEvBind
  ev = cobox_ayk
  tm  = CO <Int>_N
kickOutRewritable
  tv =  a_auR
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
15[<C:0,F:0>] [W] cobox_ayk :: a_auR ~ Int: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_awU :: Vector a_awT
                                ~ Vector FlatVector [" a type equality Vector a_awT
                                                                       ~
                                                                       Vector
                                                                         FlatVector " p4.hs:18:21-43] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_awU :: Vector a_awT
                                 ~ Vector FlatVector [" a type equality Vector a_awT
                                                                        ~
                                                                        Vector
                                                                          FlatVector " p4.hs:18:21-43] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_awU :: Vector a_awT
                   ~ Vector FlatVector [" a type equality Vector a_awT
                                                          ~
                                                          Vector
                                                            FlatVector " p4.hs:18:21-43] (CNonCanonical)
canEvNC:eq
  Vector a_awT
  Vector FlatVector
can_eq_nc
  [W] cobox_awU :: Vector a_awT ~ Vector FlatVector
  Vector a_awT
  Vector a_awT
  Vector FlatVector
  Vector FlatVector
can_eq_nc
  [W] cobox_awU :: Vector a_awT ~ Vector FlatVector
  Array Int a_awT
  Vector a_awT
  Vector FlatVector
  Vector FlatVector
can_eq_nc
  [W] cobox_awU :: Vector a_awT ~ Vector FlatVector
  Array Int a_awT
  Vector a_awT
  Array Int FlatVector
  Vector FlatVector
newWantedEvVar/cache miss [W] cobox_ayl :: Int ~ Int
newWantedEvVar/cache miss [W] cobox_aym :: a_awT ~ FlatVector
setEvBind
  ev = cobox_awU
  tm  = CO Array cobox_ayl cobox_aym_N
canEvNC:eq
  Int
  Int
can_eq_nc
  [W] cobox_ayl :: Int ~ Int
  Int
  Int
  Int
  Int
setEvBind
  ev = cobox_ayl
  tm  = CO <Int>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_aym :: a_awT
                                ~ FlatVector [" a type equality Vector a_awT
                                                                ~
                                                                Vector
                                                                  FlatVector " p4.hs:18:21-43] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_aym :: a_awT
                                 ~ FlatVector [" a type equality Vector a_awT
                                                                 ~
                                                                 Vector
                                                                   FlatVector " p4.hs:18:21-43] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_aym :: a_awT ~ FlatVector [" a type equality Vector a_awT
                                                         ~
                                                         Vector
                                                           FlatVector " p4.hs:18:21-43] (CNonCanonical)
canEvNC:eq
  a_awT
  FlatVector
can_eq_nc
  [W] cobox_aym :: a_awT ~ FlatVector
  a_awT
  a_awT
  FlatVector
  FlatVector
can_eq_nc
  [W] cobox_aym :: a_awT ~ FlatVector
  a_awT
  a_awT
  UArray Int Double
  FlatVector
canEqTyVar
  a_awT
  UArray Int Double
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_aym :: a_awT
                                 ~ FlatVector [" a type equality Vector a_awT
                                                                 ~
                                                                 Vector
                                                                   FlatVector " p4.hs:18:21-43] (CTyEqCan)
Sneaky unification:
  Unifies: a_awT := FlatVector
  Coercion: a_awT ~ FlatVector
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_awT := FlatVector
setEvBind
  ev = cobox_aym
  tm  = CO <FlatVector>_N
kickOutRewritable
  tv =  a_awT
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
17[<C:0,F:0>] [W] cobox_aym :: a_awT
                               ~ FlatVector: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_awV :: t_auG ~ Int [" a type equality t_auG
                                                               ~
                                                               Int " p4.hs:18:35-37] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_awV :: t_auG ~ Int [" a type equality t_auG
                                                                ~
                                                                Int " p4.hs:18:35-37] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_awV :: t_auG ~ Int [" a type equality t_auG
                                                  ~
                                                  Int " p4.hs:18:35-37] (CNonCanonical)
canEvNC:eq
  t_auG
  Int
can_eq_nc
  [W] cobox_awV :: t_auG ~ Int
  t_auG
  t_auG
  Int
  Int
canEqTyVar
  t_auG
  Int
  Not-swapped
Following bound tyvar t_auG = Int
canEqTyVar2
  t_auG
  Int
  Not-swapped
  Int
  <Int>_N
can_eq_nc
  [W] cobox_awV :: Int ~ Int
  Int
  Int
  Int
  Int
setEvBind
  ev = cobox_awV
  tm  = CO <Int>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_awW :: [FlatVector]
                                ~ [a_awT] [" a type equality [FlatVector]
                                                             ~
                                                             [a_awT] " p4.hs:18:40-43] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_awW :: [FlatVector]
                                 ~ [a_awT] [" a type equality [FlatVector]
                                                              ~
                                                              [a_awT] " p4.hs:18:40-43] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_awW :: [FlatVector]
                   ~ [a_awT] [" a type equality [FlatVector]
                                                ~
                                                [a_awT] " p4.hs:18:40-43] (CNonCanonical)
canEvNC:eq
  [FlatVector]
  [a_awT]
can_eq_nc
  [W] cobox_awW :: [FlatVector] ~ [a_awT]
  [FlatVector]
  [FlatVector]
  [a_awT]
  [a_awT]
newWantedEvVar/cache miss [W] cobox_ayn :: FlatVector ~ a_awT
setEvBind
  ev = cobox_awW
  tm  = CO [cobox_ayn]_N
canEvNC:eq
  FlatVector
  a_awT
can_eq_nc
  [W] cobox_ayn :: FlatVector ~ a_awT
  FlatVector
  FlatVector
  a_awT
  a_awT
can_eq_nc
  [W] cobox_ayn :: FlatVector ~ a_awT
  UArray Int Double
  FlatVector
  a_awT
  a_awT
canEqTyVar
  a_awT
  UArray Int Double
  Is-swapped
Following bound tyvar a_awT = FlatVector
newWantedEvVar/cache miss [W] cobox_ayo :: FlatVector ~ FlatVector
setEvBind
  ev = cobox_ayn
  tm  = CO Sym cobox_ayo
rewriteEqEvidence
  [W] cobox_ayn :: FlatVector ~ a_awT
  FlatVector
  FlatVector
  Sym cobox_ayo
canEqTyVar2
  a_awT
  UArray Int Double
  Is-swapped
  FlatVector
  <FlatVector>_N
can_eq_nc
  [W] cobox_ayo :: FlatVector ~ FlatVector
  FlatVector
  FlatVector
  UArray Int Double
  FlatVector
can_eq_nc
  [W] cobox_ayo :: FlatVector ~ FlatVector
  UArray Int Double
  FlatVector
  UArray Int Double
  FlatVector
newWantedEvVar/cache miss [W] cobox_ayp :: Int ~ Int
newWantedEvVar/cache miss [W] cobox_ayq :: Double ~ Double
setEvBind
  ev = cobox_ayo
  tm  = CO UArray cobox_ayp cobox_ayq_N
canEvNC:eq
  Int
  Int
can_eq_nc
  [W] cobox_ayp :: Int ~ Int
  Int
  Int
  Int
  Int
setEvBind
  ev = cobox_ayp
  tm  = CO <Int>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ayq :: Double
                                ~ Double [" a type equality [FlatVector]
                                                            ~
                                                            [a_awT] " p4.hs:18:40-43] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ayq :: Double
                                 ~ Double [" a type equality [FlatVector]
                                                             ~
                                                             [a_awT] " p4.hs:18:40-43] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ayq :: Double ~ Double [" a type equality [FlatVector]
                                                      ~
                                                      [a_awT] " p4.hs:18:40-43] (CNonCanonical)
canEvNC:eq
  Double
  Double
can_eq_nc
  [W] cobox_ayq :: Double ~ Double
  Double
  Double
  Double
  Double
setEvBind
  ev = cobox_ayq
  tm  = CO <Double>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ax7 :: (m_ax2 a_ax4
                                 -> (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5)
                                ~ (t_awX
                                   -> (t_awY -> t_awZ) -> IO ()) [" a type equality m_ax2 a_ax4
                                                                                    -> (a_ax4
                                                                                        -> m_ax2 b_ax5)
                                                                                    -> m_ax2 b_ax5
                                                                                    ~
                                                                                    t_awX
                                                                                    -> (t_awY
                                                                                        -> t_awZ)
                                                                                    -> IO
                                                                                         () " p4.hs:19:11-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ax7 :: (m_ax2 a_ax4
                                  -> (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5)
                                 ~ (t_awX
                                    -> (t_awY -> t_awZ) -> IO ()) [" a type equality m_ax2 a_ax4
                                                                                     -> (a_ax4
                                                                                         -> m_ax2 b_ax5)
                                                                                     -> m_ax2 b_ax5
                                                                                     ~
                                                                                     t_awX
                                                                                     -> (t_awY
                                                                                         -> t_awZ)
                                                                                     -> IO
                                                                                          () " p4.hs:19:11-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ax7 :: (m_ax2 a_ax4
                    -> (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5)
                   ~ (t_awX
                      -> (t_awY -> t_awZ) -> IO ()) [" a type equality m_ax2 a_ax4
                                                                       -> (a_ax4 -> m_ax2 b_ax5)
                                                                       -> m_ax2 b_ax5
                                                                       ~
                                                                       t_awX
                                                                       -> (t_awY -> t_awZ)
                                                                       -> IO
                                                                            () " p4.hs:19:11-23] (CNonCanonical)
canEvNC:eq
  m_ax2 a_ax4 -> (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5
  t_awX -> (t_awY -> t_awZ) -> IO ()
can_eq_nc
  [W] cobox_ax7 :: (m_ax2 a_ax4
                    -> (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5)
                   ~ (t_awX -> (t_awY -> t_awZ) -> IO ())
  m_ax2 a_ax4 -> (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5
  m_ax2 a_ax4 -> (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5
  t_awX -> (t_awY -> t_awZ) -> IO ()
  t_awX -> (t_awY -> t_awZ) -> IO ()
newWantedEvVar/cache miss [W] cobox_ayr :: m_ax2 a_ax4 ~ t_awX
newWantedEvVar/cache miss
  [W] cobox_ays :: ((a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5)
                   ~ ((t_awY -> t_awZ) -> IO ())
setEvBind
  ev = cobox_ax7
  tm  = CO cobox_ayr -> cobox_ays
canEvNC:eq
  m_ax2 a_ax4
  t_awX
can_eq_nc
  [W] cobox_ayr :: m_ax2 a_ax4 ~ t_awX
  m_ax2 a_ax4
  m_ax2 a_ax4
  t_awX
  t_awX
canEqTyVar
  t_awX
  m_ax2 a_ax4
  Is-swapped
flatten/appty
  m_ax2
  a_ax4
  m_ax2
  <m_ax2>_N
  a_ax4
  <a_ax4>_N
newWantedEvVar/cache miss [W] cobox_ayt :: t_awX ~ m_ax2 a_ax4
setEvBind
  ev = cobox_ayr
  tm  = CO Sym cobox_ayt
rewriteEqEvidence
  [W] cobox_ayr :: m_ax2 a_ax4 ~ t_awX
  t_awX
  m_ax2 a_ax4
  Sym cobox_ayt
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayt :: t_awX
                                 ~ m_ax2 a_ax4 [" a type equality m_ax2 a_ax4
                                                                  -> (a_ax4 -> m_ax2 b_ax5)
                                                                  -> m_ax2 b_ax5
                                                                  ~
                                                                  t_awX
                                                                  -> (t_awY -> t_awZ)
                                                                  -> IO
                                                                       () " p4.hs:19:11-23] (CTyEqCan)
Sneaky unification:
  Unifies: t_awX := m_ax2 a_ax4
  Coercion: t_awX ~ m_ax2 a_ax4
  Left Kind is: *
  Right Kind is: *
setWantedTyBind t_awX := m_ax2 a_ax4
setEvBind
  ev = cobox_ayt
  tm  = CO <m_ax2 a_ax4>_N
kickOutRewritable
  tv =  t_awX
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
21[<C:0,F:0>] [W] cobox_ayt :: t_awX
                               ~ m_ax2 a_ax4: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ays :: ((a_ax4 -> m_ax2 b_ax5)
                                 -> m_ax2 b_ax5)
                                ~ ((t_awY -> t_awZ) -> IO ()) [" a type equality m_ax2 a_ax4
                                                                                 -> (a_ax4
                                                                                     -> m_ax2 b_ax5)
                                                                                 -> m_ax2 b_ax5
                                                                                 ~
                                                                                 t_awX
                                                                                 -> (t_awY -> t_awZ)
                                                                                 -> IO
                                                                                      () " p4.hs:19:11-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ays :: ((a_ax4 -> m_ax2 b_ax5)
                                  -> m_ax2 b_ax5)
                                 ~ ((t_awY -> t_awZ) -> IO ()) [" a type equality m_ax2 a_ax4
                                                                                  -> (a_ax4
                                                                                      -> m_ax2 b_ax5)
                                                                                  -> m_ax2 b_ax5
                                                                                  ~
                                                                                  t_awX
                                                                                  -> (t_awY
                                                                                      -> t_awZ)
                                                                                  -> IO
                                                                                       () " p4.hs:19:11-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ays :: ((a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5)
                   ~ ((t_awY -> t_awZ) -> IO ()) [" a type equality m_ax2 a_ax4
                                                                    -> (a_ax4 -> m_ax2 b_ax5)
                                                                    -> m_ax2 b_ax5
                                                                    ~
                                                                    t_awX
                                                                    -> (t_awY -> t_awZ)
                                                                    -> IO
                                                                         () " p4.hs:19:11-23] (CNonCanonical)
canEvNC:eq
  (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5
  (t_awY -> t_awZ) -> IO ()
can_eq_nc
  [W] cobox_ays :: ((a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5)
                   ~ ((t_awY -> t_awZ) -> IO ())
  (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5
  (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5
  (t_awY -> t_awZ) -> IO ()
  (t_awY -> t_awZ) -> IO ()
newWantedEvVar/cache miss
  [W] cobox_ayu :: (a_ax4 -> m_ax2 b_ax5) ~ (t_awY -> t_awZ)
newWantedEvVar/cache miss [W] cobox_ayv :: m_ax2 b_ax5 ~ IO ()
setEvBind
  ev = cobox_ays
  tm  = CO cobox_ayu -> cobox_ayv
canEvNC:eq
  a_ax4 -> m_ax2 b_ax5
  t_awY -> t_awZ
can_eq_nc
  [W] cobox_ayu :: (a_ax4 -> m_ax2 b_ax5) ~ (t_awY -> t_awZ)
  a_ax4 -> m_ax2 b_ax5
  a_ax4 -> m_ax2 b_ax5
  t_awY -> t_awZ
  t_awY -> t_awZ
newWantedEvVar/cache miss [W] cobox_ayw :: a_ax4 ~ t_awY
newWantedEvVar/cache miss [W] cobox_ayx :: m_ax2 b_ax5 ~ t_awZ
setEvBind
  ev = cobox_ayu
  tm  = CO cobox_ayw -> cobox_ayx
canEvNC:eq
  a_ax4
  t_awY
can_eq_nc
  [W] cobox_ayw :: a_ax4 ~ t_awY
  a_ax4
  a_ax4
  t_awY
  t_awY
canEqTyVar
  a_ax4
  t_awY
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayw :: a_ax4
                                 ~ t_awY [" a type equality m_ax2 a_ax4
                                                            -> (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5
                                                            ~
                                                            t_awX
                                                            -> (t_awY -> t_awZ)
                                                            -> IO () " p4.hs:19:11-23] (CTyEqCan)
Sneaky unification:
  Unifies: t_awY := a_ax4
  Coercion: t_awY ~ a_ax4
  Left Kind is: *
  Right Kind is: *
setWantedTyBind t_awY := a_ax4
setEvBind
  ev = cobox_ayw
  tm  = CO <a_ax4>_N
kickOutRewritable
  tv =  t_awY
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
22[<C:0,F:0>] [W] cobox_ayw :: a_ax4 ~ t_awY: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ayx :: m_ax2 b_ax5
                                ~ t_awZ [" a type equality m_ax2 a_ax4
                                                           -> (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5
                                                           ~
                                                           t_awX
                                                           -> (t_awY -> t_awZ)
                                                           -> IO
                                                                () " p4.hs:19:11-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ayx :: m_ax2 b_ax5
                                 ~ t_awZ [" a type equality m_ax2 a_ax4
                                                            -> (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5
                                                            ~
                                                            t_awX
                                                            -> (t_awY -> t_awZ)
                                                            -> IO
                                                                 () " p4.hs:19:11-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ayx :: m_ax2 b_ax5 ~ t_awZ [" a type equality m_ax2 a_ax4
                                                          -> (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5
                                                          ~
                                                          t_awX
                                                          -> (t_awY -> t_awZ)
                                                          -> IO () " p4.hs:19:11-23] (CNonCanonical)
canEvNC:eq
  m_ax2 b_ax5
  t_awZ
can_eq_nc
  [W] cobox_ayx :: m_ax2 b_ax5 ~ t_awZ
  m_ax2 b_ax5
  m_ax2 b_ax5
  t_awZ
  t_awZ
canEqTyVar
  t_awZ
  m_ax2 b_ax5
  Is-swapped
flatten/appty
  m_ax2
  b_ax5
  m_ax2
  <m_ax2>_N
  b_ax5
  <b_ax5>_N
newWantedEvVar/cache miss [W] cobox_ayy :: t_awZ ~ m_ax2 b_ax5
setEvBind
  ev = cobox_ayx
  tm  = CO Sym cobox_ayy
rewriteEqEvidence
  [W] cobox_ayx :: m_ax2 b_ax5 ~ t_awZ
  t_awZ
  m_ax2 b_ax5
  Sym cobox_ayy
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayy :: t_awZ
                                 ~ m_ax2 b_ax5 [" a type equality m_ax2 a_ax4
                                                                  -> (a_ax4 -> m_ax2 b_ax5)
                                                                  -> m_ax2 b_ax5
                                                                  ~
                                                                  t_awX
                                                                  -> (t_awY -> t_awZ)
                                                                  -> IO
                                                                       () " p4.hs:19:11-23] (CTyEqCan)
Sneaky unification:
  Unifies: t_awZ := m_ax2 b_ax5
  Coercion: t_awZ ~ m_ax2 b_ax5
  Left Kind is: *
  Right Kind is: *
setWantedTyBind t_awZ := m_ax2 b_ax5
setEvBind
  ev = cobox_ayy
  tm  = CO <m_ax2 b_ax5>_N
kickOutRewritable
  tv =  t_awZ
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
23[<C:0,F:0>] [W] cobox_ayy :: t_awZ
                               ~ m_ax2 b_ax5: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ayv :: m_ax2 b_ax5
                                ~ IO () [" a type equality m_ax2 a_ax4
                                                           -> (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5
                                                           ~
                                                           t_awX
                                                           -> (t_awY -> t_awZ)
                                                           -> IO
                                                                () " p4.hs:19:11-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ayv :: m_ax2 b_ax5
                                 ~ IO () [" a type equality m_ax2 a_ax4
                                                            -> (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5
                                                            ~
                                                            t_awX
                                                            -> (t_awY -> t_awZ)
                                                            -> IO
                                                                 () " p4.hs:19:11-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ayv :: m_ax2 b_ax5 ~ IO () [" a type equality m_ax2 a_ax4
                                                          -> (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5
                                                          ~
                                                          t_awX
                                                          -> (t_awY -> t_awZ)
                                                          -> IO () " p4.hs:19:11-23] (CNonCanonical)
canEvNC:eq
  m_ax2 b_ax5
  IO ()
can_eq_nc
  [W] cobox_ayv :: m_ax2 b_ax5 ~ IO ()
  m_ax2 b_ax5
  m_ax2 b_ax5
  IO ()
  IO ()
can_eq_app 1
  [W] cobox_ayv :: m_ax2 b_ax5 ~ IO ()
  Not-swapped
  m_ax2
  b_ax5
  IO ()
can_eq_app 2
  [W] cobox_ayv :: m_ax2 b_ax5 ~ IO ()
  m_ax2
newWantedEvVar/cache miss [W] cobox_ayz :: m_ax2 ~ IO
newWantedEvVar/cache miss [W] cobox_ayA :: b_ax5 ~ ()
setEvBind
  ev = cobox_ayv
  tm  = CO cobox_ayz cobox_ayA
canEvNC:eq
  m_ax2
  IO
can_eq_nc
  [W] cobox_ayz :: m_ax2 ~ IO
  m_ax2
  m_ax2
  IO
  IO
canEqTyVar
  m_ax2
  IO
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayz :: m_ax2
                                 ~ IO [" a type equality m_ax2 a_ax4
                                                         -> (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5
                                                         ~
                                                         t_awX
                                                         -> (t_awY -> t_awZ)
                                                         -> IO () " p4.hs:19:11-23] (CTyEqCan)
Sneaky unification:
  Unifies: m_ax2 := IO
  Coercion: m_ax2 ~ IO
  Left Kind is: * -> *
  Right Kind is: * -> *
setWantedTyBind m_ax2 := IO
setEvBind
  ev = cobox_ayz
  tm  = CO <IO>_N
kickOutRewritable
  tv =  m_ax2
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
24[<C:0,F:0>] [W] cobox_ayz :: m_ax2 ~ IO: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ayA :: b_ax5
                                ~ () [" a type equality m_ax2 a_ax4
                                                        -> (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5
                                                        ~
                                                        t_awX
                                                        -> (t_awY -> t_awZ)
                                                        -> IO () " p4.hs:19:11-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ayA :: b_ax5
                                 ~ () [" a type equality m_ax2 a_ax4
                                                         -> (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5
                                                         ~
                                                         t_awX
                                                         -> (t_awY -> t_awZ)
                                                         -> IO () " p4.hs:19:11-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ayA :: b_ax5 ~ () [" a type equality m_ax2 a_ax4
                                                 -> (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5
                                                 ~
                                                 t_awX
                                                 -> (t_awY -> t_awZ)
                                                 -> IO () " p4.hs:19:11-23] (CNonCanonical)
canEvNC:eq
  b_ax5
  ()
can_eq_nc
  [W] cobox_ayA :: b_ax5 ~ ()
  b_ax5
  b_ax5
  ()
  ()
canEqTyVar
  b_ax5
  ()
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayA :: b_ax5
                                 ~ () [" a type equality m_ax2 a_ax4
                                                         -> (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5
                                                         ~
                                                         t_awX
                                                         -> (t_awY -> t_awZ)
                                                         -> IO () " p4.hs:19:11-23] (CTyEqCan)
Sneaky unification:
  Unifies: b_ax5 := ()
  Coercion: b_ax5 ~ ()
  Left Kind is: *
  Right Kind is: *
setWantedTyBind b_ax5 := ()
setEvBind
  ev = cobox_ayA
  tm  = CO <()>_N
kickOutRewritable
  tv =  b_ax5
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
25[<C:0,F:0>] [W] cobox_ayA :: b_ax5 ~ (): Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_axz :: m_axu (b_axv i_axs e_axt)
                                ~ t_awX [" a type equality m_axu (b_axv i_axs e_axt)
                                                           ~
                                                           t_awX " p4.hs:19:16-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_axz :: m_axu (b_axv i_axs e_axt)
                                 ~ t_awX [" a type equality m_axu (b_axv i_axs e_axt)
                                                            ~
                                                            t_awX " p4.hs:19:16-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_axz :: m_axu (b_axv i_axs e_axt)
                   ~ t_awX [" a type equality m_axu (b_axv i_axs e_axt)
                                              ~
                                              t_awX " p4.hs:19:16-23] (CNonCanonical)
canEvNC:eq
  m_axu (b_axv i_axs e_axt)
  t_awX
can_eq_nc
  [W] cobox_axz :: m_axu (b_axv i_axs e_axt) ~ t_awX
  m_axu (b_axv i_axs e_axt)
  m_axu (b_axv i_axs e_axt)
  t_awX
  t_awX
canEqTyVar
  t_awX
  m_axu (b_axv i_axs e_axt)
  Is-swapped
Following bound tyvar t_awX = m_ax2 a_ax4
newWantedEvVar/cache miss
  [W] cobox_ayB :: m_ax2 a_ax4 ~ m_axu (b_axv i_axs e_axt)
setEvBind
  ev = cobox_axz
  tm  = CO Sym cobox_ayB
rewriteEqEvidence
  [W] cobox_axz :: m_axu (b_axv i_axs e_axt) ~ t_awX
  m_ax2 a_ax4
  m_axu (b_axv i_axs e_axt)
  Sym cobox_ayB
canEqTyVar2
  t_awX
  m_axu (b_axv i_axs e_axt)
  Is-swapped
  m_ax2 a_ax4
  <m_ax2 a_ax4>_N
can_eq_nc
  [W] cobox_ayB :: m_ax2 a_ax4 ~ m_axu (b_axv i_axs e_axt)
  m_ax2 a_ax4
  m_ax2 a_ax4
  m_axu (b_axv i_axs e_axt)
  m_axu (b_axv i_axs e_axt)
can_eq_app 1
  [W] cobox_ayB :: m_ax2 a_ax4 ~ m_axu (b_axv i_axs e_axt)
  Not-swapped
  m_ax2
  a_ax4
  m_axu (b_axv i_axs e_axt)
Following bound tyvar m_ax2 = IO
can_eq_app 2
  [W] cobox_ayB :: m_ax2 a_ax4 ~ m_axu (b_axv i_axs e_axt)
  IO
can_eq_app 3
  [W] cobox_ayB :: m_ax2 a_ax4 ~ m_axu (b_axv i_axs e_axt)
  IO a_ax4
  <IO a_ax4>_N
can_eq_app 4
  [W] cobox_ayB :: m_ax2 a_ax4 ~ m_axu (b_axv i_axs e_axt)
  IO a_ax4
  <IO a_ax4>_N
can_eq_nc
  [W] cobox_ayB :: IO a_ax4 ~ m_axu (b_axv i_axs e_axt)
  IO a_ax4
  IO a_ax4
  m_axu (b_axv i_axs e_axt)
  m_axu (b_axv i_axs e_axt)
can_eq_app 1
  [W] cobox_ayB :: IO a_ax4 ~ m_axu (b_axv i_axs e_axt)
  Is-swapped
  m_axu
  b_axv i_axs e_axt
  IO a_ax4
can_eq_app 2
  [W] cobox_ayB :: IO a_ax4 ~ m_axu (b_axv i_axs e_axt)
  m_axu
newWantedEvVar/cache miss [W] cobox_ayC :: IO ~ m_axu
newWantedEvVar/cache miss
  [W] cobox_ayD :: a_ax4 ~ b_axv i_axs e_axt
setEvBind
  ev = cobox_ayB
  tm  = CO cobox_ayC cobox_ayD
canEvNC:eq
  IO
  m_axu
can_eq_nc
  [W] cobox_ayC :: IO ~ m_axu
  IO
  IO
  m_axu
  m_axu
canEqTyVar
  m_axu
  IO
  Is-swapped
newWantedEvVar/cache miss [W] cobox_ayE :: m_axu ~ IO
setEvBind
  ev = cobox_ayC
  tm  = CO Sym cobox_ayE
rewriteEqEvidence
  [W] cobox_ayC :: IO ~ m_axu
  m_axu
  IO
  Sym cobox_ayE
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayE :: m_axu
                                 ~ IO [" a type equality m_axu (b_axv i_axs e_axt)
                                                         ~
                                                         t_awX " p4.hs:19:16-23] (CTyEqCan)
Sneaky unification:
  Unifies: m_axu := IO
  Coercion: m_axu ~ IO
  Left Kind is: * -> *
  Right Kind is: * -> *
setWantedTyBind m_axu := IO
setEvBind
  ev = cobox_ayE
  tm  = CO <IO>_N
kickOutRewritable
  tv =  m_axu
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
26[<C:0,F:0>] [W] cobox_ayE :: m_axu ~ IO: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ayD :: a_ax4
                                ~ b_axv i_axs e_axt [" a type equality m_axu (b_axv i_axs e_axt)
                                                                       ~
                                                                       t_awX " p4.hs:19:16-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ayD :: a_ax4
                                 ~ b_axv i_axs e_axt [" a type equality m_axu (b_axv i_axs e_axt)
                                                                        ~
                                                                        t_awX " p4.hs:19:16-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ayD :: a_ax4
                   ~ b_axv i_axs e_axt [" a type equality m_axu (b_axv i_axs e_axt)
                                                          ~
                                                          t_awX " p4.hs:19:16-23] (CNonCanonical)
canEvNC:eq
  a_ax4
  b_axv i_axs e_axt
can_eq_nc
  [W] cobox_ayD :: a_ax4 ~ b_axv i_axs e_axt
  a_ax4
  a_ax4
  b_axv i_axs e_axt
  b_axv i_axs e_axt
canEqTyVar
  a_ax4
  b_axv i_axs e_axt
  Not-swapped
flatten/appty
  b_axv
  i_axs
  b_axv
  <b_axv>_N
  i_axs
  <i_axs>_N
flatten/appty
  b_axv i_axs
  e_axt
  b_axv i_axs
  <b_axv i_axs>_N
  e_axt
  <e_axt>_N
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayD :: a_ax4
                                 ~ b_axv i_axs e_axt [" a type equality m_axu (b_axv i_axs e_axt)
                                                                        ~
                                                                        t_awX " p4.hs:19:16-23] (CTyEqCan)
Sneaky unification:
  Unifies: a_ax4 := b_axv i_axs e_axt
  Coercion: a_ax4 ~ b_axv i_axs e_axt
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_ax4 := b_axv i_axs e_axt
setEvBind
  ev = cobox_ayD
  tm  = CO <b_axv i_axs e_axt>_N
kickOutRewritable
  tv =  a_ax4
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
27[<C:0,F:0>] [W] cobox_ayD :: a_ax4
                               ~ b_axv i_axs e_axt: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_axA :: Vector FlatVector
                                ~ a_axr i_axs e_axt [" a type equality Vector FlatVector
                                                                       ~
                                                                       a_axr i_axs e_axt " p4.hs:19:21-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_axA :: Vector FlatVector
                                 ~ a_axr i_axs e_axt [" a type equality Vector FlatVector
                                                                        ~
                                                                        a_axr i_axs e_axt " p4.hs:19:21-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_axA :: Vector FlatVector
                   ~ a_axr i_axs e_axt [" a type equality Vector FlatVector
                                                          ~
                                                          a_axr i_axs e_axt " p4.hs:19:21-23] (CNonCanonical)
canEvNC:eq
  Vector FlatVector
  a_axr i_axs e_axt
can_eq_nc
  [W] cobox_axA :: Vector FlatVector ~ a_axr i_axs e_axt
  Vector FlatVector
  Vector FlatVector
  a_axr i_axs e_axt
  a_axr i_axs e_axt
can_eq_nc
  [W] cobox_axA :: Vector FlatVector ~ a_axr i_axs e_axt
  Array Int FlatVector
  Vector FlatVector
  a_axr i_axs e_axt
  a_axr i_axs e_axt
can_eq_app 1
  [W] cobox_axA :: Vector FlatVector ~ a_axr i_axs e_axt
  Is-swapped
  a_axr i_axs
  e_axt
  Array Int FlatVector
flatten/appty
  a_axr
  i_axs
  a_axr
  <a_axr>_N
  i_axs
  <i_axs>_N
can_eq_app 2
  [W] cobox_axA :: Vector FlatVector ~ a_axr i_axs e_axt
  a_axr i_axs
newWantedEvVar/cache miss [W] cobox_ayF :: Array Int ~ a_axr i_axs
newWantedEvVar/cache miss [W] cobox_ayG :: FlatVector ~ e_axt
setEvBind
  ev = cobox_axA
  tm  = CO cobox_ayF cobox_ayG
canEvNC:eq
  Array Int
  a_axr i_axs
can_eq_nc
  [W] cobox_ayF :: Array Int ~ a_axr i_axs
  Array Int
  Array Int
  a_axr i_axs
  a_axr i_axs
can_eq_app 1
  [W] cobox_ayF :: Array Int ~ a_axr i_axs
  Is-swapped
  a_axr
  i_axs
  Array Int
can_eq_app 2
  [W] cobox_ayF :: Array Int ~ a_axr i_axs
  a_axr
newWantedEvVar/cache miss [W] cobox_ayH :: Array ~ a_axr
newWantedEvVar/cache miss [W] cobox_ayI :: Int ~ i_axs
setEvBind
  ev = cobox_ayF
  tm  = CO cobox_ayH cobox_ayI
canEvNC:eq
  Array
  a_axr
can_eq_nc
  [W] cobox_ayH :: Array ~ a_axr
  Array
  Array
  a_axr
  a_axr
canEqTyVar
  a_axr
  Array
  Is-swapped
newWantedEvVar/cache miss [W] cobox_ayJ :: a_axr ~ Array
setEvBind
  ev = cobox_ayH
  tm  = CO Sym cobox_ayJ
rewriteEqEvidence
  [W] cobox_ayH :: Array ~ a_axr
  a_axr
  Array
  Sym cobox_ayJ
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayJ :: a_axr
                                 ~ Array [" a type equality Vector FlatVector
                                                            ~
                                                            a_axr i_axs e_axt " p4.hs:19:21-23] (CTyEqCan)
Sneaky unification:
  Unifies: a_axr := Array
  Coercion: a_axr ~ Array
  Left Kind is: * -> * -> *
  Right Kind is: * -> * -> *
setWantedTyBind a_axr := Array
setEvBind
  ev = cobox_ayJ
  tm  = CO <Array>_N
kickOutRewritable
  tv =  a_axr
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
28[<C:0,F:0>] [W] cobox_ayJ :: a_axr ~ Array: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ayI :: Int ~ i_axs [" a type equality Vector
                                                                 FlatVector
                                                               ~
                                                               a_axr i_axs e_axt " p4.hs:19:21-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ayI :: Int
                                 ~ i_axs [" a type equality Vector FlatVector
                                                            ~
                                                            a_axr i_axs e_axt " p4.hs:19:21-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ayI :: Int ~ i_axs [" a type equality Vector FlatVector
                                                  ~
                                                  a_axr i_axs e_axt " p4.hs:19:21-23] (CNonCanonical)
canEvNC:eq
  Int
  i_axs
can_eq_nc
  [W] cobox_ayI :: Int ~ i_axs
  Int
  Int
  i_axs
  i_axs
canEqTyVar
  i_axs
  Int
  Is-swapped
newWantedEvVar/cache miss [W] cobox_ayK :: i_axs ~ Int
setEvBind
  ev = cobox_ayI
  tm  = CO Sym cobox_ayK
rewriteEqEvidence
  [W] cobox_ayI :: Int ~ i_axs
  i_axs
  Int
  Sym cobox_ayK
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayK :: i_axs
                                 ~ Int [" a type equality Vector FlatVector
                                                          ~
                                                          a_axr i_axs e_axt " p4.hs:19:21-23] (CTyEqCan)
Sneaky unification:
  Unifies: i_axs := Int
  Coercion: i_axs ~ Int
  Left Kind is: *
  Right Kind is: *
setWantedTyBind i_axs := Int
setEvBind
  ev = cobox_ayK
  tm  = CO <Int>_N
kickOutRewritable
  tv =  i_axs
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
29[<C:0,F:0>] [W] cobox_ayK :: i_axs ~ Int: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ayG :: FlatVector
                                ~ e_axt [" a type equality Vector FlatVector
                                                           ~
                                                           a_axr i_axs e_axt " p4.hs:19:21-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ayG :: FlatVector
                                 ~ e_axt [" a type equality Vector FlatVector
                                                            ~
                                                            a_axr i_axs e_axt " p4.hs:19:21-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ayG :: FlatVector ~ e_axt [" a type equality Vector
                                                           FlatVector
                                                         ~
                                                         a_axr i_axs e_axt " p4.hs:19:21-23] (CNonCanonical)
canEvNC:eq
  FlatVector
  e_axt
can_eq_nc
  [W] cobox_ayG :: FlatVector ~ e_axt
  FlatVector
  FlatVector
  e_axt
  e_axt
can_eq_nc
  [W] cobox_ayG :: FlatVector ~ e_axt
  UArray Int Double
  FlatVector
  e_axt
  e_axt
canEqTyVar
  e_axt
  UArray Int Double
  Is-swapped
newWantedEvVar/cache miss [W] cobox_ayL :: e_axt ~ FlatVector
setEvBind
  ev = cobox_ayG
  tm  = CO Sym cobox_ayL
rewriteEqEvidence
  [W] cobox_ayG :: FlatVector ~ e_axt
  e_axt
  FlatVector
  Sym cobox_ayL
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayL :: e_axt
                                 ~ FlatVector [" a type equality Vector FlatVector
                                                                 ~
                                                                 a_axr i_axs e_axt " p4.hs:19:21-23] (CTyEqCan)
Sneaky unification:
  Unifies: e_axt := FlatVector
  Coercion: e_axt ~ FlatVector
  Left Kind is: *
  Right Kind is: *
setWantedTyBind e_axt := FlatVector
setEvBind
  ev = cobox_ayL
  tm  = CO <FlatVector>_N
kickOutRewritable
  tv =  e_axt
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
30[<C:0,F:0>] [W] cobox_ayL :: e_axt
                               ~ FlatVector: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_axG :: m_axC a_axE
                                ~ t_awZ [" a type equality m_axC a_axE
                                                           ~
                                                           t_awZ " p4.hs:20:11-19] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_axG :: m_axC a_axE
                                 ~ t_awZ [" a type equality m_axC a_axE
                                                            ~
                                                            t_awZ " p4.hs:20:11-19] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_axG :: m_axC a_axE ~ t_awZ [" a type equality m_axC a_axE
                                                          ~
                                                          t_awZ " p4.hs:20:11-19] (CNonCanonical)
canEvNC:eq
  m_axC a_axE
  t_awZ
can_eq_nc
  [W] cobox_axG :: m_axC a_axE ~ t_awZ
  m_axC a_axE
  m_axC a_axE
  t_awZ
  t_awZ
canEqTyVar
  t_awZ
  m_axC a_axE
  Is-swapped
Following bound tyvar t_awZ = m_ax2 b_ax5
newWantedEvVar/cache miss
  [W] cobox_ayM :: m_ax2 b_ax5 ~ m_axC a_axE
setEvBind
  ev = cobox_axG
  tm  = CO Sym cobox_ayM
rewriteEqEvidence
  [W] cobox_axG :: m_axC a_axE ~ t_awZ
  m_ax2 b_ax5
  m_axC a_axE
  Sym cobox_ayM
canEqTyVar2
  t_awZ
  m_axC a_axE
  Is-swapped
  m_ax2 b_ax5
  <m_ax2 b_ax5>_N
can_eq_nc
  [W] cobox_ayM :: m_ax2 b_ax5 ~ m_axC a_axE
  m_ax2 b_ax5
  m_ax2 b_ax5
  m_axC a_axE
  m_axC a_axE
can_eq_app 1
  [W] cobox_ayM :: m_ax2 b_ax5 ~ m_axC a_axE
  Not-swapped
  m_ax2
  b_ax5
  m_axC a_axE
Following bound tyvar m_ax2 = IO
can_eq_app 2
  [W] cobox_ayM :: m_ax2 b_ax5 ~ m_axC a_axE
  IO
Following bound tyvar b_ax5 = ()
can_eq_app 3
  [W] cobox_ayM :: m_ax2 b_ax5 ~ m_axC a_axE
  IO ()
  <IO ()>_N
can_eq_app 4
  [W] cobox_ayM :: m_ax2 b_ax5 ~ m_axC a_axE
  IO ()
  <IO ()>_N
can_eq_nc
  [W] cobox_ayM :: IO () ~ m_axC a_axE
  IO ()
  IO ()
  m_axC a_axE
  m_axC a_axE
can_eq_app 1
  [W] cobox_ayM :: IO () ~ m_axC a_axE
  Is-swapped
  m_axC
  a_axE
  IO ()
can_eq_app 2
  [W] cobox_ayM :: IO () ~ m_axC a_axE
  m_axC
newWantedEvVar/cache miss [W] cobox_ayN :: IO ~ m_axC
newWantedEvVar/cache miss [W] cobox_ayO :: () ~ a_axE
setEvBind
  ev = cobox_ayM
  tm  = CO cobox_ayN cobox_ayO
canEvNC:eq
  IO
  m_axC
can_eq_nc
  [W] cobox_ayN :: IO ~ m_axC
  IO
  IO
  m_axC
  m_axC
canEqTyVar
  m_axC
  IO
  Is-swapped
newWantedEvVar/cache miss [W] cobox_ayP :: m_axC ~ IO
setEvBind
  ev = cobox_ayN
  tm  = CO Sym cobox_ayP
rewriteEqEvidence
  [W] cobox_ayN :: IO ~ m_axC
  m_axC
  IO
  Sym cobox_ayP
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayP :: m_axC
                                 ~ IO [" a type equality m_axC a_axE
                                                         ~
                                                         t_awZ " p4.hs:20:11-19] (CTyEqCan)
Sneaky unification:
  Unifies: m_axC := IO
  Coercion: m_axC ~ IO
  Left Kind is: * -> *
  Right Kind is: * -> *
setWantedTyBind m_axC := IO
setEvBind
  ev = cobox_ayP
  tm  = CO <IO>_N
kickOutRewritable
  tv =  m_axC
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
31[<C:0,F:0>] [W] cobox_ayP :: m_axC ~ IO: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ayO :: ()
                                ~ a_axE [" a type equality m_axC a_axE
                                                           ~
                                                           t_awZ " p4.hs:20:11-19] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ayO :: ()
                                 ~ a_axE [" a type equality m_axC a_axE
                                                            ~
                                                            t_awZ " p4.hs:20:11-19] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ayO :: () ~ a_axE [" a type equality m_axC a_axE
                                                 ~
                                                 t_awZ " p4.hs:20:11-19] (CNonCanonical)
canEvNC:eq
  ()
  a_axE
can_eq_nc
  [W] cobox_ayO :: () ~ a_axE
  ()
  ()
  a_axE
  a_axE
canEqTyVar
  a_axE
  ()
  Is-swapped
newWantedEvVar/cache miss [W] cobox_ayQ :: a_axE ~ ()
setEvBind
  ev = cobox_ayO
  tm  = CO Sym cobox_ayQ
rewriteEqEvidence
  [W] cobox_ayO :: () ~ a_axE
  a_axE
  ()
  Sym cobox_ayQ
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayQ :: a_axE
                                 ~ () [" a type equality m_axC a_axE
                                                         ~
                                                         t_awZ " p4.hs:20:11-19] (CTyEqCan)
Sneaky unification:
  Unifies: a_axE := ()
  Coercion: a_axE ~ ()
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_axE := ()
setEvBind
  ev = cobox_ayQ
  tm  = CO <()>_N
kickOutRewritable
  tv =  a_axE
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
32[<C:0,F:0>] [W] cobox_ayQ :: a_axE ~ (): Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_axH :: () ~ a_axE [" a type equality ()
                                                              ~
                                                              a_axE " p4.hs:20:18-19] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_axH :: () ~ a_axE [" a type equality ()
                                                               ~
                                                               a_axE " p4.hs:20:18-19] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_axH :: () ~ a_axE [" a type equality ()
                                                 ~
                                                 a_axE " p4.hs:20:18-19] (CNonCanonical)
canEvNC:eq
  ()
  a_axE
can_eq_nc
  [W] cobox_axH :: () ~ a_axE
  ()
  ()
  a_axE
  a_axE
canEqTyVar
  a_axE
  ()
  Is-swapped
Following bound tyvar a_axE = ()
newWantedEvVar/cache miss [W] cobox_ayR :: () ~ ()
setEvBind
  ev = cobox_axH
  tm  = CO Sym cobox_ayR
rewriteEqEvidence
  [W] cobox_axH :: () ~ a_axE
  ()
  ()
  Sym cobox_ayR
canEqTyVar2
  a_axE
  ()
  Is-swapped
  ()
  <()>_N
can_eq_nc
  [W] cobox_ayR :: () ~ ()
  ()
  ()
  ()
  ()
setEvBind
  ev = cobox_ayR
  tm  = CO <()>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_axJ :: IO ()
                                ~ IO t_axI [" a type equality IO ()
                                                              ~
                                                              IO t_axI " p4.hs:13:1] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_axJ :: IO ()
                                 ~ IO t_axI [" a type equality IO ()
                                                               ~
                                                               IO
                                                                 t_axI " p4.hs:13:1] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_axJ :: IO () ~ IO t_axI [" a type equality IO ()
                                                       ~
                                                       IO t_axI " p4.hs:13:1] (CNonCanonical)
canEvNC:eq
  IO ()
  IO t_axI
can_eq_nc
  [W] cobox_axJ :: IO () ~ IO t_axI
  IO ()
  IO ()
  IO t_axI
  IO t_axI
newWantedEvVar/cache miss [W] cobox_ayS :: () ~ t_axI
setEvBind
  ev = cobox_axJ
  tm  = CO IO cobox_ayS_N
canEvNC:eq
  ()
  t_axI
can_eq_nc
  [W] cobox_ayS :: () ~ t_axI
  ()
  ()
  t_axI
  t_axI
canEqTyVar
  t_axI
  ()
  Is-swapped
newWantedEvVar/cache miss [W] cobox_ayT :: t_axI ~ ()
setEvBind
  ev = cobox_ayS
  tm  = CO Sym cobox_ayT
rewriteEqEvidence
  [W] cobox_ayS :: () ~ t_axI
  t_axI
  ()
  Sym cobox_ayT
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayT :: t_axI ~ () [" a type equality IO ()
                                                               ~
                                                               IO t_axI " p4.hs:13:1] (CTyEqCan)
Sneaky unification:
  Unifies: t_axI := ()
  Coercion: t_axI ~ ()
  Left Kind is: *
  Right Kind is: *
setWantedTyBind t_axI := ()
setEvBind
  ev = cobox_ayT
  tm  = CO <()>_N
kickOutRewritable
  tv =  t_axI
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
34[<C:0,F:0>] [W] cobox_ayT :: t_axI ~ (): Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dIArray_ar9 :: Data.Array.Base.IArray
                                     a_ar8
                                     e_ar7 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dIArray_ar9 :: Data.Array.Base.IArray
                                      a_ar8
                                      e_ar7 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dIArray_ar9 :: Data.Array.Base.IArray
                        a_ar8
                        e_ar7 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
canEvNC:cls Data.Array.Base.IArray [a_ar8, e_ar7]
Following bound tyvar a_ar8 = UArray
Following bound tyvar e_ar7 = Double
canClass
  [W] $dIArray_ar9 :: Data.Array.Base.IArray
                        a_ar8 e_ar7 Data.Array.Base.IArray [a_ar8, e_ar7]
  Data.Array.Base.IArray UArray Double
  Just [W] $dIArray_ar9 :: Data.Array.Base.IArray UArray Double
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dIArray_ar9 :: Data.Array.Base.IArray
                                      UArray
                                      Double [" a use of ‘listArray’ " p4.hs:25:18-29] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dIArray_ar9 :: Data.Array.Base.IArray
                                      UArray
                                      Double [" a use of ‘listArray’ " p4.hs:25:18-29] (CDictCan)
doTopReact
  [W] $dIArray_ar9 :: Data.Array.Base.IArray
                        UArray Double [" a use of ‘listArray’ " p4.hs:25:18-29] (CDictCan)
matchClassInst
  pred = Data.Array.Base.IArray UArray Double
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 0
          Solved funeqs 0
  untouchables= 0
matchClass success
  dict Data.Array.Base.IArray UArray Double
  witness Data.Array.Base.$fIArrayUArrayDouble Data.Array.Base.IArray
                                                 UArray Double
updSolvedSetTcs:
  [W] $dIArray_ar9 :: Data.Array.Base.IArray UArray Double
doTopReact/found nullary instance for $dIArray_ar9
setEvBind
  ev = $dIArray_ar9
  tm  = Data.Array.Base.$fIArrayUArrayDouble @[] []
35[<C:0,F:0>] [W] $dIArray_ar9 :: Data.Array.Base.IArray
                                    UArray Double: Top react: Dict/Top (solved, no new work)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 1
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dIx_ara :: GHC.Arr.Ix
                                 i_ar6 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 1
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dIx_ara :: GHC.Arr.Ix
                                  i_ar6 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dIx_ara :: GHC.Arr.Ix
                    i_ar6 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
canEvNC:cls GHC.Arr.Ix [i_ar6]
Following bound tyvar i_ar6 = Int
canClass
  [W] $dIx_ara :: GHC.Arr.Ix i_ar6 GHC.Arr.Ix [i_ar6]
  GHC.Arr.Ix Int
  Just [W] $dIx_ara :: GHC.Arr.Ix Int
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dIx_ara :: GHC.Arr.Ix
                                  Int [" a use of ‘listArray’ " p4.hs:25:18-29] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dIx_ara :: GHC.Arr.Ix
                                  Int [" a use of ‘listArray’ " p4.hs:25:18-29] (CDictCan)
doTopReact
  [W] $dIx_ara :: GHC.Arr.Ix
                    Int [" a use of ‘listArray’ " p4.hs:25:18-29] (CDictCan)
matchClassInst
  pred = GHC.Arr.Ix Int
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 1
          Solved funeqs 0
  untouchables= 0
matchClass success
  dict GHC.Arr.Ix Int
  witness GHC.Arr.$fIxInt GHC.Arr.Ix Int
updSolvedSetTcs: [W] $dIx_ara :: GHC.Arr.Ix Int
doTopReact/found nullary instance for $dIx_ara
setEvBind
  ev = $dIx_ara
  tm  = GHC.Arr.$fIxInt @[] []
36[<C:0,F:0>] [W] $dIx_ara :: GHC.Arr.Ix
                                Int: Top react: Dict/Top (solved, no new work)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 2
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dNum_atO :: Num
                                  a_au2 [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 2
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_atO :: Num
                                   a_au2 [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_atO :: Num
                     a_au2 [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
canEvNC:cls Num [a_au2]
Following bound tyvar a_au2 = Int
canClass
  [W] $dNum_atO :: Num a_au2 Num [a_au2]
  Num Int
  Just [W] $dNum_atO :: Num Int
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_atO :: Num
                                   Int [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dNum_atO :: Num
                                   Int [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
doTopReact
  [W] $dNum_atO :: Num
                     Int [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
matchClassInst
  pred = Num Int
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 2
          Solved funeqs 0
  untouchables= 0
matchClass success
  dict Num Int
  witness GHC.Num.$fNumInt Num Int
updSolvedSetTcs: [W] $dNum_atO :: Num Int
doTopReact/found nullary instance for $dNum_atO
setEvBind
  ev = $dNum_atO
  tm  = GHC.Num.$fNumInt @[] []
37[<C:0,F:0>] [W] $dNum_atO :: Num
                                 Int: Top react: Dict/Top (solved, no new work)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 3
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dNum_auS :: Num
                                  a_auR [" the literal ‘1’ " p4.hs:16:51] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 3
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_auS :: Num
                                   a_auR [" the literal ‘1’ " p4.hs:16:51] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_auS :: Num
                     a_auR [" the literal ‘1’ " p4.hs:16:51] (CNonCanonical)
canEvNC:cls Num [a_auR]
Following bound tyvar a_auR = Int
canClass
  [W] $dNum_auS :: Num a_auR Num [a_auR]
  Num Int
  Just [W] $dNum_auS :: Num Int
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_auS :: Num
                                   Int [" the literal ‘1’ " p4.hs:16:51] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dNum_auS :: Num
                                   Int [" the literal ‘1’ " p4.hs:16:51] (CDictCan)
doTopReact
  [W] $dNum_auS :: Num
                     Int [" the literal ‘1’ " p4.hs:16:51] (CDictCan)
setEvBind
  ev = $dNum_auS
  tm  = $dNum_atO
38[<C:0,F:0>] [W] $dNum_auS :: Num
                                 Int: Top react: Dict/Top (cached)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 3
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dEnum_awR :: Enum
                                   t_auQ [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 3
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dEnum_awR :: Enum
                                    t_auQ [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dEnum_awR :: Enum
                      t_auQ [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CNonCanonical)
canEvNC:cls Enum [t_auQ]
Following bound tyvar t_auQ = a_auR
Following bound tyvar a_auR = Int
canClass
  [W] $dEnum_awR :: Enum t_auQ Enum [t_auQ]
  Enum Int
  Just [W] $dEnum_awR :: Enum Int
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dEnum_awR :: Enum
                                    Int [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dEnum_awR :: Enum
                                    Int [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CDictCan)
doTopReact
  [W] $dEnum_awR :: Enum
                      Int [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CDictCan)
matchClassInst
  pred = Enum Int
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 3
          Solved funeqs 0
  untouchables= 0
matchClass success
  dict Enum Int
  witness GHC.Enum.$fEnumInt Enum Int
updSolvedSetTcs: [W] $dEnum_awR :: Enum Int
doTopReact/found nullary instance for $dEnum_awR
setEvBind
  ev = $dEnum_awR
  tm  = GHC.Enum.$fEnumInt @[] []
39[<C:0,F:0>] [W] $dEnum_awR :: Enum
                                  Int: Top react: Dict/Top (solved, no new work)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 4
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dMonad_ax3 :: Monad
                                    m_ax2 [" a do statement " p4.hs:19:11-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 4
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dMonad_ax3 :: Monad
                                     m_ax2 [" a do statement " p4.hs:19:11-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dMonad_ax3 :: Monad
                       m_ax2 [" a do statement " p4.hs:19:11-23] (CNonCanonical)
canEvNC:cls Monad [m_ax2]
Following bound tyvar m_ax2 = IO
canClass
  [W] $dMonad_ax3 :: Monad m_ax2 Monad [m_ax2]
  Monad IO
  Just [W] $dMonad_ax3 :: Monad IO
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dMonad_ax3 :: Monad
                                     IO [" a do statement " p4.hs:19:11-23] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dMonad_ax3 :: Monad
                                     IO [" a do statement " p4.hs:19:11-23] (CDictCan)
doTopReact
  [W] $dMonad_ax3 :: Monad
                       IO [" a do statement " p4.hs:19:11-23] (CDictCan)
matchClassInst
  pred = Monad IO
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 4
          Solved funeqs 0
  untouchables= 0
matchClass success
  dict Monad IO
  witness GHC.Base.$fMonadIO Monad IO
updSolvedSetTcs: [W] $dMonad_ax3 :: Monad IO
doTopReact/found nullary instance for $dMonad_ax3
setEvBind
  ev = $dMonad_ax3
  tm  = GHC.Base.$fMonadIO @[] []
40[<C:0,F:0>] [W] $dMonad_ax3 :: Monad
                                   IO: Top react: Dict/Top (solved, no new work)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 5
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dIx_axw :: GHC.Arr.Ix
                                 i_axs [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 5
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dIx_axw :: GHC.Arr.Ix
                                  i_axs [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dIx_axw :: GHC.Arr.Ix
                    i_axs [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
canEvNC:cls GHC.Arr.Ix [i_axs]
Following bound tyvar i_axs = Int
canClass
  [W] $dIx_axw :: GHC.Arr.Ix i_axs GHC.Arr.Ix [i_axs]
  GHC.Arr.Ix Int
  Just [W] $dIx_axw :: GHC.Arr.Ix Int
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dIx_axw :: GHC.Arr.Ix
                                  Int [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dIx_axw :: GHC.Arr.Ix
                                  Int [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
doTopReact
  [W] $dIx_axw :: GHC.Arr.Ix
                    Int [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
setEvBind
  ev = $dIx_axw
  tm  = $dIx_ara
41[<C:0,F:0>] [W] $dIx_axw :: GHC.Arr.Ix
                                Int: Top react: Dict/Top (cached)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 5
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dIArray_axx :: Data.Array.Base.IArray
                                     a_axr
                                     e_axt [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 5
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dIArray_axx :: Data.Array.Base.IArray
                                      a_axr
                                      e_axt [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dIArray_axx :: Data.Array.Base.IArray
                        a_axr e_axt [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
canEvNC:cls Data.Array.Base.IArray [a_axr, e_axt]
Following bound tyvar a_axr = Array
Following bound tyvar e_axt = FlatVector
canClass
  [W] $dIArray_axx :: Data.Array.Base.IArray
                        a_axr e_axt Data.Array.Base.IArray [a_axr, e_axt]
  Data.Array.Base.IArray Array FlatVector
  Just [W] $dIArray_axx :: Data.Array.Base.IArray Array FlatVector
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dIArray_axx :: Data.Array.Base.IArray
                                      Array
                                      FlatVector [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dIArray_axx :: Data.Array.Base.IArray
                                      Array
                                      FlatVector [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
doTopReact
  [W] $dIArray_axx :: Data.Array.Base.IArray
                        Array FlatVector [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
matchClassInst
  pred = Data.Array.Base.IArray Array FlatVector
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 5
          Solved funeqs 0
  untouchables= 0
matchClass success
  dict Data.Array.Base.IArray Array FlatVector
  witness Data.Array.Base.$fIArrayArraye forall e.
                                         Data.Array.Base.IArray Array e
updSolvedSetTcs:
  [W] $dIArray_axx :: Data.Array.Base.IArray Array FlatVector
doTopReact/found nullary instance for $dIArray_axx
setEvBind
  ev = $dIArray_axx
  tm  = Data.Array.Base.$fIArrayArraye @[UArray Int Double] []
42[<C:0,F:0>] [W] $dIArray_axx :: Data.Array.Base.IArray
                                    Array FlatVector: Top react: Dict/Top (solved, no new work)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dMArray_axy :: Data.Array.Base.MArray
                                     b_axv
                                     e_axt
                                     m_axu [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dMArray_axy :: Data.Array.Base.MArray
                                      b_axv
                                      e_axt
                                      m_axu [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dMArray_axy :: Data.Array.Base.MArray
                        b_axv
                        e_axt
                        m_axu [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
canEvNC:cls Data.Array.Base.MArray [b_axv, e_axt, m_axu]
Following bound tyvar e_axt = FlatVector
Following bound tyvar m_axu = IO
canClass
  [W] $dMArray_axy :: Data.Array.Base.MArray
                        b_axv e_axt m_axu Data.Array.Base.MArray [b_axv, e_axt, m_axu]
  Data.Array.Base.MArray b_axv FlatVector IO
  Just [W] $dMArray_axy :: Data.Array.Base.MArray b_axv FlatVector IO
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dMArray_axy :: Data.Array.Base.MArray
                                      b_axv
                                      FlatVector
                                      IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dMArray_axy :: Data.Array.Base.MArray
                                      b_axv
                                      FlatVector
                                      IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
doTopReact
  [W] $dMArray_axy :: Data.Array.Base.MArray
                        b_axv FlatVector IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
matchClassInst
  pred = Data.Array.Base.MArray b_axv FlatVector IO
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 6
          Solved funeqs 0
  untouchables= 0
matchClass not matching
  dict Data.Array.Base.MArray b_axv FlatVector IO
end stage top-level reactions }
43[<C:0,F:0>] [W] $dMArray_axy :: Data.Array.Base.MArray
                                    b_axv FlatVector IO: Kept as inert
End solver pipeline (not discharged) }
  final_item =  [W] $dMArray_axy :: Data.Array.Base.MArray
                                      b_axv
                                      FlatVector
                                      IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
  (b_axv :: * -> * -> *)
  inerts     =  Equalities:
                Type-function equalities:
                No-eqs: True
                Dictionaries:
                Irreds:
                Insolubles = {}
                Solved dicts 6
                Solved funeqs 0
insertInertItemTcS {
  Trying to insert new inert item: [W] $dMArray_axy :: Data.Array.Base.MArray
                                                         b_axv
                                                         FlatVector
                                                         IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
insertInertItemTcS }
Start solver pipeline {
  work item =  [W] $dMonad_axD :: Monad
                                    m_axC [" a use of ‘return’ " p4.hs:20:11-16] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dMArray_axy :: Data.Array.Base.MArray
                                                   b_axv
                                                   FlatVector
                                                   IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dMonad_axD :: Monad
                                     m_axC [" a use of ‘return’ " p4.hs:20:11-16] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dMonad_axD :: Monad
                       m_axC [" a use of ‘return’ " p4.hs:20:11-16] (CNonCanonical)
canEvNC:cls Monad [m_axC]
Following bound tyvar m_axC = IO
canClass
  [W] $dMonad_axD :: Monad m_axC Monad [m_axC]
  Monad IO
  Just [W] $dMonad_axD :: Monad IO
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dMonad_axD :: Monad
                                     IO [" a use of ‘return’ " p4.hs:20:11-16] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dMonad_axD :: Monad
                                     IO [" a use of ‘return’ " p4.hs:20:11-16] (CDictCan)
doTopReact
  [W] $dMonad_axD :: Monad
                       IO [" a use of ‘return’ " p4.hs:20:11-16] (CDictCan)
setEvBind
  ev = $dMonad_axD
  tm  = $dMonad_ax3
44[<C:0,F:0>] [W] $dMonad_axD :: Monad
                                   IO: Top react: Dict/Top (cached)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dMArray_axy :: Data.Array.Base.MArray
                                                   b_axv
                                                   FlatVector
                                                   IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
solveFlats end } {}
simpl_loop, iteration 1
solveNestedImplications starting {
  original inerts =  Equalities:
                     Type-function equalities:
                     No-eqs: True
                     Dictionaries: [W] $dMArray_axy :: Data.Array.Base.MArray
                                                         b_axv
                                                         FlatVector
                                                         IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
                     Irreds:
                     Insolubles = {}
                     Solved dicts 6
                     Solved funeqs 0
  thinner_inerts  =  Equalities:
                     Type-function equalities:
                     No-eqs: True
                     Dictionaries:
                     Irreds:
                     Insolubles = {}
                     Solved dicts 6
                     Solved funeqs 0
solveImplication {
  Implic {Untouchables = 1
          Skolems = a
          Flatten-skolems =
          No-eqs = False
          Given =
          Wanted = WC {wc_flat = [W] $dIArray_ar1 :: Data.Array.Base.IArray
                                                       a_ar0
                                                       e_aqZ [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                 [W] $dIx_ar2 :: GHC.Arr.Ix
                                                   i_aqY [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                 [W] cobox_ar3 :: ((i_aqY, i_aqY) -> [e_aqZ] -> a_ar0 i_aqY e_aqZ)
                                                  ~ ((Int, Int)
                                                     -> [a] -> Vector a) [" a type equality (i_aqY,
                                                                                             i_aqY)
                                                                                            -> [e_aqZ]
                                                                                            -> a_ar0 i_aqY e_aqZ
                                                                                            ~
                                                                                            (Int,
                                                                                             Int)
                                                                                            -> [a]
                                                                                            -> Vector
                                                                                                 a " p4.hs:30:14-25] (CNonCanonical)}
          Binds = EvBindsVar<ar4>
          the type signature for listVector :: (Int, Int) -> [a] -> Vector a}
solveWanteds {
  WC {wc_flat = [W] $dIArray_ar1 :: Data.Array.Base.IArray
                                      a_ar0
                                      e_aqZ [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                [W] $dIx_ar2 :: GHC.Arr.Ix
                                  i_aqY [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                [W] cobox_ar3 :: ((i_aqY, i_aqY) -> [e_aqZ] -> a_ar0 i_aqY e_aqZ)
                                 ~ ((Int, Int) -> [a] -> Vector a) [" a type equality (i_aqY, i_aqY)
                                                                                      -> [e_aqZ]
                                                                                      -> a_ar0 i_aqY e_aqZ
                                                                                      ~
                                                                                      (Int, Int)
                                                                                      -> [a]
                                                                                      -> Vector
                                                                                           a " p4.hs:30:14-25] (CNonCanonical)}
solveFlats {
Start solver pipeline {
  work item =  [W] cobox_ar3 :: ((i_aqY, i_aqY)
                                 -> [e_aqZ] -> a_ar0 i_aqY e_aqZ)
                                ~ ((Int, Int) -> [a] -> Vector a) [" a type equality (i_aqY, i_aqY)
                                                                                     -> [e_aqZ]
                                                                                     -> a_ar0 i_aqY e_aqZ
                                                                                     ~
                                                                                     (Int, Int)
                                                                                     -> [a]
                                                                                     -> Vector
                                                                                          a " p4.hs:30:14-25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ar3 :: ((i_aqY, i_aqY)
                                  -> [e_aqZ] -> a_ar0 i_aqY e_aqZ)
                                 ~ ((Int, Int) -> [a] -> Vector a) [" a type equality (i_aqY, i_aqY)
                                                                                      -> [e_aqZ]
                                                                                      -> a_ar0 i_aqY e_aqZ
                                                                                      ~
                                                                                      (Int, Int)
                                                                                      -> [a]
                                                                                      -> Vector
                                                                                           a " p4.hs:30:14-25] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ar3 :: ((i_aqY, i_aqY) -> [e_aqZ] -> a_ar0 i_aqY e_aqZ)
                   ~ ((Int, Int) -> [a] -> Vector a) [" a type equality (i_aqY, i_aqY)
                                                                        -> [e_aqZ]
                                                                        -> a_ar0 i_aqY e_aqZ
                                                                        ~
                                                                        (Int, Int)
                                                                        -> [a]
                                                                        -> Vector
                                                                             a " p4.hs:30:14-25] (CNonCanonical)
canEvNC:eq
  (i_aqY, i_aqY) -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
  (Int, Int) -> [a] -> Vector a
can_eq_nc
  [W] cobox_ar3 :: ((i_aqY, i_aqY) -> [e_aqZ] -> a_ar0 i_aqY e_aqZ)
                   ~ ((Int, Int) -> [a] -> Vector a)
  (i_aqY, i_aqY) -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
  (i_aqY, i_aqY) -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
  (Int, Int) -> [a] -> Vector a
  (Int, Int) -> [a] -> Vector a
newWantedEvVar/cache miss
  [W] cobox_aIK :: (i_aqY, i_aqY) ~ (Int, Int)
newWantedEvVar/cache miss
  [W] cobox_aIL :: ([e_aqZ] -> a_ar0 i_aqY e_aqZ) ~ ([a] -> Vector a)
setEvBind
  ev = cobox_ar3
  tm  = CO cobox_aIK -> cobox_aIL
canEvNC:eq
  (i_aqY, i_aqY)
  (Int, Int)
can_eq_nc
  [W] cobox_aIK :: (i_aqY, i_aqY) ~ (Int, Int)
  (i_aqY, i_aqY)
  (i_aqY, i_aqY)
  (Int, Int)
  (Int, Int)
newWantedEvVar/cache miss [W] cobox_aIM :: i_aqY ~ Int
newWantedEvVar/cache miss [W] cobox_aIN :: i_aqY ~ Int
setEvBind
  ev = cobox_aIK
  tm  = CO (cobox_aIM, cobox_aIN)_N
canEvNC:eq
  i_aqY
  Int
can_eq_nc
  [W] cobox_aIM :: i_aqY ~ Int
  i_aqY
  i_aqY
  Int
  Int
canEqTyVar
  i_aqY
  Int
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_aIM :: i_aqY
                                 ~ Int [" a type equality (i_aqY, i_aqY)
                                                          -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                          ~
                                                          (Int, Int)
                                                          -> [a]
                                                          -> Vector a " p4.hs:30:14-25] (CTyEqCan)
Sneaky unification:
  Unifies: i_aqY := Int
  Coercion: i_aqY ~ Int
  Left Kind is: *
  Right Kind is: *
setWantedTyBind i_aqY := Int
setEvBind
  ev = cobox_aIM
  tm  = CO <Int>_N
kickOutRewritable
  tv =  i_aqY
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
45[<C:0,F:0>] [W] cobox_aIM :: i_aqY ~ Int: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_aIN :: i_aqY
                                ~ Int [" a type equality (i_aqY, i_aqY)
                                                         -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                         ~
                                                         (Int, Int)
                                                         -> [a]
                                                         -> Vector
                                                              a " p4.hs:30:14-25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_aIN :: i_aqY
                                 ~ Int [" a type equality (i_aqY, i_aqY)
                                                          -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                          ~
                                                          (Int, Int)
                                                          -> [a]
                                                          -> Vector
                                                               a " p4.hs:30:14-25] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_aIN :: i_aqY ~ Int [" a type equality (i_aqY, i_aqY)
                                                  -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                  ~
                                                  (Int, Int)
                                                  -> [a]
                                                  -> Vector a " p4.hs:30:14-25] (CNonCanonical)
canEvNC:eq
  i_aqY
  Int
can_eq_nc
  [W] cobox_aIN :: i_aqY ~ Int
  i_aqY
  i_aqY
  Int
  Int
canEqTyVar
  i_aqY
  Int
  Not-swapped
Following bound tyvar i_aqY = Int
canEqTyVar2
  i_aqY
  Int
  Not-swapped
  Int
  <Int>_N
can_eq_nc
  [W] cobox_aIN :: Int ~ Int
  Int
  Int
  Int
  Int
setEvBind
  ev = cobox_aIN
  tm  = CO <Int>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_aIL :: ([e_aqZ] -> a_ar0 i_aqY e_aqZ)
                                ~ ([a] -> Vector a) [" a type equality (i_aqY, i_aqY)
                                                                       -> [e_aqZ]
                                                                       -> a_ar0 i_aqY e_aqZ
                                                                       ~
                                                                       (Int, Int)
                                                                       -> [a]
                                                                       -> Vector
                                                                            a " p4.hs:30:14-25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_aIL :: ([e_aqZ] -> a_ar0 i_aqY e_aqZ)
                                 ~ ([a] -> Vector a) [" a type equality (i_aqY, i_aqY)
                                                                        -> [e_aqZ]
                                                                        -> a_ar0 i_aqY e_aqZ
                                                                        ~
                                                                        (Int, Int)
                                                                        -> [a]
                                                                        -> Vector
                                                                             a " p4.hs:30:14-25] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_aIL :: ([e_aqZ] -> a_ar0 i_aqY e_aqZ)
                   ~ ([a] -> Vector a) [" a type equality (i_aqY, i_aqY)
                                                          -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                          ~
                                                          (Int, Int)
                                                          -> [a]
                                                          -> Vector
                                                               a " p4.hs:30:14-25] (CNonCanonical)
canEvNC:eq
  [e_aqZ] -> a_ar0 i_aqY e_aqZ
  [a] -> Vector a
can_eq_nc
  [W] cobox_aIL :: ([e_aqZ] -> a_ar0 i_aqY e_aqZ) ~ ([a] -> Vector a)
  [e_aqZ] -> a_ar0 i_aqY e_aqZ
  [e_aqZ] -> a_ar0 i_aqY e_aqZ
  [a] -> Vector a
  [a] -> Vector a
newWantedEvVar/cache miss [W] cobox_aIO :: [e_aqZ] ~ [a]
newWantedEvVar/cache miss
  [W] cobox_aIP :: a_ar0 i_aqY e_aqZ ~ Vector a
setEvBind
  ev = cobox_aIL
  tm  = CO cobox_aIO -> cobox_aIP
canEvNC:eq
  [e_aqZ]
  [a]
can_eq_nc
  [W] cobox_aIO :: [e_aqZ] ~ [a]
  [e_aqZ]
  [e_aqZ]
  [a]
  [a]
newWantedEvVar/cache miss [W] cobox_aIQ :: e_aqZ ~ a
setEvBind
  ev = cobox_aIO
  tm  = CO [cobox_aIQ]_N
canEvNC:eq
  e_aqZ
  a
can_eq_nc
  [W] cobox_aIQ :: e_aqZ ~ a
  e_aqZ
  e_aqZ
  a
  a
canEqTyVar
  e_aqZ
  a
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_aIQ :: e_aqZ ~ a [" a type equality (i_aqY,
                                                               i_aqY)
                                                              -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                              ~
                                                              (Int, Int)
                                                              -> [a]
                                                              -> Vector
                                                                   a " p4.hs:30:14-25] (CTyEqCan)
Sneaky unification:
  Unifies: e_aqZ := a
  Coercion: e_aqZ ~ a
  Left Kind is: *
  Right Kind is: *
setWantedTyBind e_aqZ := a
setEvBind
  ev = cobox_aIQ
  tm  = CO <a>_N
kickOutRewritable
  tv =  e_aqZ
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
47[<C:0,F:0>] [W] cobox_aIQ :: e_aqZ ~ a: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_aIP :: a_ar0 i_aqY e_aqZ
                                ~ Vector a [" a type equality (i_aqY, i_aqY)
                                                              -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                              ~
                                                              (Int, Int)
                                                              -> [a]
                                                              -> Vector
                                                                   a " p4.hs:30:14-25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_aIP :: a_ar0 i_aqY e_aqZ
                                 ~ Vector a [" a type equality (i_aqY, i_aqY)
                                                               -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                               ~
                                                               (Int, Int)
                                                               -> [a]
                                                               -> Vector
                                                                    a " p4.hs:30:14-25] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_aIP :: a_ar0 i_aqY e_aqZ
                   ~ Vector a [" a type equality (i_aqY, i_aqY)
                                                 -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                 ~
                                                 (Int, Int)
                                                 -> [a]
                                                 -> Vector a " p4.hs:30:14-25] (CNonCanonical)
canEvNC:eq
  a_ar0 i_aqY e_aqZ
  Vector a
can_eq_nc
  [W] cobox_aIP :: a_ar0 i_aqY e_aqZ ~ Vector a
  a_ar0 i_aqY e_aqZ
  a_ar0 i_aqY e_aqZ
  Vector a
  Vector a
can_eq_nc
  [W] cobox_aIP :: a_ar0 i_aqY e_aqZ ~ Vector a
  a_ar0 i_aqY e_aqZ
  a_ar0 i_aqY e_aqZ
  Array Int a
  Vector a
can_eq_app 1
  [W] cobox_aIP :: a_ar0 i_aqY e_aqZ ~ Vector a
  Not-swapped
  a_ar0 i_aqY
  e_aqZ
  Array Int a
Following bound tyvar i_aqY = Int
flatten/appty
  a_ar0
  i_aqY
  a_ar0
  <a_ar0>_N
  Int
  <Int>_N
can_eq_app 2
  [W] cobox_aIP :: a_ar0 i_aqY e_aqZ ~ Vector a
  a_ar0 Int
Following bound tyvar e_aqZ = a
can_eq_app 3
  [W] cobox_aIP :: a_ar0 i_aqY e_aqZ ~ Vector a
  a_ar0 Int a
  <a_ar0 Int a>_N
can_eq_app 4
  [W] cobox_aIP :: a_ar0 i_aqY e_aqZ ~ Vector a
  a_ar0 Int a
  <a_ar0 Int a>_N
can_eq_nc
  [W] cobox_aIP :: a_ar0 Int a ~ Vector a
  a_ar0 Int a
  a_ar0 Int a
  Array Int a
  Vector a
can_eq_app 1
  [W] cobox_aIP :: a_ar0 Int a ~ Vector a
  Not-swapped
  a_ar0 Int
  a
  Array Int a
flatten/appty
  a_ar0
  Int
  a_ar0
  <a_ar0>_N
  Int
  <Int>_N
can_eq_app 2
  [W] cobox_aIP :: a_ar0 Int a ~ Vector a
  a_ar0 Int
newWantedEvVar/cache miss [W] cobox_aIR :: a_ar0 Int ~ Array Int
newWantedEvVar/cache miss [W] cobox_aIS :: a ~ a
setEvBind
  ev = cobox_aIP
  tm  = CO cobox_aIR cobox_aIS
canEvNC:eq
  a_ar0 Int
  Array Int
can_eq_nc
  [W] cobox_aIR :: a_ar0 Int ~ Array Int
  a_ar0 Int
  a_ar0 Int
  Array Int
  Array Int
can_eq_app 1
  [W] cobox_aIR :: a_ar0 Int ~ Array Int
  Not-swapped
  a_ar0
  Int
  Array Int
can_eq_app 2
  [W] cobox_aIR :: a_ar0 Int ~ Array Int
  a_ar0
newWantedEvVar/cache miss [W] cobox_aIT :: a_ar0 ~ Array
newWantedEvVar/cache miss [W] cobox_aIU :: Int ~ Int
setEvBind
  ev = cobox_aIR
  tm  = CO cobox_aIT cobox_aIU
canEvNC:eq
  a_ar0
  Array
can_eq_nc
  [W] cobox_aIT :: a_ar0 ~ Array
  a_ar0
  a_ar0
  Array
  Array
canEqTyVar
  a_ar0
  Array
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_aIT :: a_ar0
                                 ~ Array [" a type equality (i_aqY, i_aqY)
                                                            -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                            ~
                                                            (Int, Int)
                                                            -> [a]
                                                            -> Vector a " p4.hs:30:14-25] (CTyEqCan)
Sneaky unification:
  Unifies: a_ar0 := Array
  Coercion: a_ar0 ~ Array
  Left Kind is: * -> * -> *
  Right Kind is: * -> * -> *
setWantedTyBind a_ar0 := Array
setEvBind
  ev = cobox_aIT
  tm  = CO <Array>_N
kickOutRewritable
  tv =  a_ar0
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
48[<C:0,F:0>] [W] cobox_aIT :: a_ar0 ~ Array: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_aIU :: Int ~ Int [" a type equality (i_aqY,
                                                              i_aqY)
                                                             -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                             ~
                                                             (Int, Int)
                                                             -> [a]
                                                             -> Vector
                                                                  a " p4.hs:30:14-25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_aIU :: Int ~ Int [" a type equality (i_aqY,
                                                               i_aqY)
                                                              -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                              ~
                                                              (Int, Int)
                                                              -> [a]
                                                              -> Vector
                                                                   a " p4.hs:30:14-25] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_aIU :: Int ~ Int [" a type equality (i_aqY, i_aqY)
                                                -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                ~
                                                (Int, Int)
                                                -> [a] -> Vector a " p4.hs:30:14-25] (CNonCanonical)
canEvNC:eq
  Int
  Int
can_eq_nc
  [W] cobox_aIU :: Int ~ Int
  Int
  Int
  Int
  Int
setEvBind
  ev = cobox_aIU
  tm  = CO <Int>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_aIS :: a ~ a [" a type equality (i_aqY,
                                                          i_aqY)
                                                         -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                         ~
                                                         (Int, Int)
                                                         -> [a]
                                                         -> Vector
                                                              a " p4.hs:30:14-25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_aIS :: a ~ a [" a type equality (i_aqY,
                                                           i_aqY)
                                                          -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                          ~
                                                          (Int, Int)
                                                          -> [a]
                                                          -> Vector
                                                               a " p4.hs:30:14-25] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_aIS :: a ~ a [" a type equality (i_aqY, i_aqY)
                                            -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                            ~
                                            (Int, Int)
                                            -> [a] -> Vector a " p4.hs:30:14-25] (CNonCanonical)
canEvNC:eq
  a
  a
can_eq_nc
  [W] cobox_aIS :: a ~ a
  a
  a
  a
  a
canEqTyVar
  a
  a
  Not-swapped
setEvBind
  ev = cobox_aIS
  tm  = CO <a>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dIArray_ar1 :: Data.Array.Base.IArray
                                     a_ar0
                                     e_aqZ [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dIArray_ar1 :: Data.Array.Base.IArray
                                      a_ar0
                                      e_aqZ [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dIArray_ar1 :: Data.Array.Base.IArray
                        a_ar0
                        e_aqZ [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
canEvNC:cls Data.Array.Base.IArray [a_ar0, e_aqZ]
Following bound tyvar a_ar0 = Array
Following bound tyvar e_aqZ = a
canClass
  [W] $dIArray_ar1 :: Data.Array.Base.IArray
                        a_ar0 e_aqZ Data.Array.Base.IArray [a_ar0, e_aqZ]
  Data.Array.Base.IArray Array a
  Just [W] $dIArray_ar1 :: Data.Array.Base.IArray Array a
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dIArray_ar1 :: Data.Array.Base.IArray
                                      Array a [" a use of ‘listArray’ " p4.hs:30:14-25] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dIArray_ar1 :: Data.Array.Base.IArray
                                      Array a [" a use of ‘listArray’ " p4.hs:30:14-25] (CDictCan)
doTopReact
  [W] $dIArray_ar1 :: Data.Array.Base.IArray
                        Array a [" a use of ‘listArray’ " p4.hs:30:14-25] (CDictCan)
matchClassInst
  pred = Data.Array.Base.IArray Array a
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 6
          Solved funeqs 0
  untouchables= 1
matchClass success
  dict Data.Array.Base.IArray Array a
  witness Data.Array.Base.$fIArrayArraye forall e.
                                         Data.Array.Base.IArray Array e
updSolvedSetTcs: [W] $dIArray_ar1 :: Data.Array.Base.IArray Array a
doTopReact/found nullary instance for $dIArray_ar1
setEvBind
  ev = $dIArray_ar1
  tm  = Data.Array.Base.$fIArrayArraye @[a] []
51[<C:0,F:0>] [W] $dIArray_ar1 :: Data.Array.Base.IArray
                                    Array a: Top react: Dict/Top (solved, no new work)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 7
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dIx_ar2 :: GHC.Arr.Ix
                                 i_aqY [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 7
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dIx_ar2 :: GHC.Arr.Ix
                                  i_aqY [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dIx_ar2 :: GHC.Arr.Ix
                    i_aqY [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
canEvNC:cls GHC.Arr.Ix [i_aqY]
Following bound tyvar i_aqY = Int
canClass
  [W] $dIx_ar2 :: GHC.Arr.Ix i_aqY GHC.Arr.Ix [i_aqY]
  GHC.Arr.Ix Int
  Just [W] $dIx_ar2 :: GHC.Arr.Ix Int
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dIx_ar2 :: GHC.Arr.Ix
                                  Int [" a use of ‘listArray’ " p4.hs:30:14-25] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dIx_ar2 :: GHC.Arr.Ix
                                  Int [" a use of ‘listArray’ " p4.hs:30:14-25] (CDictCan)
doTopReact
  [W] $dIx_ar2 :: GHC.Arr.Ix
                    Int [" a use of ‘listArray’ " p4.hs:30:14-25] (CDictCan)
setEvBind
  ev = $dIx_ar2
  tm  = $dIx_ara
52[<C:0,F:0>] [W] $dIx_ar2 :: GHC.Arr.Ix
                                Int: Top react: Dict/Top (cached)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 7
               Solved funeqs 0
solveFlats end } {}
simpl_loop, iteration 1
solveWanteds }
  unsolved_flats   = {}
  unsolved_implics = {}
  current evbinds  = {$dIArray_ar1
                        = Data.Array.Base.$fIArrayArraye @[a] [],
                      $dIx_ar2 = $dIx_ara, cobox_ar3 = CO cobox_aIK -> cobox_aIL,
                      cobox_aIK = CO (cobox_aIM, cobox_aIN)_N,
                      cobox_aIL = CO cobox_aIO -> cobox_aIP, cobox_aIM = CO <Int>_N,
                      cobox_aIN = CO <Int>_N, cobox_aIO = CO [cobox_aIQ]_N,
                      cobox_aIP = CO cobox_aIR cobox_aIS, cobox_aIQ = CO <a>_N,
                      cobox_aIR = CO cobox_aIT cobox_aIU, cobox_aIS = CO <a>_N,
                      cobox_aIT = CO <Array>_N, cobox_aIU = CO <Int>_N}
  current tybinds  = (i_aqY, Int)
                     (e_aqZ, a)
                     (a_ar0, Array)
                     (i_ar6, Int)
                     (e_ar7, Double)
                     (a_ar8, UArray)
                     (a_au2, Int)
                     (t_auG, Int)
                     (a_auI, a_au2)
                     (t_auM, a_au2)
                     (t_auQ, a_auR)
                     (a_auR, Int)
                     (a_awT, FlatVector)
                     (t_awX, m_ax2 a_ax4)
                     (t_awY, a_ax4)
                     (t_awZ, m_ax2 b_ax5)
                     (m_ax2, IO)
                     (a_ax4, b_axv i_axs e_axt)
                     (b_ax5, ())
                     (a_axr, Array)
                     (i_axs, Int)
                     (e_axt, FlatVector)
                     (m_axu, IO)
                     (m_axC, IO)
                     (a_axE, ())
                     (t_axI, ())
  final wc = WC {}
floatEqualities
  Flats = {}
  Floated eqs = {}
  Ty binds = [(aqY, (i_aqY, Int)), (aqZ, (e_aqZ, a)),
              (ar0, (a_ar0, Array)), (ar6, (i_ar6, Int)), (ar7, (e_ar7, Double)),
              (ar8, (a_ar8, UArray)), (au2, (a_au2, Int)), (auG, (t_auG, Int)),
              (auI, (a_auI, a_au2)), (auM, (t_auM, a_au2)),
              (auQ, (t_auQ, a_auR)), (auR, (a_auR, Int)),
              (awT, (a_awT, FlatVector)), (awX, (t_awX, m_ax2 a_ax4)),
              (awY, (t_awY, a_ax4)), (awZ, (t_awZ, m_ax2 b_ax5)),
              (ax2, (m_ax2, IO)), (ax4, (a_ax4, b_axv i_axs e_axt)),
              (ax5, (b_ax5, ())), (axr, (a_axr, Array)), (axs, (i_axs, Int)),
              (axt, (e_axt, FlatVector)), (axu, (m_axu, IO)), (axC, (m_axC, IO)),
              (axE, (a_axE, ())), (axI, (t_axI, ()))]
solveImplication end }
  no_given_eqs = True
  floated_eqs = {}
  new_fsks = []
  res_implic = {}
  implication evbinds =  {$dIArray_ar9
                            = Data.Array.Base.$fIArrayUArrayDouble @[] [],
                          $dIx_ara = GHC.Arr.$fIxInt @[] [],
                          cobox_arb = CO cobox_ay2 -> cobox_ay3,
                          $dNum_atO = GHC.Num.$fNumInt @[] [], cobox_auJ = CO Sym cobox_ayd,
                          cobox_auK = CO [cobox_aye]_N, cobox_auN = CO [cobox_ayf]_N,
                          cobox_auO = CO UArray cobox_ayg cobox_ayh_N,
                          cobox_auP = CO <Int>_N, $dNum_auS = $dNum_atO,
                          cobox_auT = CO cobox_ayi -> cobox_ayj,
                          cobox_auU = CO Sym cobox_ayk,
                          $dEnum_awR = GHC.Enum.$fEnumInt @[] [],
                          cobox_awU = CO Array cobox_ayl cobox_aym_N, cobox_awV = CO <Int>_N,
                          cobox_awW = CO [cobox_ayn]_N,
                          $dMonad_ax3 = GHC.Base.$fMonadIO @[] [],
                          cobox_ax7 = CO cobox_ayr -> cobox_ays, $dIx_axw = $dIx_ara,
                          $dIArray_axx
                            = Data.Array.Base.$fIArrayArraye @[UArray Int Double] [],
                          cobox_axz = CO Sym cobox_ayB, cobox_axA = CO cobox_ayF cobox_ayG,
                          $dMonad_axD = $dMonad_ax3, cobox_axG = CO Sym cobox_ayM,
                          cobox_axH = CO Sym cobox_ayR, cobox_axJ = CO IO cobox_ayS_N,
                          cobox_ay2 = CO (cobox_ay4, cobox_ay5)_N,
                          cobox_ay3 = CO cobox_ay6 -> cobox_ay7, cobox_ay4 = CO <Int>_N,
                          cobox_ay5 = CO <Int>_N, cobox_ay6 = CO [cobox_ay8]_N,
                          cobox_ay7 = CO cobox_ay9 cobox_aya, cobox_ay8 = CO <Double>_N,
                          cobox_ay9 = CO cobox_ayb cobox_ayc, cobox_aya = CO <Double>_N,
                          cobox_ayb = CO <UArray>_N, cobox_ayc = CO <Int>_N,
                          cobox_ayd = CO <Int>_N, cobox_aye = CO <a_au2>_N,
                          cobox_ayf = CO <a_au2>_N, cobox_ayg = CO <Int>_N,
                          cobox_ayh = CO <Double>_N, cobox_ayi = CO <Integer>_N,
                          cobox_ayj = CO <a_auR>_N, cobox_ayk = CO <Int>_N,
                          cobox_ayl = CO <Int>_N, cobox_aym = CO <FlatVector>_N,
                          cobox_ayn = CO Sym cobox_ayo,
                          cobox_ayo = CO UArray cobox_ayp cobox_ayq_N,
                          cobox_ayp = CO <Int>_N, cobox_ayq = CO <Double>_N,
                          cobox_ayr = CO Sym cobox_ayt,
                          cobox_ays = CO cobox_ayu -> cobox_ayv,
                          cobox_ayt = CO <m_ax2 a_ax4>_N,
                          cobox_ayu = CO cobox_ayw -> cobox_ayx,
                          cobox_ayv = CO cobox_ayz cobox_ayA, cobox_ayw = CO <a_ax4>_N,
                          cobox_ayx = CO Sym cobox_ayy, cobox_ayy = CO <m_ax2 b_ax5>_N,
                          cobox_ayz = CO <IO>_N, cobox_ayA = CO <()>_N,
                          cobox_ayB = CO cobox_ayC cobox_ayD, cobox_ayC = CO Sym cobox_ayE,
                          cobox_ayD = CO <b_axv i_axs e_axt>_N, cobox_ayE = CO <IO>_N,
                          cobox_ayF = CO cobox_ayH cobox_ayI, cobox_ayG = CO Sym cobox_ayL,
                          cobox_ayH = CO Sym cobox_ayJ, cobox_ayI = CO Sym cobox_ayK,
                          cobox_ayJ = CO <Array>_N, cobox_ayK = CO <Int>_N,
                          cobox_ayL = CO <FlatVector>_N, cobox_ayM = CO cobox_ayN cobox_ayO,
                          cobox_ayN = CO Sym cobox_ayP, cobox_ayO = CO Sym cobox_ayQ,
                          cobox_ayP = CO <IO>_N, cobox_ayQ = CO <()>_N,
                          cobox_ayR = CO <()>_N, cobox_ayS = CO Sym cobox_ayT,
                          cobox_ayT = CO <()>_N}
solveNestedImplications end }
  all floated_eqs = {}
  unsolved_implics = {}
solveWanteds }
  unsolved_flats   = {[W] $dMArray_axy :: Data.Array.Base.MArray
                                            b_axv
                                            FlatVector
                                            IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)}
  unsolved_implics = {}
  current evbinds  = {$dIArray_ar9
                        = Data.Array.Base.$fIArrayUArrayDouble @[] [],
                      $dIx_ara = GHC.Arr.$fIxInt @[] [],
                      cobox_arb = CO cobox_ay2 -> cobox_ay3,
                      $dNum_atO = GHC.Num.$fNumInt @[] [], cobox_auJ = CO Sym cobox_ayd,
                      cobox_auK = CO [cobox_aye]_N, cobox_auN = CO [cobox_ayf]_N,
                      cobox_auO = CO UArray cobox_ayg cobox_ayh_N,
                      cobox_auP = CO <Int>_N, $dNum_auS = $dNum_atO,
                      cobox_auT = CO cobox_ayi -> cobox_ayj,
                      cobox_auU = CO Sym cobox_ayk,
                      $dEnum_awR = GHC.Enum.$fEnumInt @[] [],
                      cobox_awU = CO Array cobox_ayl cobox_aym_N, cobox_awV = CO <Int>_N,
                      cobox_awW = CO [cobox_ayn]_N,
                      $dMonad_ax3 = GHC.Base.$fMonadIO @[] [],
                      cobox_ax7 = CO cobox_ayr -> cobox_ays, $dIx_axw = $dIx_ara,
                      $dIArray_axx
                        = Data.Array.Base.$fIArrayArraye @[UArray Int Double] [],
                      cobox_axz = CO Sym cobox_ayB, cobox_axA = CO cobox_ayF cobox_ayG,
                      $dMonad_axD = $dMonad_ax3, cobox_axG = CO Sym cobox_ayM,
                      cobox_axH = CO Sym cobox_ayR, cobox_axJ = CO IO cobox_ayS_N,
                      cobox_ay2 = CO (cobox_ay4, cobox_ay5)_N,
                      cobox_ay3 = CO cobox_ay6 -> cobox_ay7, cobox_ay4 = CO <Int>_N,
                      cobox_ay5 = CO <Int>_N, cobox_ay6 = CO [cobox_ay8]_N,
                      cobox_ay7 = CO cobox_ay9 cobox_aya, cobox_ay8 = CO <Double>_N,
                      cobox_ay9 = CO cobox_ayb cobox_ayc, cobox_aya = CO <Double>_N,
                      cobox_ayb = CO <UArray>_N, cobox_ayc = CO <Int>_N,
                      cobox_ayd = CO <Int>_N, cobox_aye = CO <a_au2>_N,
                      cobox_ayf = CO <a_au2>_N, cobox_ayg = CO <Int>_N,
                      cobox_ayh = CO <Double>_N, cobox_ayi = CO <Integer>_N,
                      cobox_ayj = CO <a_auR>_N, cobox_ayk = CO <Int>_N,
                      cobox_ayl = CO <Int>_N, cobox_aym = CO <FlatVector>_N,
                      cobox_ayn = CO Sym cobox_ayo,
                      cobox_ayo = CO UArray cobox_ayp cobox_ayq_N,
                      cobox_ayp = CO <Int>_N, cobox_ayq = CO <Double>_N,
                      cobox_ayr = CO Sym cobox_ayt,
                      cobox_ays = CO cobox_ayu -> cobox_ayv,
                      cobox_ayt = CO <m_ax2 a_ax4>_N,
                      cobox_ayu = CO cobox_ayw -> cobox_ayx,
                      cobox_ayv = CO cobox_ayz cobox_ayA, cobox_ayw = CO <a_ax4>_N,
                      cobox_ayx = CO Sym cobox_ayy, cobox_ayy = CO <m_ax2 b_ax5>_N,
                      cobox_ayz = CO <IO>_N, cobox_ayA = CO <()>_N,
                      cobox_ayB = CO cobox_ayC cobox_ayD, cobox_ayC = CO Sym cobox_ayE,
                      cobox_ayD = CO <b_axv i_axs e_axt>_N, cobox_ayE = CO <IO>_N,
                      cobox_ayF = CO cobox_ayH cobox_ayI, cobox_ayG = CO Sym cobox_ayL,
                      cobox_ayH = CO Sym cobox_ayJ, cobox_ayI = CO Sym cobox_ayK,
                      cobox_ayJ = CO <Array>_N, cobox_ayK = CO <Int>_N,
                      cobox_ayL = CO <FlatVector>_N, cobox_ayM = CO cobox_ayN cobox_ayO,
                      cobox_ayN = CO Sym cobox_ayP, cobox_ayO = CO Sym cobox_ayQ,
                      cobox_ayP = CO <IO>_N, cobox_ayQ = CO <()>_N,
                      cobox_ayR = CO <()>_N, cobox_ayS = CO Sym cobox_ayT,
                      cobox_ayT = CO <()>_N}
  current tybinds  = (i_aqY, Int)
                     (e_aqZ, a)
                     (a_ar0, Array)
                     (i_ar6, Int)
                     (e_ar7, Double)
                     (a_ar8, UArray)
                     (a_au2, Int)
                     (t_auG, Int)
                     (a_auI, a_au2)
                     (t_auM, a_au2)
                     (t_auQ, a_auR)
                     (a_auR, Int)
                     (a_awT, FlatVector)
                     (t_awX, m_ax2 a_ax4)
                     (t_awY, a_ax4)
                     (t_awZ, m_ax2 b_ax5)
                     (m_ax2, IO)
                     (a_ax4, b_axv i_axs e_axt)
                     (b_ax5, ())
                     (a_axr, Array)
                     (i_axs, Int)
                     (e_axt, FlatVector)
                     (m_axu, IO)
                     (m_axC, IO)
                     (a_axE, ())
                     (t_axI, ())
  final wc = WC {wc_flat = [W] $dMArray_axy :: Data.Array.Base.MArray
                                                 b_axv
                                                 FlatVector
                                                 IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)}
applyDefaultingRules { 
  wanteds = {[W] $dMArray_axy :: Data.Array.Base.MArray
                                   b_axv
                                   FlatVector
                                   IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)}
findDefaultableGroups
  groups= []
  info= ([Integer, Double], (False, False))
applyDefaultingRules } []
writeMetaTyVar i_aqY := Int
writeMetaTyVar e_aqZ := a
writeMetaTyVar a_ar0 := Array
writeMetaTyVar i_ar6 := Int
writeMetaTyVar e_ar7 := Double
writeMetaTyVar a_ar8 := UArray
writeMetaTyVar a_au2 := Int
writeMetaTyVar t_auG := Int
writeMetaTyVar a_auI := a_au2
writeMetaTyVar t_auM := a_au2
writeMetaTyVar t_auQ := a_auR
writeMetaTyVar a_auR := Int
writeMetaTyVar a_awT := FlatVector
writeMetaTyVar t_awX := m_ax2 a_ax4
writeMetaTyVar t_awY := a_ax4
writeMetaTyVar t_awZ := m_ax2 b_ax5
writeMetaTyVar m_ax2 := IO
writeMetaTyVar a_ax4 := b_axv i_axs e_axt
writeMetaTyVar b_ax5 := ()
writeMetaTyVar a_axr := Array
writeMetaTyVar i_axs := Int
writeMetaTyVar e_axt := FlatVector
writeMetaTyVar m_axu := IO
writeMetaTyVar m_axC := IO
writeMetaTyVar a_axE := ()
writeMetaTyVar t_axI := ()
Constraint solver steps = 52
End simplifyTop }
reportUnsolved {
reportUnsolved (before unflattening)
  WC {wc_flat = [W] $dMArray_axy :: Data.Array.Base.MArray
                                      b_axv
                                      FlatVector
                                      IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)}
reportUnsolved (after unflattening):
  (b_axv :: * -> * -> *)
  WC {wc_flat = [W] $dMArray_axy :: Data.Array.Base.MArray
                                      b_axv
                                      FlatVector
                                      IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)}
reportFlats
  Flats = {}
  Suppress = False
tryReporters { []
tryReporters: no Utterly wrong
tryReporters: no Holes
tryReporters: no Skolem equalities
tryReporters: no Equalities
tryReporters: no Implicit params
tryReporters: no Irreds
tryReporters: no Dicts
tryReporters }
reportFlats
  Flats = {}
  Suppress = False
tryReporters { []
tryReporters: no Utterly wrong
tryReporters: no Holes
tryReporters: no Skolem equalities
tryReporters: no Equalities
tryReporters: no Implicit params
tryReporters: no Irreds
tryReporters: no Dicts
tryReporters }
reportFlats
  Flats = {[W] $dMArray_axy :: Data.Array.Base.MArray
                                 b0
                                 FlatVector
                                 IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)}
  Suppress = False
tryReporters {
  [[W] $dMArray_axy :: Data.Array.Base.MArray
                         b0
                         FlatVector
                         IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)]
tryReporters: no Utterly wrong
tryReporters: no Holes
tryReporters: no Skolem equalities
tryReporters: no Equalities
tryReporters: no Implicit params
tryReporters: no Irreds
tryReporters: yes
  Dicts [[W] $dMArray_axy :: Data.Array.Base.MArray
                               b0
                               FlatVector
                               IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)]
relevantBindings
  [tmp, help, dim, sL, main, listFlatVector, listVector]
mk_dict_err
  [W] $dMArray_axy :: Data.Array.Base.MArray
                        b0
                        FlatVector
                        IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
  True
  The type variable ‘b0’ is ambiguous
Adding error:
  p4.hs:19:16:
      No instance for (Data.Array.Base.MArray b0 FlatVector IO)
        arising from a use of ‘thaw’
      The type variable ‘b0’ is ambiguous
      Note: there is a potential instance available:
        instance Data.Array.Base.MArray GHC.IOArray.IOArray e IO
          -- Defined in ‘Data.Array.Base’
      In a stmt of a 'do' block: v <- thaw tmp
      In the expression:
        do { let sL = ...
                 dim = length sL
                 ....;
             v <- thaw tmp;
             return () }
      In an equation for ‘main’:
          main
            = do { let sL = ...
                       ....;
                   v <- thaw tmp;
                   return () }
tryReporters }
reportUnsolved }
InstEnvs (External) {
  instance Control.Applicative.Alternative []
    -- Defined in ‘Control.Applicative’
  instance Control.Monad.MonadPlus m =>
           Control.Applicative.Alternative
             (Control.Applicative.WrappedMonad m)
    -- Defined in ‘Control.Applicative’
  instance (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) =>
           Control.Applicative.Alternative
             (Control.Applicative.WrappedArrow a b)
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Alternative GHC.Conc.Sync.STM
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Alternative
             Text.ParserCombinators.ReadPrec.ReadPrec
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Alternative
             Text.ParserCombinators.ReadP.ReadP
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Alternative Maybe
    -- Defined in ‘Control.Applicative’
  instance Control.Arrow.ArrowPlus a =>
           Control.Applicative.Alternative (Control.Arrow.ArrowMonad a)
    -- Defined in ‘Control.Applicative’
  instance Bounded GHC.Int.Int8 -- Defined in ‘GHC.Int’
  instance Bounded GHC.Int.Int64 -- Defined in ‘GHC.Int’
  instance Bounded GHC.Int.Int32 -- Defined in ‘GHC.Int’
  instance Bounded GHC.Int.Int16 -- Defined in ‘GHC.Int’
  instance Bounded GHC.Word.Word8 -- Defined in ‘GHC.Word’
  instance Bounded GHC.Word.Word64 -- Defined in ‘GHC.Word’
  instance Bounded GHC.Word.Word32 -- Defined in ‘GHC.Word’
  instance Bounded GHC.Word.Word16 -- Defined in ‘GHC.Word’
  instance Bounded GHC.Types.Word -- Defined in ‘GHC.Enum’
  instance Bounded Ordering -- Defined in ‘GHC.Enum’
  instance Bounded Int -- Defined in ‘GHC.Enum’
  instance Bounded Char -- Defined in ‘GHC.Enum’
  instance Bounded Bool -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
            Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k,
            Bounded l, Bounded m, Bounded n, Bounded o) =>
           Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
    -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
            Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k,
            Bounded l, Bounded m, Bounded n) =>
           Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
    -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
            Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k,
            Bounded l, Bounded m) =>
           Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m)
    -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
            Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k,
            Bounded l) =>
           Bounded (a, b, c, d, e, f, g, h, i, j, k, l)
    -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
            Bounded f, Bounded g, Bounded h, Bounded i, Bounded j,
            Bounded k) =>
           Bounded (a, b, c, d, e, f, g, h, i, j, k)
    -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
            Bounded f, Bounded g, Bounded h, Bounded i, Bounded j) =>
           Bounded (a, b, c, d, e, f, g, h, i, j)
    -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
            Bounded f, Bounded g, Bounded h, Bounded i) =>
           Bounded (a, b, c, d, e, f, g, h, i)
    -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
            Bounded f, Bounded g, Bounded h) =>
           Bounded (a, b, c, d, e, f, g, h)
    -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
            Bounded f, Bounded g) =>
           Bounded (a, b, c, d, e, f, g)
    -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
            Bounded f) =>
           Bounded (a, b, c, d, e, f)
    -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e) =>
           Bounded (a, b, c, d, e)
    -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b, Bounded c, Bounded d) =>
           Bounded (a, b, c, d)
    -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b, Bounded c) => Bounded (a, b, c)
    -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b) => Bounded (a, b)
    -- Defined in ‘GHC.Enum’
  instance Bounded () -- Defined in ‘GHC.Enum’
  instance Enum GHC.Int.Int8 -- Defined in ‘GHC.Int’
  instance Enum GHC.Int.Int64 -- Defined in ‘GHC.Int’
  instance Enum GHC.Int.Int32 -- Defined in ‘GHC.Int’
  instance Enum GHC.Int.Int16 -- Defined in ‘GHC.Int’
  instance Enum GHC.Word.Word8 -- Defined in ‘GHC.Word’
  instance Enum GHC.Word.Word64 -- Defined in ‘GHC.Word’
  instance Enum GHC.Word.Word32 -- Defined in ‘GHC.Word’
  instance Enum GHC.Word.Word16 -- Defined in ‘GHC.Word’
  instance Enum Ordering -- Defined in ‘GHC.Enum’
  instance Enum Integer -- Defined in ‘GHC.Enum’
  instance Enum Int -- Defined in ‘GHC.Enum’
  instance Enum Char -- Defined in ‘GHC.Enum’
  instance Enum Bool -- Defined in ‘GHC.Enum’
  instance Enum () -- Defined in ‘GHC.Enum’
  instance Enum GHC.Types.Word -- Defined in ‘GHC.Real’
  instance Integral a => Enum (GHC.Real.Ratio a)
    -- Defined in ‘GHC.Real’
  instance Enum Float -- Defined in ‘GHC.Float’
  instance Enum Double -- Defined in ‘GHC.Float’
  instance Eq (GHC.IOArray.IOArray i e) -- Defined in ‘GHC.IOArray’
  instance Eq GHC.Int.Int8 -- Defined in ‘GHC.Int’
  instance Eq GHC.Int.Int64 -- Defined in ‘GHC.Int’
  instance Eq GHC.Int.Int32 -- Defined in ‘GHC.Int’
  instance Eq GHC.Int.Int16 -- Defined in ‘GHC.Int’
  instance Eq (GHC.Ptr.Ptr a) -- Defined in ‘GHC.Ptr’
  instance Eq (GHC.Ptr.FunPtr a) -- Defined in ‘GHC.Ptr’
  instance Eq (GHC.Stable.StablePtr a) -- Defined in ‘GHC.Stable’
  instance Eq GHC.Word.Word8 -- Defined in ‘GHC.Word’
  instance Eq GHC.Word.Word64 -- Defined in ‘GHC.Word’
  instance Eq GHC.Word.Word32 -- Defined in ‘GHC.Word’
  instance Eq GHC.Word.Word16 -- Defined in ‘GHC.Word’
  instance Eq Integer -- Defined in ‘integer-gmp:GHC.Integer.Type’
  instance Eq a => Eq (Control.Applicative.ZipList a)
    -- Defined in ‘Control.Applicative’
  instance (GHC.Arr.Ix ix, Eq e, Data.Array.Base.IArray UArray e) =>
           Eq (UArray ix e)
    -- Defined in ‘Data.Array.Base’
  instance Eq (Data.Array.Base.STUArray s i e)
    -- Defined in ‘Data.Array.Base’
  instance Eq (GHC.Arr.STArray s i e) -- Defined in ‘GHC.Arr’
  instance (GHC.Arr.Ix i, Eq e) => Eq (Array i e)
    -- Defined in ‘GHC.Arr’
  instance Eq a => Eq (GHC.Real.Ratio a) -- Defined in ‘GHC.Real’
  instance Floating Float -- Defined in ‘GHC.Float’
  instance Floating Double -- Defined in ‘GHC.Float’
  instance Integral a => Fractional (GHC.Real.Ratio a)
    -- Defined in ‘GHC.Real’
  instance Fractional Float -- Defined in ‘GHC.Float’
  instance Fractional Double -- Defined in ‘GHC.Float’
  instance Integral GHC.Int.Int8 -- Defined in ‘GHC.Int’
  instance Integral GHC.Int.Int64 -- Defined in ‘GHC.Int’
  instance Integral GHC.Int.Int32 -- Defined in ‘GHC.Int’
  instance Integral GHC.Int.Int16 -- Defined in ‘GHC.Int’
  instance Integral GHC.Word.Word8 -- Defined in ‘GHC.Word’
  instance Integral GHC.Word.Word64 -- Defined in ‘GHC.Word’
  instance Integral GHC.Word.Word32 -- Defined in ‘GHC.Word’
  instance Integral GHC.Word.Word16 -- Defined in ‘GHC.Word’
  instance Integral GHC.Types.Word -- Defined in ‘GHC.Real’
  instance Integral Integer -- Defined in ‘GHC.Real’
  instance Integral Int -- Defined in ‘GHC.Real’
  instance Monad (base:Control.Monad.ST.Lazy.Imp.ST s)
    -- Defined in ‘base:Control.Monad.ST.Lazy.Imp’
  instance Monad (GHC.ST.ST s) -- Defined in ‘GHC.ST’
  instance Monad m => Monad (Control.Applicative.WrappedMonad m)
    -- Defined in ‘Control.Applicative’
  instance Monad [] -- Defined in ‘GHC.Base’
  instance Monad IO -- Defined in ‘GHC.Base’
  instance Monad ((->) r) -- Defined in ‘GHC.Base’
  instance Functor (base:Control.Monad.ST.Lazy.Imp.ST s)
    -- Defined in ‘base:Control.Monad.ST.Lazy.Imp’
  instance Functor (GHC.ST.ST s) -- Defined in ‘GHC.ST’
  instance Functor Control.Applicative.ZipList
    -- Defined in ‘Control.Applicative’
  instance Monad m => Functor (Control.Applicative.WrappedMonad m)
    -- Defined in ‘Control.Applicative’
  instance Control.Arrow.Arrow a =>
           Functor (Control.Applicative.WrappedArrow a b)
    -- Defined in ‘Control.Applicative’
  instance Functor (Control.Applicative.Const m)
    -- Defined in ‘Control.Applicative’
  instance Functor [] -- Defined in ‘GHC.Base’
  instance Functor IO -- Defined in ‘GHC.Base’
  instance Functor ((->) r) -- Defined in ‘GHC.Base’
  instance Functor ((,) a) -- Defined in ‘GHC.Base’
  instance GHC.Arr.Ix i => Functor (Array i) -- Defined in ‘GHC.Arr’
  instance Num GHC.Int.Int8 -- Defined in ‘GHC.Int’
  instance Num GHC.Int.Int64 -- Defined in ‘GHC.Int’
  instance Num GHC.Int.Int32 -- Defined in ‘GHC.Int’
  instance Num GHC.Int.Int16 -- Defined in ‘GHC.Int’
  instance Num GHC.Word.Word8 -- Defined in ‘GHC.Word’
  instance Num GHC.Word.Word64 -- Defined in ‘GHC.Word’
  instance Num GHC.Word.Word32 -- Defined in ‘GHC.Word’
  instance Num GHC.Word.Word16 -- Defined in ‘GHC.Word’
  instance Num GHC.Types.Word -- Defined in ‘GHC.Num’
  instance Num Integer -- Defined in ‘GHC.Num’
  instance Num Int -- Defined in ‘GHC.Num’
  instance Integral a => Num (GHC.Real.Ratio a)
    -- Defined in ‘GHC.Real’
  instance Num Float -- Defined in ‘GHC.Float’
  instance Num Double -- Defined in ‘GHC.Float’
  instance Ord GHC.Int.Int8 -- Defined in ‘GHC.Int’
  instance Ord GHC.Int.Int64 -- Defined in ‘GHC.Int’
  instance Ord GHC.Int.Int32 -- Defined in ‘GHC.Int’
  instance Ord GHC.Int.Int16 -- Defined in ‘GHC.Int’
  instance Ord (GHC.Ptr.Ptr a) -- Defined in ‘GHC.Ptr’
  instance Ord (GHC.Ptr.FunPtr a) -- Defined in ‘GHC.Ptr’
  instance Ord GHC.Word.Word8 -- Defined in ‘GHC.Word’
  instance Ord GHC.Word.Word64 -- Defined in ‘GHC.Word’
  instance Ord GHC.Word.Word32 -- Defined in ‘GHC.Word’
  instance Ord GHC.Word.Word16 -- Defined in ‘GHC.Word’
  instance Ord Integer -- Defined in ‘integer-gmp:GHC.Integer.Type’
  instance Ord a => Ord (Control.Applicative.ZipList a)
    -- Defined in ‘Control.Applicative’
  instance (GHC.Arr.Ix ix, Ord e, Data.Array.Base.IArray UArray e) =>
           Ord (UArray ix e)
    -- Defined in ‘Data.Array.Base’
  instance (GHC.Arr.Ix i, Ord e) => Ord (Array i e)
    -- Defined in ‘GHC.Arr’
  instance Integral a => Ord (GHC.Real.Ratio a)
    -- Defined in ‘GHC.Real’
  instance Read GHC.Int.Int8 -- Defined in ‘GHC.Int’
  instance Read GHC.Int.Int64 -- Defined in ‘GHC.Int’
  instance Read GHC.Int.Int32 -- Defined in ‘GHC.Int’
  instance Read GHC.Int.Int16 -- Defined in ‘GHC.Int’
  instance Read GHC.Word.Word8 -- Defined in ‘GHC.Word’
  instance Read GHC.Word.Word64 -- Defined in ‘GHC.Word’
  instance Read GHC.Word.Word32 -- Defined in ‘GHC.Word’
  instance Read GHC.Word.Word16 -- Defined in ‘GHC.Word’
  instance Read a => Read (Control.Applicative.ZipList a)
    -- Defined in ‘Control.Applicative’
  instance Real GHC.Int.Int8 -- Defined in ‘GHC.Int’
  instance Real GHC.Int.Int64 -- Defined in ‘GHC.Int’
  instance Real GHC.Int.Int32 -- Defined in ‘GHC.Int’
  instance Real GHC.Int.Int16 -- Defined in ‘GHC.Int’
  instance Real GHC.Word.Word8 -- Defined in ‘GHC.Word’
  instance Real GHC.Word.Word64 -- Defined in ‘GHC.Word’
  instance Real GHC.Word.Word32 -- Defined in ‘GHC.Word’
  instance Real GHC.Word.Word16 -- Defined in ‘GHC.Word’
  instance Real GHC.Types.Word -- Defined in ‘GHC.Real’
  instance Integral a => Real (GHC.Real.Ratio a)
    -- Defined in ‘GHC.Real’
  instance Real Integer -- Defined in ‘GHC.Real’
  instance Real Int -- Defined in ‘GHC.Real’
  instance Real Float -- Defined in ‘GHC.Float’
  instance Real Double -- Defined in ‘GHC.Float’
  instance RealFloat Float -- Defined in ‘GHC.Float’
  instance RealFloat Double -- Defined in ‘GHC.Float’
  instance Integral a => RealFrac (GHC.Real.Ratio a)
    -- Defined in ‘GHC.Real’
  instance RealFrac Float -- Defined in ‘GHC.Float’
  instance RealFrac Double -- Defined in ‘GHC.Float’
  instance Show GHC.Int.Int8 -- Defined in ‘GHC.Int’
  instance Show GHC.Int.Int64 -- Defined in ‘GHC.Int’
  instance Show GHC.Int.Int32 -- Defined in ‘GHC.Int’
  instance Show GHC.Int.Int16 -- Defined in ‘GHC.Int’
  instance Show (GHC.Ptr.Ptr a) -- Defined in ‘GHC.Ptr’
  instance Show (GHC.Ptr.FunPtr a) -- Defined in ‘GHC.Ptr’
  instance Show GHC.Word.Word8 -- Defined in ‘GHC.Word’
  instance Show GHC.Word.Word64 -- Defined in ‘GHC.Word’
  instance Show GHC.Word.Word32 -- Defined in ‘GHC.Word’
  instance Show GHC.Word.Word16 -- Defined in ‘GHC.Word’
  instance Show (GHC.ST.ST s a) -- Defined in ‘GHC.ST’
  instance Show a => Show (Control.Applicative.ZipList a)
    -- Defined in ‘Control.Applicative’
  instance (GHC.Arr.Ix ix, Show ix, Show e,
            Data.Array.Base.IArray UArray e) =>
           Show (UArray ix e)
    -- Defined in ‘Data.Array.Base’
  instance (GHC.Arr.Ix a, Show a, Show b) => Show (Array a b)
    -- Defined in ‘GHC.Arr’
  instance (Integral a, Show a) => Show (GHC.Real.Ratio a)
    -- Defined in ‘GHC.Real’
  instance Show Float -- Defined in ‘GHC.Float’
  instance Show Double -- Defined in ‘GHC.Float’
  instance GHC.Arr.Ix GHC.Int.Int8 -- Defined in ‘GHC.Int’
  instance GHC.Arr.Ix GHC.Int.Int64 -- Defined in ‘GHC.Int’
  instance GHC.Arr.Ix GHC.Int.Int32 -- Defined in ‘GHC.Int’
  instance GHC.Arr.Ix GHC.Int.Int16 -- Defined in ‘GHC.Int’
  instance GHC.Arr.Ix GHC.Word.Word8 -- Defined in ‘GHC.Word’
  instance GHC.Arr.Ix GHC.Word.Word64 -- Defined in ‘GHC.Word’
  instance GHC.Arr.Ix GHC.Word.Word32 -- Defined in ‘GHC.Word’
  instance GHC.Arr.Ix GHC.Word.Word16 -- Defined in ‘GHC.Word’
  instance GHC.Arr.Ix GHC.Types.Word -- Defined in ‘GHC.Arr’
  instance GHC.Arr.Ix Ordering -- Defined in ‘GHC.Arr’
  instance GHC.Arr.Ix Integer -- Defined in ‘GHC.Arr’
  instance GHC.Arr.Ix Int -- Defined in ‘GHC.Arr’
  instance GHC.Arr.Ix Char -- Defined in ‘GHC.Arr’
  instance GHC.Arr.Ix Bool -- Defined in ‘GHC.Arr’
  instance (GHC.Arr.Ix a1, GHC.Arr.Ix a2, GHC.Arr.Ix a3,
            GHC.Arr.Ix a4, GHC.Arr.Ix a5) =>
           GHC.Arr.Ix (a1, a2, a3, a4, a5)
    -- Defined in ‘GHC.Arr’
  instance (GHC.Arr.Ix a1, GHC.Arr.Ix a2, GHC.Arr.Ix a3,
            GHC.Arr.Ix a4) =>
           GHC.Arr.Ix (a1, a2, a3, a4)
    -- Defined in ‘GHC.Arr’
  instance (GHC.Arr.Ix a1, GHC.Arr.Ix a2, GHC.Arr.Ix a3) =>
           GHC.Arr.Ix (a1, a2, a3)
    -- Defined in ‘GHC.Arr’
  instance (GHC.Arr.Ix a, GHC.Arr.Ix b) => GHC.Arr.Ix (a, b)
    -- Defined in ‘GHC.Arr’
  instance GHC.Arr.Ix () -- Defined in ‘GHC.Arr’
  instance Data.Typeable.Internal.Typeable GHC.IOArray.IOArray
    -- Defined in ‘GHC.IOArray’
  instance Data.Typeable.Internal.Typeable GHC.Int.Int8
    -- Defined in ‘GHC.Int’
  instance Data.Typeable.Internal.Typeable GHC.Int.Int64
    -- Defined in ‘GHC.Int’
  instance Data.Typeable.Internal.Typeable GHC.Int.Int32
    -- Defined in ‘GHC.Int’
  instance Data.Typeable.Internal.Typeable GHC.Int.Int16
    -- Defined in ‘GHC.Int’
  instance Data.Typeable.Internal.Typeable GHC.Stable.StablePtr
    -- Defined in ‘GHC.Stable’
  instance Data.Typeable.Internal.Typeable
             Control.Applicative.Applicative
    -- Defined in ‘Control.Applicative’
  instance Data.Typeable.Internal.Typeable
             Control.Applicative.Alternative
    -- Defined in ‘Control.Applicative’
  instance Data.Typeable.Internal.Typeable UArray
    -- Defined in ‘Data.Array.Base’
  instance Data.Typeable.Internal.Typeable Data.Array.Base.STUArray
    -- Defined in ‘Data.Array.Base’
  instance Control.Monad.Fix.MonadFix
             (base:Control.Monad.ST.Lazy.Imp.ST s)
    -- Defined in ‘base:Control.Monad.ST.Lazy.Imp’
  instance Control.Monad.MonadPlus [] -- Defined in ‘Control.Monad’
  instance Control.Monad.MonadPlus Maybe
    -- Defined in ‘Control.Monad’
  instance Control.Applicative.Applicative []
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative
             Control.Applicative.ZipList
    -- Defined in ‘Control.Applicative’
  instance Monad m =>
           Control.Applicative.Applicative
             (Control.Applicative.WrappedMonad m)
    -- Defined in ‘Control.Applicative’
  instance Control.Arrow.Arrow a =>
           Control.Applicative.Applicative
             (Control.Applicative.WrappedArrow a b)
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative GHC.Conc.Sync.STM
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative (GHC.ST.ST s)
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative
             (base:Control.Monad.ST.Lazy.Imp.ST s)
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative
             Text.ParserCombinators.ReadPrec.ReadPrec
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative
             Text.ParserCombinators.ReadP.ReadP
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative Data.Proxy.Proxy
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative Maybe
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative IO
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative (Either e)
    -- Defined in ‘Control.Applicative’
  instance Data.Monoid.Monoid m =>
           Control.Applicative.Applicative (Control.Applicative.Const m)
    -- Defined in ‘Control.Applicative’
  instance Control.Arrow.Arrow a =>
           Control.Applicative.Applicative (Control.Arrow.ArrowMonad a)
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative ((->) a)
    -- Defined in ‘Control.Applicative’
  instance Data.Monoid.Monoid a =>
           Control.Applicative.Applicative ((,) a)
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Generic (Control.Applicative.ZipList a)
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Generic
             (Control.Applicative.WrappedMonad m a)
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Generic
             (Control.Applicative.WrappedArrow a b c)
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Generic (Control.Applicative.Const a b)
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Generic1 Control.Applicative.ZipList
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Generic1 (Control.Applicative.WrappedMonad m)
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Generic1
             (Control.Applicative.WrappedArrow a b)
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Generic1 (Control.Applicative.Const a)
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Datatype Control.Applicative.D1ZipList
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Datatype Control.Applicative.D1WrappedMonad
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Datatype Control.Applicative.D1WrappedArrow
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Datatype Control.Applicative.D1Const
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Constructor Control.Applicative.C1_0ZipList
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Constructor
             Control.Applicative.C1_0WrappedMonad
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Constructor
             Control.Applicative.C1_0WrappedArrow
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Constructor Control.Applicative.C1_0Const
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Selector Control.Applicative.S1_0_0ZipList
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Selector
             Control.Applicative.S1_0_0WrappedMonad
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Selector
             Control.Applicative.S1_0_0WrappedArrow
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Selector Control.Applicative.S1_0_0Const
    -- Defined in ‘Control.Applicative’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) GHC.Types.Word (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) GHC.Word.Word8 (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) GHC.Word.Word64 (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) GHC.Word.Word32 (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) GHC.Word.Word16 (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) (GHC.Stable.StablePtr a) (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) (GHC.Ptr.Ptr a) (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) Int (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) GHC.Int.Int8 (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) GHC.Int.Int64 (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) GHC.Int.Int32 (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) GHC.Int.Int16 (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) (GHC.Ptr.FunPtr a) (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) Float (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) Double (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) Char (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) Bool (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray (GHC.Arr.STArray s) e (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (GHC.Arr.STArray s) e (base:Control.Monad.ST.Lazy.Imp.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray GHC.IOArray.IOArray e IO
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray GHC.Word.Word8
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray GHC.Word.Word64
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray GHC.Word.Word32
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray GHC.Word.Word16
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray GHC.Types.Word
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray (GHC.Stable.StablePtr a)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray (GHC.Ptr.Ptr a)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray GHC.Int.Int8
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray GHC.Int.Int64
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray GHC.Int.Int32
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray GHC.Int.Int16
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray Int
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray (GHC.Ptr.FunPtr a)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray Float
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray Double
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray Char
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray Bool
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray Array e
    -- Defined in ‘Data.Array.Base’
  instance Data.Monoid.Monoid a =>
           Data.Monoid.Monoid (Control.Applicative.Const a b)
    -- Defined in ‘Control.Applicative’
  instance Data.Bits.FiniteBits GHC.Int.Int8 -- Defined in ‘GHC.Int’
  instance Data.Bits.FiniteBits GHC.Int.Int64 -- Defined in ‘GHC.Int’
  instance Data.Bits.FiniteBits GHC.Int.Int32 -- Defined in ‘GHC.Int’
  instance Data.Bits.FiniteBits GHC.Int.Int16 -- Defined in ‘GHC.Int’
  instance Data.Bits.FiniteBits GHC.Word.Word8
    -- Defined in ‘GHC.Word’
  instance Data.Bits.FiniteBits GHC.Word.Word64
    -- Defined in ‘GHC.Word’
  instance Data.Bits.FiniteBits GHC.Word.Word32
    -- Defined in ‘GHC.Word’
  instance Data.Bits.FiniteBits GHC.Word.Word16
    -- Defined in ‘GHC.Word’
  instance Data.Bits.Bits GHC.Int.Int8 -- Defined in ‘GHC.Int’
  instance Data.Bits.Bits GHC.Int.Int64 -- Defined in ‘GHC.Int’
  instance Data.Bits.Bits GHC.Int.Int32 -- Defined in ‘GHC.Int’
  instance Data.Bits.Bits GHC.Int.Int16 -- Defined in ‘GHC.Int’
  instance Data.Bits.Bits GHC.Word.Word8 -- Defined in ‘GHC.Word’
  instance Data.Bits.Bits GHC.Word.Word64 -- Defined in ‘GHC.Word’
  instance Data.Bits.Bits GHC.Word.Word32 -- Defined in ‘GHC.Word’
  instance Data.Bits.Bits GHC.Word.Word16 -- Defined in ‘GHC.Word’
End InstEnvs }
InstEnvs (Internal) {
End InstEnvs }
famInstEnvs (External) {
  type GHC.Generics.Rep Char
    ~ GHC.Generics.D1
        GHC.Generics.D_Char
        (GHC.Generics.C1
           GHC.Generics.C_Char
           (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 Char)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep Double
    ~ GHC.Generics.D1
        GHC.Generics.D_Double
        (GHC.Generics.C1
           GHC.Generics.C_Double
           (GHC.Generics.S1
              GHC.Generics.NoSelector (GHC.Generics.Rec0 Double)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep Float
    ~ GHC.Generics.D1
        GHC.Generics.D_Float
        (GHC.Generics.C1
           GHC.Generics.C_Float
           (GHC.Generics.S1
              GHC.Generics.NoSelector (GHC.Generics.Rec0 Float)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep Int
    ~ GHC.Generics.D1
        GHC.Generics.D_Int
        (GHC.Generics.C1
           GHC.Generics.C_Int
           (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 Int)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (Data.Proxy.Proxy t)
    ~ GHC.Generics.D1
        GHC.Generics.D1Proxy
        (GHC.Generics.C1 GHC.Generics.C1_0Proxy GHC.Generics.U1)
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (a, b, c, d, e, f, g)
    ~ GHC.Generics.D1
        GHC.Generics.D1(,,,,,,)
        (GHC.Generics.C1
           GHC.Generics.C1_0(,,,,,,)
           ((GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
             GHC.Generics.:*: (GHC.Generics.S1
                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 b)
                               GHC.Generics.:*: GHC.Generics.S1
                                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 c)))
            GHC.Generics.:*: ((GHC.Generics.S1
                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 d)
                               GHC.Generics.:*: GHC.Generics.S1
                                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 e))
                              GHC.Generics.:*: (GHC.Generics.S1
                                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 f)
                                                GHC.Generics.:*: GHC.Generics.S1
                                                                   GHC.Generics.NoSelector
                                                                   (GHC.Generics.Rec0 g)))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (a, b, c, d, e, f)
    ~ GHC.Generics.D1
        GHC.Generics.D1(,,,,,)
        (GHC.Generics.C1
           GHC.Generics.C1_0(,,,,,)
           ((GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
             GHC.Generics.:*: (GHC.Generics.S1
                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 b)
                               GHC.Generics.:*: GHC.Generics.S1
                                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 c)))
            GHC.Generics.:*: (GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 d)
                              GHC.Generics.:*: (GHC.Generics.S1
                                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 e)
                                                GHC.Generics.:*: GHC.Generics.S1
                                                                   GHC.Generics.NoSelector
                                                                   (GHC.Generics.Rec0 f)))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (a, b, c, d, e)
    ~ GHC.Generics.D1
        GHC.Generics.D1(,,,,)
        (GHC.Generics.C1
           GHC.Generics.C1_0(,,,,)
           ((GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
             GHC.Generics.:*: GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 b))
            GHC.Generics.:*: (GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 c)
                              GHC.Generics.:*: (GHC.Generics.S1
                                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 d)
                                                GHC.Generics.:*: GHC.Generics.S1
                                                                   GHC.Generics.NoSelector
                                                                   (GHC.Generics.Rec0 e)))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (a, b, c, d)
    ~ GHC.Generics.D1
        GHC.Generics.D1(,,,)
        (GHC.Generics.C1
           GHC.Generics.C1_0(,,,)
           ((GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
             GHC.Generics.:*: GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 b))
            GHC.Generics.:*: (GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 c)
                              GHC.Generics.:*: GHC.Generics.S1
                                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 d))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (a, b, c)
    ~ GHC.Generics.D1
        GHC.Generics.D1(,,)
        (GHC.Generics.C1
           GHC.Generics.C1_0(,,)
           (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
            GHC.Generics.:*: (GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 b)
                              GHC.Generics.:*: GHC.Generics.S1
                                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 c))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (a, b)
    ~ GHC.Generics.D1
        GHC.Generics.D1(,)
        (GHC.Generics.C1
           GHC.Generics.C1_0(,)
           (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
            GHC.Generics.:*: GHC.Generics.S1
                               GHC.Generics.NoSelector (GHC.Generics.Rec0 b)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep ()
    ~ GHC.Generics.D1
        GHC.Generics.D1()
        (GHC.Generics.C1 GHC.Generics.C1_0() GHC.Generics.U1)
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep Ordering
    ~ GHC.Generics.D1
        GHC.Generics.D1Ordering
        (GHC.Generics.C1 GHC.Generics.C1_0Ordering GHC.Generics.U1
         GHC.Generics.:+: (GHC.Generics.C1
                             GHC.Generics.C1_1Ordering GHC.Generics.U1
                           GHC.Generics.:+: GHC.Generics.C1
                                              GHC.Generics.C1_2Ordering GHC.Generics.U1))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep Bool
    ~ GHC.Generics.D1
        GHC.Generics.D1Bool
        (GHC.Generics.C1 GHC.Generics.C1_0Bool GHC.Generics.U1
         GHC.Generics.:+: GHC.Generics.C1
                            GHC.Generics.C1_1Bool GHC.Generics.U1)
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (Either a b)
    ~ GHC.Generics.D1
        GHC.Generics.D1Either
        (GHC.Generics.C1
           GHC.Generics.C1_0Either
           (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a))
         GHC.Generics.:+: GHC.Generics.C1
                            GHC.Generics.C1_1Either
                            (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 b)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (Maybe a)
    ~ GHC.Generics.D1
        GHC.Generics.D1Maybe
        (GHC.Generics.C1 GHC.Generics.C1_0Maybe GHC.Generics.U1
         GHC.Generics.:+: GHC.Generics.C1
                            GHC.Generics.C1_1Maybe
                            (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep [a]
    ~ GHC.Generics.D1
        GHC.Generics.D1[]
        (GHC.Generics.C1 GHC.Generics.C1_0[] GHC.Generics.U1
         GHC.Generics.:+: GHC.Generics.C1
                            GHC.Generics.C1_1[]
                            (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
                             GHC.Generics.:*: GHC.Generics.S1
                                                GHC.Generics.NoSelector (GHC.Generics.Rec0 [a])))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (GHC.Generics.U1 p)
    ~ GHC.Generics.D1
        GHC.Generics.D1U1
        (GHC.Generics.C1 GHC.Generics.C1_0U1 GHC.Generics.U1)
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (GHC.Generics.Par1 p)
    ~ GHC.Generics.D1
        GHC.Generics.D1Par1
        (GHC.Generics.C1
           GHC.Generics.C1_0Par1
           (GHC.Generics.S1 GHC.Generics.S1_0_0Par1 (GHC.Generics.Rec0 p)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (GHC.Generics.Rec1 f p)
    ~ GHC.Generics.D1
        GHC.Generics.D1Rec1
        (GHC.Generics.C1
           GHC.Generics.C1_0Rec1
           (GHC.Generics.S1
              GHC.Generics.S1_0_0Rec1 (GHC.Generics.Rec0 (f p))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (GHC.Generics.K1 i c p)
    ~ GHC.Generics.D1
        GHC.Generics.D1K1
        (GHC.Generics.C1
           GHC.Generics.C1_0K1
           (GHC.Generics.S1 GHC.Generics.S1_0_0K1 (GHC.Generics.Rec0 c)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (GHC.Generics.M1 i c f p)
    ~ GHC.Generics.D1
        GHC.Generics.D1M1
        (GHC.Generics.C1
           GHC.Generics.C1_0M1
           (GHC.Generics.S1 GHC.Generics.S1_0_0M1 (GHC.Generics.Rec0 (f p))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep ((GHC.Generics.:+:) f g p)
    ~ GHC.Generics.D1
        GHC.Generics.D1:+:
        (GHC.Generics.C1
           GHC.Generics.C1_0:+:
           (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 (f p)))
         GHC.Generics.:+: GHC.Generics.C1
                            GHC.Generics.C1_1:+:
                            (GHC.Generics.S1
                               GHC.Generics.NoSelector (GHC.Generics.Rec0 (g p))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep ((GHC.Generics.:*:) f g p)
    ~ GHC.Generics.D1
        GHC.Generics.D1:*:
        (GHC.Generics.C1
           GHC.Generics.C1_0:*:
           (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 (f p))
            GHC.Generics.:*: GHC.Generics.S1
                               GHC.Generics.NoSelector (GHC.Generics.Rec0 (g p))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep ((GHC.Generics.:.:) f g p)
    ~ GHC.Generics.D1
        GHC.Generics.D1:.:
        (GHC.Generics.C1
           GHC.Generics.C1_0:.:
           (GHC.Generics.S1
              GHC.Generics.S1_0_0:.: (GHC.Generics.Rec0 (f (g p)))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep GHC.Generics.Associativity
    ~ GHC.Generics.D1
        GHC.Generics.D1Associativity
        (GHC.Generics.C1 GHC.Generics.C1_0Associativity GHC.Generics.U1
         GHC.Generics.:+: (GHC.Generics.C1
                             GHC.Generics.C1_1Associativity GHC.Generics.U1
                           GHC.Generics.:+: GHC.Generics.C1
                                              GHC.Generics.C1_2Associativity GHC.Generics.U1))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep GHC.Generics.Fixity
    ~ GHC.Generics.D1
        GHC.Generics.D1Fixity
        (GHC.Generics.C1 GHC.Generics.C1_0Fixity GHC.Generics.U1
         GHC.Generics.:+: GHC.Generics.C1
                            GHC.Generics.C1_1Fixity
                            (GHC.Generics.S1
                               GHC.Generics.NoSelector
                               (GHC.Generics.Rec0 GHC.Generics.Associativity)
                             GHC.Generics.:*: GHC.Generics.S1
                                                GHC.Generics.NoSelector (GHC.Generics.Rec0 Int)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep GHC.Generics.Arity
    ~ GHC.Generics.D1
        GHC.Generics.D1Arity
        (GHC.Generics.C1 GHC.Generics.C1_0Arity GHC.Generics.U1
         GHC.Generics.:+: GHC.Generics.C1
                            GHC.Generics.C1_1Arity
                            (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 Int)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (Data.Monoid.Dual a)
    ~ GHC.Generics.D1
        Data.Monoid.D1Dual
        (GHC.Generics.C1
           Data.Monoid.C1_0Dual
           (GHC.Generics.S1 Data.Monoid.S1_0_0Dual (GHC.Generics.Rec0 a)))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep (Data.Monoid.Endo a)
    ~ GHC.Generics.D1
        Data.Monoid.D1Endo
        (GHC.Generics.C1
           Data.Monoid.C1_0Endo
           (GHC.Generics.S1
              Data.Monoid.S1_0_0Endo (GHC.Generics.Rec0 (a -> a))))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep Data.Monoid.All
    ~ GHC.Generics.D1
        Data.Monoid.D1All
        (GHC.Generics.C1
           Data.Monoid.C1_0All
           (GHC.Generics.S1 Data.Monoid.S1_0_0All (GHC.Generics.Rec0 Bool)))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep Data.Monoid.Any
    ~ GHC.Generics.D1
        Data.Monoid.D1Any
        (GHC.Generics.C1
           Data.Monoid.C1_0Any
           (GHC.Generics.S1 Data.Monoid.S1_0_0Any (GHC.Generics.Rec0 Bool)))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep (Data.Monoid.Sum a)
    ~ GHC.Generics.D1
        Data.Monoid.D1Sum
        (GHC.Generics.C1
           Data.Monoid.C1_0Sum
           (GHC.Generics.S1 Data.Monoid.S1_0_0Sum (GHC.Generics.Rec0 a)))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep (Data.Monoid.Product a)
    ~ GHC.Generics.D1
        Data.Monoid.D1Product
        (GHC.Generics.C1
           Data.Monoid.C1_0Product
           (GHC.Generics.S1 Data.Monoid.S1_0_0Product (GHC.Generics.Rec0 a)))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep (Data.Monoid.First a)
    ~ GHC.Generics.D1
        Data.Monoid.D1First
        (GHC.Generics.C1
           Data.Monoid.C1_0First
           (GHC.Generics.S1
              Data.Monoid.S1_0_0First (GHC.Generics.Rec0 (Maybe a))))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep (Data.Monoid.Last a)
    ~ GHC.Generics.D1
        Data.Monoid.D1Last
        (GHC.Generics.C1
           Data.Monoid.C1_0Last
           (GHC.Generics.S1
              Data.Monoid.S1_0_0Last (GHC.Generics.Rec0 (Maybe a))))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep (Control.Applicative.Const a b)
    ~ GHC.Generics.D1
        Control.Applicative.D1Const
        (GHC.Generics.C1
           Control.Applicative.C1_0Const
           (GHC.Generics.S1
              Control.Applicative.S1_0_0Const (GHC.Generics.Rec0 a)))
    -- Defined in ‘Control.Applicative’
  type GHC.Generics.Rep (Control.Applicative.WrappedMonad m a)
    ~ GHC.Generics.D1
        Control.Applicative.D1WrappedMonad
        (GHC.Generics.C1
           Control.Applicative.C1_0WrappedMonad
           (GHC.Generics.S1
              Control.Applicative.S1_0_0WrappedMonad (GHC.Generics.Rec0 (m a))))
    -- Defined in ‘Control.Applicative’
  type GHC.Generics.Rep (Control.Applicative.WrappedArrow a b c)
    ~ GHC.Generics.D1
        Control.Applicative.D1WrappedArrow
        (GHC.Generics.C1
           Control.Applicative.C1_0WrappedArrow
           (GHC.Generics.S1
              Control.Applicative.S1_0_0WrappedArrow
              (GHC.Generics.Rec0 (a b c))))
    -- Defined in ‘Control.Applicative’
  type GHC.Generics.Rep (Control.Applicative.ZipList a)
    ~ GHC.Generics.D1
        Control.Applicative.D1ZipList
        (GHC.Generics.C1
           Control.Applicative.C1_0ZipList
           (GHC.Generics.S1
              Control.Applicative.S1_0_0ZipList (GHC.Generics.Rec0 [a])))
    -- Defined in ‘Control.Applicative’
  type GHC.Generics.Rep1 ((,,,,,,) a b c d e f)
    ~ GHC.Generics.D1
        GHC.Generics.D1(,,,,,,)
        (GHC.Generics.C1
           GHC.Generics.C1_0(,,,,,,)
           ((GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
             GHC.Generics.:*: (GHC.Generics.S1
                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 b)
                               GHC.Generics.:*: GHC.Generics.S1
                                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 c)))
            GHC.Generics.:*: ((GHC.Generics.S1
                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 d)
                               GHC.Generics.:*: GHC.Generics.S1
                                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 e))
                              GHC.Generics.:*: (GHC.Generics.S1
                                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 f)
                                                GHC.Generics.:*: GHC.Generics.S1
                                                                   GHC.Generics.NoSelector
                                                                   GHC.Generics.Par1))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 ((,,,,,) a b c d e)
    ~ GHC.Generics.D1
        GHC.Generics.D1(,,,,,)
        (GHC.Generics.C1
           GHC.Generics.C1_0(,,,,,)
           ((GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
             GHC.Generics.:*: (GHC.Generics.S1
                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 b)
                               GHC.Generics.:*: GHC.Generics.S1
                                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 c)))
            GHC.Generics.:*: (GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 d)
                              GHC.Generics.:*: (GHC.Generics.S1
                                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 e)
                                                GHC.Generics.:*: GHC.Generics.S1
                                                                   GHC.Generics.NoSelector
                                                                   GHC.Generics.Par1))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 ((,,,,) a b c d)
    ~ GHC.Generics.D1
        GHC.Generics.D1(,,,,)
        (GHC.Generics.C1
           GHC.Generics.C1_0(,,,,)
           ((GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
             GHC.Generics.:*: GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 b))
            GHC.Generics.:*: (GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 c)
                              GHC.Generics.:*: (GHC.Generics.S1
                                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 d)
                                                GHC.Generics.:*: GHC.Generics.S1
                                                                   GHC.Generics.NoSelector
                                                                   GHC.Generics.Par1))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 ((,,,) a b c)
    ~ GHC.Generics.D1
        GHC.Generics.D1(,,,)
        (GHC.Generics.C1
           GHC.Generics.C1_0(,,,)
           ((GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
             GHC.Generics.:*: GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 b))
            GHC.Generics.:*: (GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 c)
                              GHC.Generics.:*: GHC.Generics.S1
                                                 GHC.Generics.NoSelector GHC.Generics.Par1)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 ((,,) a b)
    ~ GHC.Generics.D1
        GHC.Generics.D1(,,)
        (GHC.Generics.C1
           GHC.Generics.C1_0(,,)
           (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
            GHC.Generics.:*: (GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 b)
                              GHC.Generics.:*: GHC.Generics.S1
                                                 GHC.Generics.NoSelector GHC.Generics.Par1)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 ((,) a)
    ~ GHC.Generics.D1
        GHC.Generics.D1(,)
        (GHC.Generics.C1
           GHC.Generics.C1_0(,)
           (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
            GHC.Generics.:*: GHC.Generics.S1
                               GHC.Generics.NoSelector GHC.Generics.Par1))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 (Either a)
    ~ GHC.Generics.D1
        GHC.Generics.D1Either
        (GHC.Generics.C1
           GHC.Generics.C1_0Either
           (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a))
         GHC.Generics.:+: GHC.Generics.C1
                            GHC.Generics.C1_1Either
                            (GHC.Generics.S1 GHC.Generics.NoSelector GHC.Generics.Par1))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 Maybe
    ~ GHC.Generics.D1
        GHC.Generics.D1Maybe
        (GHC.Generics.C1 GHC.Generics.C1_0Maybe GHC.Generics.U1
         GHC.Generics.:+: GHC.Generics.C1
                            GHC.Generics.C1_1Maybe
                            (GHC.Generics.S1 GHC.Generics.NoSelector GHC.Generics.Par1))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 []
    ~ GHC.Generics.D1
        GHC.Generics.D1[]
        (GHC.Generics.C1 GHC.Generics.C1_0[] GHC.Generics.U1
         GHC.Generics.:+: GHC.Generics.C1
                            GHC.Generics.C1_1[]
                            (GHC.Generics.S1 GHC.Generics.NoSelector GHC.Generics.Par1
                             GHC.Generics.:*: GHC.Generics.S1
                                                GHC.Generics.NoSelector (GHC.Generics.Rec1 [])))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 Data.Monoid.Dual
    ~ GHC.Generics.D1
        Data.Monoid.D1Dual
        (GHC.Generics.C1
           Data.Monoid.C1_0Dual
           (GHC.Generics.S1 Data.Monoid.S1_0_0Dual GHC.Generics.Par1))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep1 Data.Monoid.Sum
    ~ GHC.Generics.D1
        Data.Monoid.D1Sum
        (GHC.Generics.C1
           Data.Monoid.C1_0Sum
           (GHC.Generics.S1 Data.Monoid.S1_0_0Sum GHC.Generics.Par1))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep1 Data.Monoid.Product
    ~ GHC.Generics.D1
        Data.Monoid.D1Product
        (GHC.Generics.C1
           Data.Monoid.C1_0Product
           (GHC.Generics.S1 Data.Monoid.S1_0_0Product GHC.Generics.Par1))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep1 Data.Monoid.First
    ~ GHC.Generics.D1
        Data.Monoid.D1First
        (GHC.Generics.C1
           Data.Monoid.C1_0First
           (GHC.Generics.S1
              Data.Monoid.S1_0_0First (GHC.Generics.Rec1 Maybe)))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep1 Data.Monoid.Last
    ~ GHC.Generics.D1
        Data.Monoid.D1Last
        (GHC.Generics.C1
           Data.Monoid.C1_0Last
           (GHC.Generics.S1 Data.Monoid.S1_0_0Last (GHC.Generics.Rec1 Maybe)))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep1 (Control.Applicative.Const a)
    ~ GHC.Generics.D1
        Control.Applicative.D1Const
        (GHC.Generics.C1
           Control.Applicative.C1_0Const
           (GHC.Generics.S1
              Control.Applicative.S1_0_0Const (GHC.Generics.Rec0 a)))
    -- Defined in ‘Control.Applicative’
  type GHC.Generics.Rep1 (Control.Applicative.WrappedMonad m)
    ~ GHC.Generics.D1
        Control.Applicative.D1WrappedMonad
        (GHC.Generics.C1
           Control.Applicative.C1_0WrappedMonad
           (GHC.Generics.S1
              Control.Applicative.S1_0_0WrappedMonad (GHC.Generics.Rec1 m)))
    -- Defined in ‘Control.Applicative’
  type GHC.Generics.Rep1 (Control.Applicative.WrappedArrow a b)
    ~ GHC.Generics.D1
        Control.Applicative.D1WrappedArrow
        (GHC.Generics.C1
           Control.Applicative.C1_0WrappedArrow
           (GHC.Generics.S1
              Control.Applicative.S1_0_0WrappedArrow (GHC.Generics.Rec1 (a b))))
    -- Defined in ‘Control.Applicative’
  type GHC.Generics.Rep1 Control.Applicative.ZipList
    ~ GHC.Generics.D1
        Control.Applicative.D1ZipList
        (GHC.Generics.C1
           Control.Applicative.C1_0ZipList
           (GHC.Generics.S1
              Control.Applicative.S1_0_0ZipList (GHC.Generics.Rec1 [])))
    -- Defined in ‘Control.Applicative’
  type instance a Data.Type.Equality.== b
    ~ Data.Either.EqEither a b
    -- Defined in ‘Data.Either’
End famInstEnvs }
famInstEnvs (Internal) {
End famInstEnvs }
originalCts (simplifyTop)
  fvars =  [(aqY, i_aqY), (aqZ, e_aqZ), (ar0, a_ar0), (ar6, i_ar6),
            (ar7, e_ar7), (ar8, a_ar8), (au2, a_au2), (auG, t_auG),
            (auI, a_auI), (auM, t_auM), (auQ, t_auQ), (auR, a_auR),
            (awT, a_awT), (awX, t_awX), (awY, t_awY), (awZ, t_awZ),
            (ax2, m_ax2), (ax4, a_ax4), (ax5, b_ax5), (axr, a_axr),
            (axs, i_axs), (axt, e_axt), (axu, m_axu), (axv, b_axv),
            (axC, m_axC), (axE, a_axE), (axI, t_axI)]
  wanted =  WC {wc_flat = [W] $dIArray_ar9 :: Data.Array.Base.IArray
                                                a_ar8
                                                e_ar7 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                          [W] $dIx_ara :: GHC.Arr.Ix
                                            i_ar6 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                          [W] cobox_arb :: ((i_ar6, i_ar6) -> [e_ar7] -> a_ar8 i_ar6 e_ar7)
                                           ~ ((Int, Int)
                                              -> [Double] -> FlatVector) [" a type equality (i_ar6,
                                                                                             i_ar6)
                                                                                            -> [e_ar7]
                                                                                            -> a_ar8 i_ar6 e_ar7
                                                                                            ~
                                                                                            (Int,
                                                                                             Int)
                                                                                            -> [Double]
                                                                                            -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
                          [W] $dNum_atO :: Num
                                             a_au2 [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                          [W] cobox_auJ :: Int ~ t_auG [" a type equality Int
                                                                          ~
                                                                          t_auG " p4.hs:14:21-29] (CNonCanonical)
                          [W] cobox_auK :: [a_au2] ~ [a_auI] [" a type equality [a_au2]
                                                                                ~
                                                                                [a_auI] " p4.hs:14:28-29] (CNonCanonical)
                          [W] cobox_auN :: [a_au2] ~ [t_auM] [" a type equality [a_au2]
                                                                                ~
                                                                                [t_auM] " p4.hs:16:61-62] (CNonCanonical)
                          [W] cobox_auO :: FlatVector
                                           ~ FlatVector [" a type equality FlatVector
                                                                           ~
                                                                           FlatVector " p4.hs:16:23-56] (CNonCanonical)
                          [W] cobox_auP :: t_auM ~ Int [" a type equality t_auM
                                                                          ~
                                                                          Int " p4.hs:16:41] (CNonCanonical)
                          [W] $dNum_auS :: Num
                                             a_auR [" the literal ‘1’ " p4.hs:16:51] (CNonCanonical)
                          [W] cobox_auT :: (Integer -> a_auR)
                                           ~ (Integer -> t_auQ) [" a type equality Integer -> a_auR
                                                                                   ~
                                                                                   Integer
                                                                                   -> t_auQ " p4.hs:16:51] (CNonCanonical)
                          [W] cobox_auU :: t_auM ~ t_auQ [" a type equality t_auM
                                                                            ~
                                                                            t_auQ " p4.hs:16:54] (CNonCanonical)
                          [W] $dEnum_awR :: Enum
                                              t_auQ [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CNonCanonical)
                          [W] cobox_awU :: Vector a_awT
                                           ~ Vector FlatVector [" a type equality Vector a_awT
                                                                                  ~
                                                                                  Vector
                                                                                    FlatVector " p4.hs:18:21-43] (CNonCanonical)
                          [W] cobox_awV :: t_auG ~ Int [" a type equality t_auG
                                                                          ~
                                                                          Int " p4.hs:18:35-37] (CNonCanonical)
                          [W] cobox_awW :: [FlatVector]
                                           ~ [a_awT] [" a type equality [FlatVector]
                                                                        ~
                                                                        [a_awT] " p4.hs:18:40-43] (CNonCanonical)
                          [W] $dMonad_ax3 :: Monad
                                               m_ax2 [" a do statement " p4.hs:19:11-23] (CNonCanonical)
                          [W] cobox_ax7 :: (m_ax2 a_ax4
                                            -> (a_ax4 -> m_ax2 b_ax5) -> m_ax2 b_ax5)
                                           ~ (t_awX
                                              -> (t_awY -> t_awZ)
                                              -> IO ()) [" a type equality m_ax2 a_ax4
                                                                           -> (a_ax4 -> m_ax2 b_ax5)
                                                                           -> m_ax2 b_ax5
                                                                           ~
                                                                           t_awX
                                                                           -> (t_awY -> t_awZ)
                                                                           -> IO
                                                                                () " p4.hs:19:11-23] (CNonCanonical)
                          [W] $dIx_axw :: GHC.Arr.Ix
                                            i_axs [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                          [W] $dIArray_axx :: Data.Array.Base.IArray
                                                a_axr
                                                e_axt [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                          [W] $dMArray_axy :: Data.Array.Base.MArray
                                                b_axv
                                                e_axt
                                                m_axu [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                          [W] cobox_axz :: m_axu (b_axv i_axs e_axt)
                                           ~ t_awX [" a type equality m_axu (b_axv i_axs e_axt)
                                                                      ~
                                                                      t_awX " p4.hs:19:16-23] (CNonCanonical)
                          [W] cobox_axA :: Vector FlatVector
                                           ~ a_axr i_axs e_axt [" a type equality Vector FlatVector
                                                                                  ~
                                                                                  a_axr i_axs e_axt " p4.hs:19:21-23] (CNonCanonical)
                          [W] $dMonad_axD :: Monad
                                               m_axC [" a use of ‘return’ " p4.hs:20:11-16] (CNonCanonical)
                          [W] cobox_axG :: m_axC a_axE ~ t_awZ [" a type equality m_axC a_axE
                                                                                  ~
                                                                                  t_awZ " p4.hs:20:11-19] (CNonCanonical)
                          [W] cobox_axH :: () ~ a_axE [" a type equality ()
                                                                         ~
                                                                         a_axE " p4.hs:20:18-19] (CNonCanonical)
                          [W] cobox_axJ :: IO () ~ IO t_axI [" a type equality IO ()
                                                                               ~
                                                                               IO
                                                                                 t_axI " p4.hs:13:1] (CNonCanonical)
                wc_impl = Implic {Untouchables = 1
                                  Skolems = a
                                  Flatten-skolems =
                                  No-eqs = False
                                  Given =
                                  Wanted = WC {wc_flat = [W] $dIArray_ar1 :: Data.Array.Base.IArray
                                                                               a_ar0
                                                                               e_aqZ [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                                         [W] $dIx_ar2 :: GHC.Arr.Ix
                                                                           i_aqY [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                                         [W] cobox_ar3 :: ((i_aqY, i_aqY)
                                                                           -> [e_aqZ]
                                                                           -> a_ar0 i_aqY e_aqZ)
                                                                          ~ ((Int, Int)
                                                                             -> [a]
                                                                             -> Vector
                                                                                  a) [" a type equality (i_aqY,
                                                                                                         i_aqY)
                                                                                                        -> [e_aqZ]
                                                                                                        -> a_ar0 i_aqY e_aqZ
                                                                                                        ~
                                                                                                        (Int,
                                                                                                         Int)
                                                                                                        -> [a]
                                                                                                        -> Vector
                                                                                                             a " p4.hs:30:14-25] (CNonCanonical)}
                                  Binds = EvBindsVar<ar4>
                                  the type signature for
                                    listVector :: (Int, Int) -> [a] -> Vector a}}
Tc9

p4.hs:19:16:
    No instance for (Data.Array.Base.MArray b0 FlatVector IO)
      arising from a use of ‘thaw’
    The type variable ‘b0’ is ambiguous
    Note: there is a potential instance available:
      instance Data.Array.Base.MArray GHC.IOArray.IOArray e IO
        -- Defined in ‘Data.Array.Base’
    In a stmt of a 'do' block: v <- thaw tmp
    In the expression:
      do { let sL = ...
               dim = length sL
               ....;
           v <- thaw tmp;
           return () }
    In an equation for ‘main’:
        main
          = do { let sL = ...
                     ....;
                 v <- thaw tmp;
                 return () }
