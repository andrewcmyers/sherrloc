rn12
rn13
Tc2 (src)
Tc3
kcTyClGroup
  module Main
  type FlatVector = UArray Int Double
kcTyClGroup: initial kinds []
env2 []
kcd1 FlatVector []
tc_lhs_type:
  UArray Int Double
  Expected kind ‘k_ajz’
tc_lhs_type:
  UArray
  Expected kind ‘k_ajA’
lk1 UArray
lk2 UArray Type constructor ‘UArray’
writeMetaTyVar k_ajA := * -> * -> *
tc_lhs_type:
  Int
  The first argument of ‘UArray’ should have kind ‘*’
lk1 Int
lk2 Int Type constructor ‘Int’
tc_lhs_type:
  Double
  The second argument of ‘UArray’ should have kind ‘*’
lk1 Double
lk2 Double Type constructor ‘Double’
writeMetaTyVar k_ajz := *
kcd2 FlatVector
Generalise kind
  FlatVector
  k_ajz
  []
  *
kcTyClGroup result [(FlatVector, *)]
tcTyAndCl generalized kinds [(FlatVector, *)]
tcTyAndCl-x type FlatVector = UArray Int Double
env2 []
env2 []
tc-syn
  FlatVector
  [(r9A, AThing *)]
tc_lhs_type:
  UArray Int Double
  Expected kind ‘*’
tc_lhs_type:
  UArray
  Expected kind ‘k_ajJ’
lk1 UArray
lk2 UArray Type constructor ‘UArray’
writeMetaTyVar k_ajJ := * -> * -> *
tc_lhs_type:
  Int
  The first argument of ‘UArray’ should have kind ‘*’
lk1 Int
lk2 Int Type constructor ‘Int’
tc_lhs_type:
  Double
  The second argument of ‘UArray’ should have kind ‘*’
lk1 Double
lk2 Double Type constructor ‘Double’
Starting validity check [Type constructor ‘FlatVector’]
checkValidType UArray Int Double :: *
checkValidType done UArray Int Double :: *
env2 []
kcTyClGroup
  module Main
  type Vector a = Array Int a
kcTyClGroup: initial kinds []
env2 []
kcd1 Vector [a]
tc_lhs_type:
  Array Int a
  Expected kind ‘k_ajL’
tc_lhs_type:
  Array
  Expected kind ‘k_ajM’
lk1 Array
lk2 Array Type constructor ‘Array’
writeMetaTyVar k_ajM := * -> * -> *
tc_lhs_type:
  Int
  The first argument of ‘Array’ should have kind ‘*’
lk1 Int
lk2 Int Type constructor ‘Int’
tc_lhs_type:
  a
  The second argument of ‘Array’ should have kind ‘*’
lk1 a
lk2 a AThing k_ajK
writeMetaTyVar k_ajK := *
writeMetaTyVar k_ajL := *
kcd2 Vector
Generalise kind
  Vector
  k_ajK -> k_ajL
  []
  * -> *
kcTyClGroup result [(Vector, * -> *)]
tcTyAndCl generalized kinds [(Vector, * -> *)]
tcTyAndCl-x type Vector a = Array Int a
env2 []
env2 [(a, Type variable ‘a’ = a)]
tc-syn
  Vector
  [(a9F, Type variable ‘a’ = a), (r8Q, AThing * -> *)]
tc_lhs_type:
  Array Int a
  Expected kind ‘*’
tc_lhs_type:
  Array
  Expected kind ‘k_ajV’
lk1 Array
lk2 Array Type constructor ‘Array’
writeMetaTyVar k_ajV := * -> * -> *
tc_lhs_type:
  Int
  The first argument of ‘Array’ should have kind ‘*’
lk1 Int
lk2 Int Type constructor ‘Int’
tc_lhs_type:
  a
  The second argument of ‘Array’ should have kind ‘*’
lk1 a
lk2 a Type variable ‘a’ = a
Starting validity check [Type constructor ‘Vector’]
checkValidType Array Int a :: *
checkValidType done Array Int a :: *
env2 []
Adding instances:
addFamInsts
env2 []
tcDeriving
tcDeriving False
tcDeriving 1 []
Adding instances:
Tc3b
tcAmpMissingParentClassWarn/isInsts []
tcAmpMissingParentClassWarn/isInsts []
tcAmpFunctionWarn/wouldBeImported
tcAmpFunctionWarn/amp_prelude_functions Control.Monad.join []
tcAmpFunctionWarn/wouldBeImported
tcAmpFunctionWarn/amp_prelude_functions Control.Applicative.<*> []
tcAmpFunctionWarn/wouldBeImported
tcAmpFunctionWarn/amp_prelude_functions Control.Applicative.pure []
Tc4
Tc4a
env2 []
Tc5
env2 []
tcHsTyVarBndrs {
  Hs kind vars: []
  Hs type vars: [a]
  Kind vars: []
  Type vars: [a]
env2 [(a, Type variable ‘a’ = a)]
tc_lhs_type:
  (Int, Int) -> [a] -> Vector a
  Expected a type
tc_lhs_type:
  (Int, Int)
  Expected a type
tc_lhs_type:
  Int
  Expected kind ‘k_aqd’
lk1 Int
lk2 Int Type constructor ‘Int’
writeMetaTyVar k_aqd := *
tc_lhs_type:
  Int
  Expected kind ‘k_aqe’
lk1 Int
lk2 Int Type constructor ‘Int’
writeMetaTyVar k_aqe := *
tc_lhs_type:
  [a] -> Vector a
  Expected a type
tc_lhs_type:
  [a]
  Expected a type
tc_lhs_type:
  a
  Expected kind ‘*’
lk1 a
lk2 a Type variable ‘a’ = a
writeMetaTyVar k_aqc := *
tc_lhs_type:
  Vector a
  Expected a type
tc_lhs_type:
  Vector
  Expected kind ‘k_aqf’
lk1 Vector
lk2 Vector Type constructor ‘Vector’
writeMetaTyVar k_aqf := * -> *
tc_lhs_type:
  a
  The first argument of ‘Vector’ should have kind ‘*’
lk1 a
lk2 a Type variable ‘a’ = a
tcHsTyVarBndrs }
  Hs kind vars: []
  Hs type vars: [a]
  Kind vars: []
  Type vars: [a]
tcCheckHsTypeAndGen (Int, Int) -> [a] -> Vector a
checkValidType forall a. (Int, Int) -> [a] -> Vector a :: *
Ambiguity check for forall a. (Int, Int) -> [a] -> Vector a
tcGen
u_tys 
  untch 1
  (Int, Int) -> [a_aqi] -> Vector a_aqi
  ~
  (Int, Int) -> [a] -> Vector a
  a type equality (Int, Int) -> [a_aqi] -> Vector a_aqi
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys 
  untch 1
  (Int, Int) ~ (Int, Int)
  a type equality (Int, Int) -> [a_aqi] -> Vector a_aqi
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys 
  untch 1
  Int ~ Int
  a type equality (Int, Int) -> [a_aqi] -> Vector a_aqi
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys yields no coercion
u_tys 
  untch 1
  Int ~ Int
  a type equality (Int, Int) -> [a_aqi] -> Vector a_aqi
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys yields no coercion
u_tys yields no coercion
u_tys 
  untch 1
  [a_aqi] -> Vector a_aqi ~ [a] -> Vector a
  a type equality (Int, Int) -> [a_aqi] -> Vector a_aqi
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys 
  untch 1
  [a_aqi] ~ [a]
  a type equality (Int, Int) -> [a_aqi] -> Vector a_aqi
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys 
  untch 1
  a_aqi ~ a
  a type equality (Int, Int) -> [a_aqi] -> Vector a_aqi
                  ~
                  (Int, Int) -> [a] -> Vector a
uUnfilledVars trying to unify * with *
writeMetaTyVar a_aqi := a
u_tys yields no coercion
u_tys yields no coercion
u_tys 
  untch 1
  Vector a_aqi ~ Vector a
  a type equality (Int, Int) -> [a_aqi] -> Vector a_aqi
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys 
  untch 1
  Int ~ Int
  a type equality (Int, Int) -> [a_aqi] -> Vector a_aqi
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys yields no coercion
u_tys 
  untch 1
  a_aqi ~ a
  a type equality (Int, Int) -> [a_aqi] -> Vector a_aqi
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys yields no coercion
u_tys yields no coercion
u_tys yields no coercion
u_tys yields no coercion
simplifyAmbiguityCheck {
  type =  forall a. (Int, Int) -> [a] -> Vector a
  wanted =  WC {}
solveWantedsTcMWithEvBinds wanted= WC {}
solveWanteds { WC {}
solveFlats {
solveFlats end } {}
simpl_loop, iteration 1
solveWanteds }
  unsolved_flats   = {}
  unsolved_implics = {}
  current evbinds  = {}
  current tybinds  =
  final wc = WC {}
End simplifyAmbiguityCheck }
reportUnsolved(ambig) {
reportUnsolved(ambig) }
Done ambiguity check for forall a. (Int, Int) -> [a] -> Vector a
checkValidType done forall a. (Int, Int) -> [a] -> Vector a :: *
tc_lhs_type:
  (Int, Int)
  Expected a type
tc_lhs_type:
  Int
  Expected kind ‘k_aqn’
lk1 Int
lk2 Int Type constructor ‘Int’
writeMetaTyVar k_aqn := *
tc_lhs_type:
  Int
  Expected kind ‘k_aqo’
lk1 Int
lk2 Int Type constructor ‘Int’
writeMetaTyVar k_aqo := *
tc_lhs_type:
  [Double] -> FlatVector
  Expected a type
tc_lhs_type:
  [Double]
  Expected a type
tc_lhs_type:
  Double
  Expected kind ‘*’
lk1 Double
lk2 Double Type constructor ‘Double’
tc_lhs_type:
  FlatVector
  Expected a type
lk1 FlatVector
lk2 FlatVector Type constructor ‘FlatVector’
tcCheckHsTypeAndGen (Int, Int) -> [Double] -> FlatVector
checkValidType (Int, Int) -> [Double] -> FlatVector :: *
checkValidType done (Int, Int) -> [Double] -> FlatVector :: *
tc_lhs_type:
  IO
  Expected kind ‘k_aqp’
lk1 IO
lk2 IO Type constructor ‘IO’
writeMetaTyVar k_aqp := * -> *
tc_lhs_type:
  ()
  The first argument of ‘IO’ should have kind ‘*’
tcCheckHsTypeAndGen IO ()
checkValidType IO () :: *
checkValidType done IO () :: *
env2
  [(listVector,
    Identifier[listVector::forall a.
                           (Int, Int) -> [a] -> Vector a, <NotTopLevel>]),
   (listFlatVector,
    Identifier[listFlatVector::(Int, Int)
                               -> [Double] -> FlatVector, <NotTopLevel>]),
   (main, Identifier[main::IO (), <NotTopLevel>])]
------------------------------------------------
Bindings for { [listVector]
Generalisation plan
  CheckGen listVector :: (Int, Int) -> [a] -> Vector a
                         [Nothing]
env2 []
tcMonoBinds
env2 []
tcRhs: fun bind
  listVector
  (Int, Int) -> [a] -> Vector a
tcMatchesFun
  listVector
  (Int, Int) -> [a] -> Vector a
tcGen
tcBody (Int, Int) -> [a] -> Vector a
Instantiating
  listArray with [i_aqY, e_aqZ, a_ar0]
                 [Data.Array.Base.IArray a_ar0 e_aqZ, GHC.Arr.Ix i_aqY]
instCallConstraints [$dIArray_ar1, $dIx_ar2]
utype_defer
  cobox_ar3
  (i_aqY, i_aqY) -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
  (Int, Int) -> [a] -> Vector a
  a type equality (i_aqY, i_aqY) -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                  ~
                  (Int, Int) -> [a] -> Vector a
  In the expression: listArray
  In an equation for ‘listVector’: listVector = listArray
addInlinePrags
  listVector
  []
csb2 [listVector]
} End of bindings for
  [listVector]
  NonRecursive
  listVector forall a. (Int, Int) -> [a] -> Vector a
env2
  [(listVector,
    Identifier[listVector::forall a.
                           (Int, Int) -> [a] -> Vector a, <TopLevel>])]
------------------------------------------------
Bindings for { [listFlatVector]
Generalisation plan
  CheckGen listFlatVector :: (Int, Int) -> [Double] -> FlatVector
                             []
env2 []
tcMonoBinds
env2 []
tcRhs: fun bind
  listFlatVector
  (Int, Int) -> [Double] -> FlatVector
tcMatchesFun
  listFlatVector
  (Int, Int) -> [Double] -> FlatVector
tcGen
tcBody (Int, Int) -> [Double] -> FlatVector
Instantiating
  listArray with [i_ar6, e_ar7, a_ar8]
                 [Data.Array.Base.IArray a_ar8 e_ar7, GHC.Arr.Ix i_ar6]
instCallConstraints [$dIArray_ar9, $dIx_ara]
utype_defer
  cobox_arb
  (i_ar6, i_ar6) -> [e_ar7] -> a_ar8 i_ar6 e_ar7
  (Int, Int) -> [Double] -> FlatVector
  a type equality (i_ar6, i_ar6) -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                  ~
                  (Int, Int) -> [Double] -> FlatVector
  In the expression: listArray
  In an equation for ‘listFlatVector’: listFlatVector = listArray
addInlinePrags
  listFlatVector
  []
csb2 [listFlatVector]
} End of bindings for
  [listFlatVector]
  NonRecursive
  listFlatVector (Int, Int) -> [Double] -> FlatVector
env2
  [(listFlatVector,
    Identifier[listFlatVector::(Int, Int)
                               -> [Double] -> FlatVector, <TopLevel>])]
------------------------------------------------
Bindings for { [main]
Generalisation plan
  CheckGen main :: IO ()
                   []
env2 []
tcMonoBinds
env2 []
tcRhs: fun bind
  main
  IO ()
tcMatchesFun
  main
  IO ()
tcGen
tcBody IO ()
tc_lhs_type:
  FlatVector
  Expected kind ‘*’
lk1 FlatVector
lk2 FlatVector Type constructor ‘FlatVector’
tcCheckHsTypeAndGen [FlatVector]
checkValidType [FlatVector] :: *
checkValidType done [FlatVector] :: *
tc_lhs_type:
  Vector
  Expected kind ‘k_ard’
lk1 Vector
lk2 Vector Type constructor ‘Vector’
writeMetaTyVar k_ard := * -> *
tc_lhs_type:
  FlatVector
  The first argument of ‘Vector’ should have kind ‘*’
lk1 FlatVector
lk2 FlatVector Type constructor ‘FlatVector’
tcCheckHsTypeAndGen Vector FlatVector
checkValidType Vector FlatVector :: *
checkValidType done Vector FlatVector :: *
env2
  [(help, Identifier[help::[FlatVector], <NotTopLevel>]),
   (tmp, Identifier[tmp::Vector FlatVector, <NotTopLevel>])]
------------------------------------------------
Bindings for { [sL]
Generalisation plan InferGen True True
tcMatchesFun
  sL
  t_are
tcGen
tcBody t_are
utype_defer
  cobox_arh
  [t_arg]
  t_are
  a type equality [t_arg] ~ t_are
  In the expression: [1, 4, 6, 3, 2, 5]
  In an equation for ‘sL’: sL = [1, 4, 6, 3, 2, 5]
  In the expression:
    do { let sL = [1, 4, 6, 3, 2, 5]
             dim = length sL
             help :: [FlatVector]
             help = [listFlatVector (1, s) [0 | i <- [1 .. s]] | s <- sL]
             tmp :: Vector FlatVector
             tmp = listVector (1, dim) help;
         v <- thaw tmp;
         return () }
tcPolyExpr t_arg
tcPolyExprNC t_arg
tcGen
Instantiating
  fromInteger with [a_atN]
                   [Num a_atN]
instCallConstraints [$dNum_atO]
utype_defer
  cobox_atP
  Integer -> a_atN
  Integer -> t_arg
  a type equality Integer -> a_atN ~ Integer -> t_arg
  In the expression: 1
  In the expression: [1, 4, 6, 3, 2, 5]
  In an equation for ‘sL’: sL = [1, 4, 6, 3, 2, 5]
tcPolyExpr t_arg
tcPolyExprNC t_arg
tcGen
Instantiating
  fromInteger with [a_atQ]
                   [Num a_atQ]
instCallConstraints [$dNum_atR]
utype_defer
  cobox_atS
  Integer -> a_atQ
  Integer -> t_arg
  a type equality Integer -> a_atQ ~ Integer -> t_arg
  In the expression: 4
  In the expression: [1, 4, 6, 3, 2, 5]
  In an equation for ‘sL’: sL = [1, 4, 6, 3, 2, 5]
tcPolyExpr t_arg
tcPolyExprNC t_arg
tcGen
Instantiating
  fromInteger with [a_atT]
                   [Num a_atT]
instCallConstraints [$dNum_atU]
utype_defer
  cobox_atV
  Integer -> a_atT
  Integer -> t_arg
  a type equality Integer -> a_atT ~ Integer -> t_arg
  In the expression: 6
  In the expression: [1, 4, 6, 3, 2, 5]
  In an equation for ‘sL’: sL = [1, 4, 6, 3, 2, 5]
tcPolyExpr t_arg
tcPolyExprNC t_arg
tcGen
Instantiating
  fromInteger with [a_atW]
                   [Num a_atW]
instCallConstraints [$dNum_atX]
utype_defer
  cobox_atY
  Integer -> a_atW
  Integer -> t_arg
  a type equality Integer -> a_atW ~ Integer -> t_arg
  In the expression: 3
  In the expression: [1, 4, 6, 3, 2, 5]
  In an equation for ‘sL’: sL = [1, 4, 6, 3, 2, 5]
tcPolyExpr t_arg
tcPolyExprNC t_arg
tcGen
Instantiating
  fromInteger with [a_atZ]
                   [Num a_atZ]
instCallConstraints [$dNum_au0]
utype_defer
  cobox_au1
  Integer -> a_atZ
  Integer -> t_arg
  a type equality Integer -> a_atZ ~ Integer -> t_arg
  In the expression: 2
  In the expression: [1, 4, 6, 3, 2, 5]
  In an equation for ‘sL’: sL = [1, 4, 6, 3, 2, 5]
tcPolyExpr t_arg
tcPolyExprNC t_arg
tcGen
Instantiating
  fromInteger with [a_au2]
                   [Num a_au2]
instCallConstraints [$dNum_au3]
utype_defer
  cobox_au4
  Integer -> a_au2
  Integer -> t_arg
  a type equality Integer -> a_au2 ~ Integer -> t_arg
  In the expression: 5
  In the expression: [1, 4, 6, 3, 2, 5]
  In an equation for ‘sL’: sL = [1, 4, 6, 3, 2, 5]
simplifyInfer call
  [(sL, t_are)]
  WC {wc_flat = [W] cobox_arh :: [t_arg]
                                 ~ t_are [" a type equality [t_arg]
                                                            ~
                                                            t_are " p4.hs:13:20-32] (CNonCanonical)
                [W] $dNum_atO :: Num
                                   a_atN [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                [W] cobox_atP :: (Integer -> a_atN)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atN
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:21] (CNonCanonical)
                [W] $dNum_atR :: Num
                                   a_atQ [" the literal ‘4’ " p4.hs:13:23] (CNonCanonical)
                [W] cobox_atS :: (Integer -> a_atQ)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atQ
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:23] (CNonCanonical)
                [W] $dNum_atU :: Num
                                   a_atT [" the literal ‘6’ " p4.hs:13:25] (CNonCanonical)
                [W] cobox_atV :: (Integer -> a_atT)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atT
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:25] (CNonCanonical)
                [W] $dNum_atX :: Num
                                   a_atW [" the literal ‘3’ " p4.hs:13:27] (CNonCanonical)
                [W] cobox_atY :: (Integer -> a_atW)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atW
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:27] (CNonCanonical)
                [W] $dNum_au0 :: Num
                                   a_atZ [" the literal ‘2’ " p4.hs:13:29] (CNonCanonical)
                [W] cobox_au1 :: (Integer -> a_atZ)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atZ
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:29] (CNonCanonical)
                [W] $dNum_au3 :: Num
                                   a_au2 [" the literal ‘5’ " p4.hs:13:31] (CNonCanonical)
                [W] cobox_au4 :: (Integer -> a_au2)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_au2
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:31] (CNonCanonical)}
simplifyInfer {
  binds = [(sL, t_are)]
  closed = True
  apply_mr = True
  (unzonked) wanted = WC {wc_flat = [W] cobox_arh :: [t_arg]
                                                     ~ t_are [" a type equality [t_arg]
                                                                                ~
                                                                                t_are " p4.hs:13:20-32] (CNonCanonical)
                                    [W] $dNum_atO :: Num
                                                       a_atN [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                                    [W] cobox_atP :: (Integer -> a_atN)
                                                     ~ (Integer -> t_arg) [" a type equality Integer
                                                                                             -> a_atN
                                                                                             ~
                                                                                             Integer
                                                                                             -> t_arg " p4.hs:13:21] (CNonCanonical)
                                    [W] $dNum_atR :: Num
                                                       a_atQ [" the literal ‘4’ " p4.hs:13:23] (CNonCanonical)
                                    [W] cobox_atS :: (Integer -> a_atQ)
                                                     ~ (Integer -> t_arg) [" a type equality Integer
                                                                                             -> a_atQ
                                                                                             ~
                                                                                             Integer
                                                                                             -> t_arg " p4.hs:13:23] (CNonCanonical)
                                    [W] $dNum_atU :: Num
                                                       a_atT [" the literal ‘6’ " p4.hs:13:25] (CNonCanonical)
                                    [W] cobox_atV :: (Integer -> a_atT)
                                                     ~ (Integer -> t_arg) [" a type equality Integer
                                                                                             -> a_atT
                                                                                             ~
                                                                                             Integer
                                                                                             -> t_arg " p4.hs:13:25] (CNonCanonical)
                                    [W] $dNum_atX :: Num
                                                       a_atW [" the literal ‘3’ " p4.hs:13:27] (CNonCanonical)
                                    [W] cobox_atY :: (Integer -> a_atW)
                                                     ~ (Integer -> t_arg) [" a type equality Integer
                                                                                             -> a_atW
                                                                                             ~
                                                                                             Integer
                                                                                             -> t_arg " p4.hs:13:27] (CNonCanonical)
                                    [W] $dNum_au0 :: Num
                                                       a_atZ [" the literal ‘2’ " p4.hs:13:29] (CNonCanonical)
                                    [W] cobox_au1 :: (Integer -> a_atZ)
                                                     ~ (Integer -> t_arg) [" a type equality Integer
                                                                                             -> a_atZ
                                                                                             ~
                                                                                             Integer
                                                                                             -> t_arg " p4.hs:13:29] (CNonCanonical)
                                    [W] $dNum_au3 :: Num
                                                       a_au2 [" the literal ‘5’ " p4.hs:13:31] (CNonCanonical)
                                    [W] cobox_au4 :: (Integer -> a_au2)
                                                     ~ (Integer -> t_arg) [" a type equality Integer
                                                                                             -> a_au2
                                                                                             ~
                                                                                             Integer
                                                                                             -> t_arg " p4.hs:13:31] (CNonCanonical)}
solveWantedsTcMWithEvBinds
  wanted= WC {wc_flat = [W] cobox_arh :: [t_arg]
                                         ~ t_are [" a type equality [t_arg]
                                                                    ~
                                                                    t_are " p4.hs:13:20-32] (CNonCanonical)
                        [W] $dNum_atO :: Num
                                           a_atN [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                        [W] cobox_atP :: (Integer -> a_atN)
                                         ~ (Integer -> t_arg) [" a type equality Integer -> a_atN
                                                                                 ~
                                                                                 Integer
                                                                                 -> t_arg " p4.hs:13:21] (CNonCanonical)
                        [W] $dNum_atR :: Num
                                           a_atQ [" the literal ‘4’ " p4.hs:13:23] (CNonCanonical)
                        [W] cobox_atS :: (Integer -> a_atQ)
                                         ~ (Integer -> t_arg) [" a type equality Integer -> a_atQ
                                                                                 ~
                                                                                 Integer
                                                                                 -> t_arg " p4.hs:13:23] (CNonCanonical)
                        [W] $dNum_atU :: Num
                                           a_atT [" the literal ‘6’ " p4.hs:13:25] (CNonCanonical)
                        [W] cobox_atV :: (Integer -> a_atT)
                                         ~ (Integer -> t_arg) [" a type equality Integer -> a_atT
                                                                                 ~
                                                                                 Integer
                                                                                 -> t_arg " p4.hs:13:25] (CNonCanonical)
                        [W] $dNum_atX :: Num
                                           a_atW [" the literal ‘3’ " p4.hs:13:27] (CNonCanonical)
                        [W] cobox_atY :: (Integer -> a_atW)
                                         ~ (Integer -> t_arg) [" a type equality Integer -> a_atW
                                                                                 ~
                                                                                 Integer
                                                                                 -> t_arg " p4.hs:13:27] (CNonCanonical)
                        [W] $dNum_au0 :: Num
                                           a_atZ [" the literal ‘2’ " p4.hs:13:29] (CNonCanonical)
                        [W] cobox_au1 :: (Integer -> a_atZ)
                                         ~ (Integer -> t_arg) [" a type equality Integer -> a_atZ
                                                                                 ~
                                                                                 Integer
                                                                                 -> t_arg " p4.hs:13:29] (CNonCanonical)
                        [W] $dNum_au3 :: Num
                                           a_au2 [" the literal ‘5’ " p4.hs:13:31] (CNonCanonical)
                        [W] cobox_au4 :: (Integer -> a_au2)
                                         ~ (Integer -> t_arg) [" a type equality Integer -> a_au2
                                                                                 ~
                                                                                 Integer
                                                                                 -> t_arg " p4.hs:13:31] (CNonCanonical)}
solveWanteds {
  WC {wc_flat = [W] cobox_arh :: [t_arg]
                                 ~ t_are [" a type equality [t_arg]
                                                            ~
                                                            t_are " p4.hs:13:20-32] (CNonCanonical)
                [W] $dNum_atO :: Num
                                   a_atN [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                [W] cobox_atP :: (Integer -> a_atN)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atN
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:21] (CNonCanonical)
                [W] $dNum_atR :: Num
                                   a_atQ [" the literal ‘4’ " p4.hs:13:23] (CNonCanonical)
                [W] cobox_atS :: (Integer -> a_atQ)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atQ
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:23] (CNonCanonical)
                [W] $dNum_atU :: Num
                                   a_atT [" the literal ‘6’ " p4.hs:13:25] (CNonCanonical)
                [W] cobox_atV :: (Integer -> a_atT)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atT
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:25] (CNonCanonical)
                [W] $dNum_atX :: Num
                                   a_atW [" the literal ‘3’ " p4.hs:13:27] (CNonCanonical)
                [W] cobox_atY :: (Integer -> a_atW)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atW
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:27] (CNonCanonical)
                [W] $dNum_au0 :: Num
                                   a_atZ [" the literal ‘2’ " p4.hs:13:29] (CNonCanonical)
                [W] cobox_au1 :: (Integer -> a_atZ)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atZ
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:29] (CNonCanonical)
                [W] $dNum_au3 :: Num
                                   a_au2 [" the literal ‘5’ " p4.hs:13:31] (CNonCanonical)
                [W] cobox_au4 :: (Integer -> a_au2)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_au2
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:31] (CNonCanonical)}
solveFlats {
Start solver pipeline {
  work item =  [W] cobox_arh :: [t_arg]
                                ~ t_are [" a type equality [t_arg]
                                                           ~
                                                           t_are " p4.hs:13:20-32] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_arh :: [t_arg]
                                 ~ t_are [" a type equality [t_arg]
                                                            ~
                                                            t_are " p4.hs:13:20-32] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_arh :: [t_arg] ~ t_are [" a type equality [t_arg]
                                                      ~
                                                      t_are " p4.hs:13:20-32] (CNonCanonical)
canEvNC:eq
  [t_arg]
  t_are
can_eq_nc
  [W] cobox_arh :: [t_arg] ~ t_are
  [t_arg]
  [t_arg]
  t_are
  t_are
canEqTyVar
  t_are
  [t_arg]
  Is-swapped
newWantedEvVar/cache miss [W] cobox_au6 :: t_are ~ [t_arg]
setEvBind
  ev = cobox_arh
  tm  = CO Sym cobox_au6
rewriteEqEvidence
  [W] cobox_arh :: [t_arg] ~ t_are
  t_are
  [t_arg]
  Sym cobox_au6
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_au6 :: t_are
                                 ~ [t_arg] [" a type equality [t_arg]
                                                              ~
                                                              t_are " p4.hs:13:20-32] (CTyEqCan)
Sneaky unification:
  Unifies: t_are := [t_arg]
  Coercion: t_are ~ [t_arg]
  Left Kind is: OpenKind
  Right Kind is: *
setWantedTyBind t_are := [t_arg]
setEvBind
  ev = cobox_au6
  tm  = CO <[t_arg]>_N
kickOutRewritable
  tv =  t_are
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
1[<C:0,F:0>] [W] cobox_au6 :: t_are ~ [t_arg]: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_atP :: (Integer -> a_atN)
                                ~ (Integer -> t_arg) [" a type equality Integer -> a_atN
                                                                        ~
                                                                        Integer
                                                                        -> t_arg " p4.hs:13:21] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_atP :: (Integer -> a_atN)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atN
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:21] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_atP :: (Integer -> a_atN)
                   ~ (Integer -> t_arg) [" a type equality Integer -> a_atN
                                                           ~
                                                           Integer
                                                           -> t_arg " p4.hs:13:21] (CNonCanonical)
canEvNC:eq
  Integer -> a_atN
  Integer -> t_arg
can_eq_nc
  [W] cobox_atP :: (Integer -> a_atN) ~ (Integer -> t_arg)
  Integer -> a_atN
  Integer -> a_atN
  Integer -> t_arg
  Integer -> t_arg
newWantedEvVar/cache miss [W] cobox_au7 :: Integer ~ Integer
newWantedEvVar/cache miss [W] cobox_au8 :: a_atN ~ t_arg
setEvBind
  ev = cobox_atP
  tm  = CO cobox_au7 -> cobox_au8
canEvNC:eq
  Integer
  Integer
can_eq_nc
  [W] cobox_au7 :: Integer ~ Integer
  Integer
  Integer
  Integer
  Integer
setEvBind
  ev = cobox_au7
  tm  = CO <Integer>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_au8 :: a_atN
                                ~ t_arg [" a type equality Integer -> a_atN
                                                           ~
                                                           Integer
                                                           -> t_arg " p4.hs:13:21] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_au8 :: a_atN
                                 ~ t_arg [" a type equality Integer -> a_atN
                                                            ~
                                                            Integer
                                                            -> t_arg " p4.hs:13:21] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_au8 :: a_atN ~ t_arg [" a type equality Integer -> a_atN
                                                    ~
                                                    Integer -> t_arg " p4.hs:13:21] (CNonCanonical)
canEvNC:eq
  a_atN
  t_arg
can_eq_nc
  [W] cobox_au8 :: a_atN ~ t_arg
  a_atN
  a_atN
  t_arg
  t_arg
canEqTyVar
  a_atN
  t_arg
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_au8 :: a_atN
                                 ~ t_arg [" a type equality Integer -> a_atN
                                                            ~
                                                            Integer
                                                            -> t_arg " p4.hs:13:21] (CTyEqCan)
Sneaky unification:
  Unifies: t_arg := a_atN
  Coercion: t_arg ~ a_atN
  Left Kind is: *
  Right Kind is: *
setWantedTyBind t_arg := a_atN
setEvBind
  ev = cobox_au8
  tm  = CO <a_atN>_N
kickOutRewritable
  tv =  t_arg
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
3[<C:0,F:0>] [W] cobox_au8 :: a_atN ~ t_arg: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_atS :: (Integer -> a_atQ)
                                ~ (Integer -> t_arg) [" a type equality Integer -> a_atQ
                                                                        ~
                                                                        Integer
                                                                        -> t_arg " p4.hs:13:23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_atS :: (Integer -> a_atQ)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atQ
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_atS :: (Integer -> a_atQ)
                   ~ (Integer -> t_arg) [" a type equality Integer -> a_atQ
                                                           ~
                                                           Integer
                                                           -> t_arg " p4.hs:13:23] (CNonCanonical)
canEvNC:eq
  Integer -> a_atQ
  Integer -> t_arg
can_eq_nc
  [W] cobox_atS :: (Integer -> a_atQ) ~ (Integer -> t_arg)
  Integer -> a_atQ
  Integer -> a_atQ
  Integer -> t_arg
  Integer -> t_arg
newWantedEvVar/cache miss [W] cobox_au9 :: Integer ~ Integer
newWantedEvVar/cache miss [W] cobox_aua :: a_atQ ~ t_arg
setEvBind
  ev = cobox_atS
  tm  = CO cobox_au9 -> cobox_aua
canEvNC:eq
  Integer
  Integer
can_eq_nc
  [W] cobox_au9 :: Integer ~ Integer
  Integer
  Integer
  Integer
  Integer
setEvBind
  ev = cobox_au9
  tm  = CO <Integer>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_aua :: a_atQ
                                ~ t_arg [" a type equality Integer -> a_atQ
                                                           ~
                                                           Integer
                                                           -> t_arg " p4.hs:13:23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_aua :: a_atQ
                                 ~ t_arg [" a type equality Integer -> a_atQ
                                                            ~
                                                            Integer
                                                            -> t_arg " p4.hs:13:23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_aua :: a_atQ ~ t_arg [" a type equality Integer -> a_atQ
                                                    ~
                                                    Integer -> t_arg " p4.hs:13:23] (CNonCanonical)
canEvNC:eq
  a_atQ
  t_arg
can_eq_nc
  [W] cobox_aua :: a_atQ ~ t_arg
  a_atQ
  a_atQ
  t_arg
  t_arg
canEqTyVar
  a_atQ
  t_arg
  Not-swapped
Following bound tyvar t_arg = a_atN
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_aua :: a_atQ
                                 ~ a_atN [" a type equality Integer -> a_atQ
                                                            ~
                                                            Integer
                                                            -> t_arg " p4.hs:13:23] (CTyEqCan)
Sneaky unification:
  Unifies: a_atN := a_atQ
  Coercion: a_atN ~ a_atQ
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_atN := a_atQ
setEvBind
  ev = cobox_aua
  tm  = CO <a_atQ>_N
kickOutRewritable
  tv =  a_atN
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
5[<C:0,F:0>] [W] cobox_aua :: a_atQ ~ a_atN: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_atV :: (Integer -> a_atT)
                                ~ (Integer -> t_arg) [" a type equality Integer -> a_atT
                                                                        ~
                                                                        Integer
                                                                        -> t_arg " p4.hs:13:25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_atV :: (Integer -> a_atT)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atT
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:25] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_atV :: (Integer -> a_atT)
                   ~ (Integer -> t_arg) [" a type equality Integer -> a_atT
                                                           ~
                                                           Integer
                                                           -> t_arg " p4.hs:13:25] (CNonCanonical)
canEvNC:eq
  Integer -> a_atT
  Integer -> t_arg
can_eq_nc
  [W] cobox_atV :: (Integer -> a_atT) ~ (Integer -> t_arg)
  Integer -> a_atT
  Integer -> a_atT
  Integer -> t_arg
  Integer -> t_arg
newWantedEvVar/cache miss [W] cobox_aub :: Integer ~ Integer
newWantedEvVar/cache miss [W] cobox_auc :: a_atT ~ t_arg
setEvBind
  ev = cobox_atV
  tm  = CO cobox_aub -> cobox_auc
canEvNC:eq
  Integer
  Integer
can_eq_nc
  [W] cobox_aub :: Integer ~ Integer
  Integer
  Integer
  Integer
  Integer
setEvBind
  ev = cobox_aub
  tm  = CO <Integer>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_auc :: a_atT
                                ~ t_arg [" a type equality Integer -> a_atT
                                                           ~
                                                           Integer
                                                           -> t_arg " p4.hs:13:25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_auc :: a_atT
                                 ~ t_arg [" a type equality Integer -> a_atT
                                                            ~
                                                            Integer
                                                            -> t_arg " p4.hs:13:25] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_auc :: a_atT ~ t_arg [" a type equality Integer -> a_atT
                                                    ~
                                                    Integer -> t_arg " p4.hs:13:25] (CNonCanonical)
canEvNC:eq
  a_atT
  t_arg
can_eq_nc
  [W] cobox_auc :: a_atT ~ t_arg
  a_atT
  a_atT
  t_arg
  t_arg
canEqTyVar
  a_atT
  t_arg
  Not-swapped
Following bound tyvar t_arg = a_atN
Following bound tyvar a_atN = a_atQ
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_auc :: a_atT
                                 ~ a_atQ [" a type equality Integer -> a_atT
                                                            ~
                                                            Integer
                                                            -> t_arg " p4.hs:13:25] (CTyEqCan)
Sneaky unification:
  Unifies: a_atQ := a_atT
  Coercion: a_atQ ~ a_atT
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_atQ := a_atT
setEvBind
  ev = cobox_auc
  tm  = CO <a_atT>_N
kickOutRewritable
  tv =  a_atQ
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
7[<C:0,F:0>] [W] cobox_auc :: a_atT ~ a_atQ: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_atY :: (Integer -> a_atW)
                                ~ (Integer -> t_arg) [" a type equality Integer -> a_atW
                                                                        ~
                                                                        Integer
                                                                        -> t_arg " p4.hs:13:27] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_atY :: (Integer -> a_atW)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atW
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:27] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_atY :: (Integer -> a_atW)
                   ~ (Integer -> t_arg) [" a type equality Integer -> a_atW
                                                           ~
                                                           Integer
                                                           -> t_arg " p4.hs:13:27] (CNonCanonical)
canEvNC:eq
  Integer -> a_atW
  Integer -> t_arg
can_eq_nc
  [W] cobox_atY :: (Integer -> a_atW) ~ (Integer -> t_arg)
  Integer -> a_atW
  Integer -> a_atW
  Integer -> t_arg
  Integer -> t_arg
newWantedEvVar/cache miss [W] cobox_aud :: Integer ~ Integer
newWantedEvVar/cache miss [W] cobox_aue :: a_atW ~ t_arg
setEvBind
  ev = cobox_atY
  tm  = CO cobox_aud -> cobox_aue
canEvNC:eq
  Integer
  Integer
can_eq_nc
  [W] cobox_aud :: Integer ~ Integer
  Integer
  Integer
  Integer
  Integer
setEvBind
  ev = cobox_aud
  tm  = CO <Integer>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_aue :: a_atW
                                ~ t_arg [" a type equality Integer -> a_atW
                                                           ~
                                                           Integer
                                                           -> t_arg " p4.hs:13:27] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_aue :: a_atW
                                 ~ t_arg [" a type equality Integer -> a_atW
                                                            ~
                                                            Integer
                                                            -> t_arg " p4.hs:13:27] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_aue :: a_atW ~ t_arg [" a type equality Integer -> a_atW
                                                    ~
                                                    Integer -> t_arg " p4.hs:13:27] (CNonCanonical)
canEvNC:eq
  a_atW
  t_arg
can_eq_nc
  [W] cobox_aue :: a_atW ~ t_arg
  a_atW
  a_atW
  t_arg
  t_arg
canEqTyVar
  a_atW
  t_arg
  Not-swapped
Following bound tyvar t_arg = a_atN
Following bound tyvar a_atN = a_atQ
Following bound tyvar a_atQ = a_atT
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_aue :: a_atW
                                 ~ a_atT [" a type equality Integer -> a_atW
                                                            ~
                                                            Integer
                                                            -> t_arg " p4.hs:13:27] (CTyEqCan)
Sneaky unification:
  Unifies: a_atT := a_atW
  Coercion: a_atT ~ a_atW
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_atT := a_atW
setEvBind
  ev = cobox_aue
  tm  = CO <a_atW>_N
kickOutRewritable
  tv =  a_atT
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
9[<C:0,F:0>] [W] cobox_aue :: a_atW ~ a_atT: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_au1 :: (Integer -> a_atZ)
                                ~ (Integer -> t_arg) [" a type equality Integer -> a_atZ
                                                                        ~
                                                                        Integer
                                                                        -> t_arg " p4.hs:13:29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_au1 :: (Integer -> a_atZ)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_atZ
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_au1 :: (Integer -> a_atZ)
                   ~ (Integer -> t_arg) [" a type equality Integer -> a_atZ
                                                           ~
                                                           Integer
                                                           -> t_arg " p4.hs:13:29] (CNonCanonical)
canEvNC:eq
  Integer -> a_atZ
  Integer -> t_arg
can_eq_nc
  [W] cobox_au1 :: (Integer -> a_atZ) ~ (Integer -> t_arg)
  Integer -> a_atZ
  Integer -> a_atZ
  Integer -> t_arg
  Integer -> t_arg
newWantedEvVar/cache miss [W] cobox_auf :: Integer ~ Integer
newWantedEvVar/cache miss [W] cobox_aug :: a_atZ ~ t_arg
setEvBind
  ev = cobox_au1
  tm  = CO cobox_auf -> cobox_aug
canEvNC:eq
  Integer
  Integer
can_eq_nc
  [W] cobox_auf :: Integer ~ Integer
  Integer
  Integer
  Integer
  Integer
setEvBind
  ev = cobox_auf
  tm  = CO <Integer>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_aug :: a_atZ
                                ~ t_arg [" a type equality Integer -> a_atZ
                                                           ~
                                                           Integer
                                                           -> t_arg " p4.hs:13:29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_aug :: a_atZ
                                 ~ t_arg [" a type equality Integer -> a_atZ
                                                            ~
                                                            Integer
                                                            -> t_arg " p4.hs:13:29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_aug :: a_atZ ~ t_arg [" a type equality Integer -> a_atZ
                                                    ~
                                                    Integer -> t_arg " p4.hs:13:29] (CNonCanonical)
canEvNC:eq
  a_atZ
  t_arg
can_eq_nc
  [W] cobox_aug :: a_atZ ~ t_arg
  a_atZ
  a_atZ
  t_arg
  t_arg
canEqTyVar
  a_atZ
  t_arg
  Not-swapped
Following bound tyvar t_arg = a_atN
Following bound tyvar a_atN = a_atQ
Following bound tyvar a_atQ = a_atT
Following bound tyvar a_atT = a_atW
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_aug :: a_atZ
                                 ~ a_atW [" a type equality Integer -> a_atZ
                                                            ~
                                                            Integer
                                                            -> t_arg " p4.hs:13:29] (CTyEqCan)
Sneaky unification:
  Unifies: a_atW := a_atZ
  Coercion: a_atW ~ a_atZ
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_atW := a_atZ
setEvBind
  ev = cobox_aug
  tm  = CO <a_atZ>_N
kickOutRewritable
  tv =  a_atW
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
11[<C:0,F:0>] [W] cobox_aug :: a_atZ ~ a_atW: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_au4 :: (Integer -> a_au2)
                                ~ (Integer -> t_arg) [" a type equality Integer -> a_au2
                                                                        ~
                                                                        Integer
                                                                        -> t_arg " p4.hs:13:31] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_au4 :: (Integer -> a_au2)
                                 ~ (Integer -> t_arg) [" a type equality Integer -> a_au2
                                                                         ~
                                                                         Integer
                                                                         -> t_arg " p4.hs:13:31] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_au4 :: (Integer -> a_au2)
                   ~ (Integer -> t_arg) [" a type equality Integer -> a_au2
                                                           ~
                                                           Integer
                                                           -> t_arg " p4.hs:13:31] (CNonCanonical)
canEvNC:eq
  Integer -> a_au2
  Integer -> t_arg
can_eq_nc
  [W] cobox_au4 :: (Integer -> a_au2) ~ (Integer -> t_arg)
  Integer -> a_au2
  Integer -> a_au2
  Integer -> t_arg
  Integer -> t_arg
newWantedEvVar/cache miss [W] cobox_auh :: Integer ~ Integer
newWantedEvVar/cache miss [W] cobox_aui :: a_au2 ~ t_arg
setEvBind
  ev = cobox_au4
  tm  = CO cobox_auh -> cobox_aui
canEvNC:eq
  Integer
  Integer
can_eq_nc
  [W] cobox_auh :: Integer ~ Integer
  Integer
  Integer
  Integer
  Integer
setEvBind
  ev = cobox_auh
  tm  = CO <Integer>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_aui :: a_au2
                                ~ t_arg [" a type equality Integer -> a_au2
                                                           ~
                                                           Integer
                                                           -> t_arg " p4.hs:13:31] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_aui :: a_au2
                                 ~ t_arg [" a type equality Integer -> a_au2
                                                            ~
                                                            Integer
                                                            -> t_arg " p4.hs:13:31] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_aui :: a_au2 ~ t_arg [" a type equality Integer -> a_au2
                                                    ~
                                                    Integer -> t_arg " p4.hs:13:31] (CNonCanonical)
canEvNC:eq
  a_au2
  t_arg
can_eq_nc
  [W] cobox_aui :: a_au2 ~ t_arg
  a_au2
  a_au2
  t_arg
  t_arg
canEqTyVar
  a_au2
  t_arg
  Not-swapped
Following bound tyvar t_arg = a_atN
Following bound tyvar a_atN = a_atQ
Following bound tyvar a_atQ = a_atT
Following bound tyvar a_atT = a_atW
Following bound tyvar a_atW = a_atZ
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_aui :: a_au2
                                 ~ a_atZ [" a type equality Integer -> a_au2
                                                            ~
                                                            Integer
                                                            -> t_arg " p4.hs:13:31] (CTyEqCan)
Sneaky unification:
  Unifies: a_atZ := a_au2
  Coercion: a_atZ ~ a_au2
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_atZ := a_au2
setEvBind
  ev = cobox_aui
  tm  = CO <a_au2>_N
kickOutRewritable
  tv =  a_atZ
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
13[<C:0,F:0>] [W] cobox_aui :: a_au2 ~ a_atZ: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dNum_atO :: Num
                                  a_atN [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_atO :: Num
                                   a_atN [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_atO :: Num
                     a_atN [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
canEvNC:cls Num [a_atN]
Following bound tyvar a_atN = a_atQ
Following bound tyvar a_atQ = a_atT
Following bound tyvar a_atT = a_atW
Following bound tyvar a_atW = a_atZ
Following bound tyvar a_atZ = a_au2
canClass
  [W] $dNum_atO :: Num a_atN Num [a_atN]
  Num a_au2
  Just [W] $dNum_atO :: Num a_au2
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_atO :: Num
                                   a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dNum_atO :: Num
                                   a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
doTopReact
  [W] $dNum_atO :: Num
                     a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
matchClassInst
  pred = Num a_au2
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 0
          Solved funeqs 0
  untouchables= 0
matchClass not matching dict Num a_au2
end stage top-level reactions }
14[<C:0,F:0>] [W] $dNum_atO :: Num a_au2: Kept as inert
End solver pipeline (not discharged) }
  final_item =  [W] $dNum_atO :: Num
                                   a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
  a_au2
  inerts     =  Equalities:
                Type-function equalities:
                No-eqs: True
                Dictionaries:
                Irreds:
                Insolubles = {}
                Solved dicts 0
                Solved funeqs 0
insertInertItemTcS {
  Trying to insert new inert item: [W] $dNum_atO :: Num
                                                      a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
insertInertItemTcS }
Start solver pipeline {
  work item =  [W] $dNum_atR :: Num
                                  a_atQ [" the literal ‘4’ " p4.hs:13:23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_atO :: Num
                                                a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_atR :: Num
                                   a_atQ [" the literal ‘4’ " p4.hs:13:23] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_atR :: Num
                     a_atQ [" the literal ‘4’ " p4.hs:13:23] (CNonCanonical)
canEvNC:cls Num [a_atQ]
Following bound tyvar a_atQ = a_atT
Following bound tyvar a_atT = a_atW
Following bound tyvar a_atW = a_atZ
Following bound tyvar a_atZ = a_au2
canClass
  [W] $dNum_atR :: Num a_atQ Num [a_atQ]
  Num a_au2
  Just [W] $dNum_atR :: Num a_au2
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_atR :: Num
                                   a_au2 [" the literal ‘4’ " p4.hs:13:23] (CDictCan)
setEvBind
  ev = $dNum_atR
  tm  = $dNum_atO
15[<C:0,F:0>] [W] $dNum_atR :: Num a_au2: Dict equal (keep)
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_atO :: Num
                                                a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dNum_atU :: Num
                                  a_atT [" the literal ‘6’ " p4.hs:13:25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_atO :: Num
                                                a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_atU :: Num
                                   a_atT [" the literal ‘6’ " p4.hs:13:25] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_atU :: Num
                     a_atT [" the literal ‘6’ " p4.hs:13:25] (CNonCanonical)
canEvNC:cls Num [a_atT]
Following bound tyvar a_atT = a_atW
Following bound tyvar a_atW = a_atZ
Following bound tyvar a_atZ = a_au2
canClass
  [W] $dNum_atU :: Num a_atT Num [a_atT]
  Num a_au2
  Just [W] $dNum_atU :: Num a_au2
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_atU :: Num
                                   a_au2 [" the literal ‘6’ " p4.hs:13:25] (CDictCan)
setEvBind
  ev = $dNum_atU
  tm  = $dNum_atO
16[<C:0,F:0>] [W] $dNum_atU :: Num a_au2: Dict equal (keep)
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_atO :: Num
                                                a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dNum_atX :: Num
                                  a_atW [" the literal ‘3’ " p4.hs:13:27] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_atO :: Num
                                                a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_atX :: Num
                                   a_atW [" the literal ‘3’ " p4.hs:13:27] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_atX :: Num
                     a_atW [" the literal ‘3’ " p4.hs:13:27] (CNonCanonical)
canEvNC:cls Num [a_atW]
Following bound tyvar a_atW = a_atZ
Following bound tyvar a_atZ = a_au2
canClass
  [W] $dNum_atX :: Num a_atW Num [a_atW]
  Num a_au2
  Just [W] $dNum_atX :: Num a_au2
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_atX :: Num
                                   a_au2 [" the literal ‘3’ " p4.hs:13:27] (CDictCan)
setEvBind
  ev = $dNum_atX
  tm  = $dNum_atO
17[<C:0,F:0>] [W] $dNum_atX :: Num a_au2: Dict equal (keep)
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_atO :: Num
                                                a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dNum_au0 :: Num
                                  a_atZ [" the literal ‘2’ " p4.hs:13:29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_atO :: Num
                                                a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_au0 :: Num
                                   a_atZ [" the literal ‘2’ " p4.hs:13:29] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_au0 :: Num
                     a_atZ [" the literal ‘2’ " p4.hs:13:29] (CNonCanonical)
canEvNC:cls Num [a_atZ]
Following bound tyvar a_atZ = a_au2
canClass
  [W] $dNum_au0 :: Num a_atZ Num [a_atZ]
  Num a_au2
  Just [W] $dNum_au0 :: Num a_au2
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_au0 :: Num
                                   a_au2 [" the literal ‘2’ " p4.hs:13:29] (CDictCan)
setEvBind
  ev = $dNum_au0
  tm  = $dNum_atO
18[<C:0,F:0>] [W] $dNum_au0 :: Num a_au2: Dict equal (keep)
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_atO :: Num
                                                a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dNum_au3 :: Num
                                  a_au2 [" the literal ‘5’ " p4.hs:13:31] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_atO :: Num
                                                a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_au3 :: Num
                                   a_au2 [" the literal ‘5’ " p4.hs:13:31] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_au3 :: Num
                     a_au2 [" the literal ‘5’ " p4.hs:13:31] (CNonCanonical)
canEvNC:cls Num [a_au2]
canClass
  [W] $dNum_au3 :: Num a_au2 Num [a_au2]
  Num a_au2
  Just [W] $dNum_au3 :: Num a_au2
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_au3 :: Num
                                   a_au2 [" the literal ‘5’ " p4.hs:13:31] (CDictCan)
setEvBind
  ev = $dNum_au3
  tm  = $dNum_atO
19[<C:0,F:0>] [W] $dNum_au3 :: Num a_au2: Dict equal (keep)
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_atO :: Num
                                                a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
solveFlats end } {}
simpl_loop, iteration 1
solveWanteds }
  unsolved_flats   = {[W] $dNum_atO :: Num
                                         a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)}
  unsolved_implics = {}
  current evbinds  = {cobox_arh = CO Sym cobox_au6,
                      cobox_atP = CO cobox_au7 -> cobox_au8, $dNum_atR = $dNum_atO,
                      cobox_atS = CO cobox_au9 -> cobox_aua, $dNum_atU = $dNum_atO,
                      cobox_atV = CO cobox_aub -> cobox_auc, $dNum_atX = $dNum_atO,
                      cobox_atY = CO cobox_aud -> cobox_aue, $dNum_au0 = $dNum_atO,
                      cobox_au1 = CO cobox_auf -> cobox_aug, $dNum_au3 = $dNum_atO,
                      cobox_au4 = CO cobox_auh -> cobox_aui, cobox_au6 = CO <[t_arg]>_N,
                      cobox_au7 = CO <Integer>_N, cobox_au8 = CO <a_atN>_N,
                      cobox_au9 = CO <Integer>_N, cobox_aua = CO <a_atQ>_N,
                      cobox_aub = CO <Integer>_N, cobox_auc = CO <a_atT>_N,
                      cobox_aud = CO <Integer>_N, cobox_aue = CO <a_atW>_N,
                      cobox_auf = CO <Integer>_N, cobox_aug = CO <a_atZ>_N,
                      cobox_auh = CO <Integer>_N, cobox_aui = CO <a_au2>_N}
  current tybinds  = (t_are, [t_arg])
                     (t_arg, a_atN)
                     (a_atN, a_atQ)
                     (a_atQ, a_atT)
                     (a_atT, a_atW)
                     (a_atW, a_atZ)
                     (a_atZ, a_au2)
  final wc = WC {wc_flat = [W] $dNum_atO :: Num
                                              a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)}
writeMetaTyVar t_are := [t_arg]
writeMetaTyVar t_arg := a_atN
writeMetaTyVar a_atN := a_atQ
writeMetaTyVar a_atQ := a_atT
writeMetaTyVar a_atT := a_atW
writeMetaTyVar a_atW := a_atZ
writeMetaTyVar a_atZ := a_au2
Constraint solver steps = 19
Start solver pipeline {
  work item =  [W] $dNum_atO :: Num
                                  a_au2 [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_atO :: Num
                                   a_au2 [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_atO :: Num
                     a_au2 [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
canEvNC:cls Num [a_au2]
canClass
  [W] $dNum_atO :: Num a_au2 Num [a_au2]
  Num a_au2
  Just [W] $dNum_atO :: Num a_au2
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_atO :: Num
                                   a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dNum_atO :: Num
                                   a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
doTopReact
  [W] $dNum_atO :: Num
                     a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
matchClassInst
  pred = Num a_au2
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 0
          Solved funeqs 0
  untouchables= 0
matchClass not matching dict Num a_au2
end stage top-level reactions }
1[<C:0,F:0>] [W] $dNum_atO :: Num a_au2: Kept as inert
End solver pipeline (not discharged) }
  final_item =  [W] $dNum_atO :: Num
                                   a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
  a_au2
  inerts     =  Equalities:
                Type-function equalities:
                No-eqs: True
                Dictionaries:
                Irreds:
                Insolubles = {}
                Solved dicts 0
                Solved funeqs 0
insertInertItemTcS {
  Trying to insert new inert item: [W] $dNum_atO :: Num
                                                      a_au2 [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
insertInertItemTcS }
Constraint solver steps = 1
simplifyWithApprox
  quant_pred_candidates = [Num a_au2]
  gbl_tvs= []
  zonked_tau_tvs= [(au2, a_au2)]
  pbound = [Num a_au2]
  bbound = []
  poly_qtvs = [(au2, a_au2)]
  constrained_tvs = [(au2, a_au2)]
  mr_bites = True
  qtvs = []
} simplifyInfer/no implication needed
addInlinePrags
  sL
  []
mkExport: check sig
  sL
  [a_au2]
  [a_au2]
u_tys 
  untch 0
  [a_au2] ~ [a_au2]
  a type equality [a_au2] ~ [a_au2]
u_tys 
  untch 0
  a_au2 ~ a_au2
  a type equality [a_au2] ~ [a_au2]
u_tys yields no coercion
u_tys yields no coercion
simplifyTop { wanted =  WC {}
solveWantedsTcMWithEvBinds wanted= WC {}
solveWanteds { WC {}
solveFlats {
solveFlats end } {}
simpl_loop, iteration 1
solveWanteds }
  unsolved_flats   = {}
  unsolved_implics = {}
  current evbinds  = {}
  current tybinds  =
  final wc = WC {}
End simplifyTop }
reportUnsolved {
reportUnsolved }
Binding:
  <NotTopLevel>
  [(sL, [a_au2])]
csb2 [sL]
} End of bindings for
  [sL]
  NonRecursive
  sL [a_au2]
env2 [(sL, Identifier[sL::[a_au2], <NotTopLevel>])]
------------------------------------------------
Bindings for { [dim]
Generalisation plan InferGen True False
tcMatchesFun
  dim
  t_auG
tcGen
tcBody t_auG
Instantiating
  length with [a_auJ]
              []
utype_defer
  cobox_auK
  Int
  t_auG
  a type equality Int ~ t_auG
  In the expression: length sL
  In an equation for ‘dim’: dim = length sL
tcPolyExprNC [a_auJ]
tcGen
utype_defer
  cobox_auL
  [a_au2]
  [a_auJ]
  a type equality [a_au2] ~ [a_auJ]
  In the first argument of ‘length’, namely ‘sL’
  In the expression: length sL
simplifyInfer call
  [(dim, t_auG)]
  WC {wc_flat = [W] cobox_auK :: Int ~ t_auG [" a type equality Int
                                                                ~
                                                                t_auG " p4.hs:14:21-29] (CNonCanonical)
                [W] cobox_auL :: [a_au2] ~ [a_auJ] [" a type equality [a_au2]
                                                                      ~
                                                                      [a_auJ] " p4.hs:14:28-29] (CNonCanonical)}
simplifyInfer {
  binds = [(dim, t_auG)]
  closed = False
  apply_mr = True
  (unzonked) wanted = WC {wc_flat = [W] cobox_auK :: Int
                                                     ~ t_auG [" a type equality Int
                                                                                ~
                                                                                t_auG " p4.hs:14:21-29] (CNonCanonical)
                                    [W] cobox_auL :: [a_au2] ~ [a_auJ] [" a type equality [a_au2]
                                                                                          ~
                                                                                          [a_auJ] " p4.hs:14:28-29] (CNonCanonical)}
solveWantedsTcMWithEvBinds
  wanted= WC {wc_flat = [W] cobox_auK :: Int
                                         ~ t_auG [" a type equality Int
                                                                    ~
                                                                    t_auG " p4.hs:14:21-29] (CNonCanonical)
                        [W] cobox_auL :: [a_au2] ~ [a_auJ] [" a type equality [a_au2]
                                                                              ~
                                                                              [a_auJ] " p4.hs:14:28-29] (CNonCanonical)}
solveWanteds {
  WC {wc_flat = [W] cobox_auK :: Int ~ t_auG [" a type equality Int
                                                                ~
                                                                t_auG " p4.hs:14:21-29] (CNonCanonical)
                [W] cobox_auL :: [a_au2] ~ [a_auJ] [" a type equality [a_au2]
                                                                      ~
                                                                      [a_auJ] " p4.hs:14:28-29] (CNonCanonical)}
solveFlats {
Start solver pipeline {
  work item =  [W] cobox_auK :: Int ~ t_auG [" a type equality Int
                                                               ~
                                                               t_auG " p4.hs:14:21-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_auK :: Int ~ t_auG [" a type equality Int
                                                                ~
                                                                t_auG " p4.hs:14:21-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_auK :: Int ~ t_auG [" a type equality Int
                                                  ~
                                                  t_auG " p4.hs:14:21-29] (CNonCanonical)
canEvNC:eq
  Int
  t_auG
can_eq_nc
  [W] cobox_auK :: Int ~ t_auG
  Int
  Int
  t_auG
  t_auG
canEqTyVar
  t_auG
  Int
  Is-swapped
newWantedEvVar/cache miss [W] cobox_auN :: t_auG ~ Int
setEvBind
  ev = cobox_auK
  tm  = CO Sym cobox_auN
rewriteEqEvidence
  [W] cobox_auK :: Int ~ t_auG
  t_auG
  Int
  Sym cobox_auN
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_auN :: t_auG ~ Int [" a type equality Int
                                                                ~
                                                                t_auG " p4.hs:14:21-29] (CTyEqCan)
Sneaky unification:
  Unifies: t_auG := Int
  Coercion: t_auG ~ Int
  Left Kind is: OpenKind
  Right Kind is: *
setWantedTyBind t_auG := Int
setEvBind
  ev = cobox_auN
  tm  = CO <Int>_N
kickOutRewritable
  tv =  t_auG
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
1[<C:0,F:0>] [W] cobox_auN :: t_auG ~ Int: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_auL :: [a_au2]
                                ~ [a_auJ] [" a type equality [a_au2]
                                                             ~
                                                             [a_auJ] " p4.hs:14:28-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_auL :: [a_au2]
                                 ~ [a_auJ] [" a type equality [a_au2]
                                                              ~
                                                              [a_auJ] " p4.hs:14:28-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_auL :: [a_au2] ~ [a_auJ] [" a type equality [a_au2]
                                                        ~
                                                        [a_auJ] " p4.hs:14:28-29] (CNonCanonical)
canEvNC:eq
  [a_au2]
  [a_auJ]
can_eq_nc
  [W] cobox_auL :: [a_au2] ~ [a_auJ]
  [a_au2]
  [a_au2]
  [a_auJ]
  [a_auJ]
newWantedEvVar/cache miss [W] cobox_auO :: a_au2 ~ a_auJ
setEvBind
  ev = cobox_auL
  tm  = CO [cobox_auO]_N
canEvNC:eq
  a_au2
  a_auJ
can_eq_nc
  [W] cobox_auO :: a_au2 ~ a_auJ
  a_au2
  a_au2
  a_auJ
  a_auJ
canEqTyVar
  a_au2
  a_auJ
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_auO :: a_au2
                                 ~ a_auJ [" a type equality [a_au2]
                                                            ~
                                                            [a_auJ] " p4.hs:14:28-29] (CTyEqCan)
Sneaky unification:
  Unifies: a_auJ := a_au2
  Coercion: a_auJ ~ a_au2
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_auJ := a_au2
setEvBind
  ev = cobox_auO
  tm  = CO <a_au2>_N
kickOutRewritable
  tv =  a_auJ
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
2[<C:0,F:0>] [W] cobox_auO :: a_au2 ~ a_auJ: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
solveFlats end } {}
simpl_loop, iteration 1
solveWanteds }
  unsolved_flats   = {}
  unsolved_implics = {}
  current evbinds  = {cobox_auK = CO Sym cobox_auN,
                      cobox_auL = CO [cobox_auO]_N, cobox_auN = CO <Int>_N,
                      cobox_auO = CO <a_au2>_N}
  current tybinds  = (t_auG, Int)
                     (a_auJ, a_au2)
  final wc = WC {}
writeMetaTyVar t_auG := Int
writeMetaTyVar a_auJ := a_au2
Constraint solver steps = 2
simplifyWithApprox
  quant_pred_candidates = []
  gbl_tvs= [(au2, a_au2)]
  zonked_tau_tvs= []
  pbound = []
  bbound = []
  poly_qtvs = []
  constrained_tvs = [(au2, a_au2)]
  mr_bites = False
  qtvs = []
} simplifyInfer/no implication needed
addInlinePrags
  dim
  []
mkExport: check sig
  dim
  Int
  Int
u_tys 
  untch 0
  Int ~ Int
  a type equality Int ~ Int
u_tys yields no coercion
simplifyTop { wanted =  WC {}
solveWantedsTcMWithEvBinds wanted= WC {}
solveWanteds { WC {}
solveFlats {
solveFlats end } {}
simpl_loop, iteration 1
solveWanteds }
  unsolved_flats   = {}
  unsolved_implics = {}
  current evbinds  = {}
  current tybinds  =
  final wc = WC {}
End simplifyTop }
reportUnsolved {
reportUnsolved }
Binding:
  <NotTopLevel>
  [(dim, Int)]
csb2 [dim]
} End of bindings for
  [dim]
  NonRecursive
  dim Int
env2 [(dim, Identifier[dim::Int, <NotTopLevel>])]
------------------------------------------------
Bindings for { [help]
Generalisation plan
  CheckGen help :: [FlatVector]
                   []
env2 []
tcMonoBinds
env2 []
tcRhs: fun bind
  help
  [FlatVector]
tcMatchesFun
  help
  [FlatVector]
tcGen
tcBody [FlatVector]
utype_defer
  cobox_auU
  [a_au2]
  [t_auT]
  a type equality [a_au2] ~ [t_auT]
  In the expression: sL
  In a stmt of a list comprehension: s <- sL
env2 [(s, Identifier[s::t_auT, <NotTopLevel>])]
utype_defer
  cobox_auV
  FlatVector
  FlatVector
  a type equality FlatVector ~ FlatVector
  In the expression: listFlatVector (1, s) [0 | i <- [1 .. s]]
  In the expression:
    [listFlatVector (1, s) [0 | i <- [1 .. s]] | s <- sL]
tcPolyExprNC (Int, Int)
tcGen
tcPolyExpr Int
tcPolyExprNC Int
tcGen
tcPolyExpr Int
tcPolyExprNC Int
tcGen
utype_defer
  cobox_auW
  t_auT
  Int
  a type equality t_auT ~ Int
  In the expression: s
  In the first argument of ‘listFlatVector’, namely ‘(1, s)’
tcPolyExprNC [Double]
tcGen
tcPolyExpr t_auX
tcPolyExprNC t_auX
tcGen
Instantiating
  fromInteger with [a_auY]
                   [Num a_auY]
instCallConstraints [$dNum_auZ]
utype_defer
  cobox_av0
  Integer -> a_auY
  Integer -> t_auX
  a type equality Integer -> a_auY ~ Integer -> t_auX
  In the expression: 1
  In the expression: [1 .. s]
  In a stmt of a list comprehension: i <- [1 .. s]
tcPolyExpr t_auX
tcPolyExprNC t_auX
tcGen
utype_defer
  cobox_av1
  t_auT
  t_auX
  a type equality t_auT ~ t_auX
  In the expression: s
  In the expression: [1 .. s]
instCallConstraints [$dEnum_awY]
env2 [(i, Identifier[i::t_auX, <NotTopLevel>])]
addInlinePrags
  help
  []
csb2 [help]
} End of bindings for
  [help]
  NonRecursive
  help [FlatVector]
env2 [(help, Identifier[help::[FlatVector], <TopLevel>])]
------------------------------------------------
Bindings for { [tmp]
Generalisation plan
  CheckGen tmp :: Vector FlatVector
                  []
env2 []
tcMonoBinds
env2 []
tcRhs: fun bind
  tmp
  Vector FlatVector
tcMatchesFun
  tmp
  Vector FlatVector
tcGen
tcBody Vector FlatVector
Instantiating
  listVector with [a_ax0]
                  []
utype_defer
  cobox_ax1
  Vector a_ax0
  Vector FlatVector
  a type equality Vector a_ax0 ~ Vector FlatVector
  In the expression: listVector (1, dim) help
  In an equation for ‘tmp’: tmp = listVector (1, dim) help
tcPolyExprNC (Int, Int)
tcGen
tcPolyExpr Int
tcPolyExprNC Int
tcGen
tcPolyExpr Int
tcPolyExprNC Int
tcGen
utype_defer
  cobox_ax2
  Int
  Int
  a type equality Int ~ Int
  In the expression: dim
  In the first argument of ‘listVector’, namely ‘(1, dim)’
tcPolyExprNC [a_ax0]
tcGen
utype_defer
  cobox_ax3
  [FlatVector]
  [a_ax0]
  a type equality [FlatVector] ~ [a_ax0]
  In the second argument of ‘listVector’, namely ‘help’
  In the expression: listVector (1, dim) help
addInlinePrags
  tmp
  []
csb2 [tmp]
} End of bindings for
  [tmp]
  NonRecursive
  tmp Vector FlatVector
env2 [(tmp, Identifier[tmp::Vector FlatVector, <TopLevel>])]
Instantiating
  >>= with [m_ax9]
           [Monad m_ax9]
instCallConstraints [$dMonad_axa]
utype_defer
  cobox_axe
  m_ax9 a_axb -> (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc
  t_ax4 -> (t_ax5 -> t_ax6) -> IO ()
  a type equality m_ax9 a_axb
                  -> (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc
                  ~
                  t_ax4 -> (t_ax5 -> t_ax6) -> IO ()
  In a stmt of a 'do' block: v <- thaw tmp
  In the expression:
    do { let sL = [1, 4, 6, 3, 2, 5]
             dim = length sL
             help :: [FlatVector]
             help = [listFlatVector (1, s) [0 | i <- [1 .. s]] | s <- sL]
             tmp :: Vector FlatVector
             tmp = listVector (1, dim) help;
         v <- thaw tmp;
         return () }
  In an equation for ‘main’:
      main
        = do { let sL = [1, 4, 6, 3, 2, 5]
                   dim = length sL
                   help :: [FlatVector]
                   help = [listFlatVector (1, s) [0 | i <- [1 .. s]] | s <- sL]
                   tmp :: Vector FlatVector
                   tmp = listVector (1, dim) help;
               v <- thaw tmp;
               return () }
Instantiating
  thaw with [a_axy, i_axz, e_axA, m_axB, b_axC]
            [GHC.Arr.Ix i_axz, Data.Array.Base.IArray a_axy e_axA,
             Data.Array.Base.MArray b_axC e_axA m_axB]
instCallConstraints [$dIx_axD, $dIArray_axE, $dMArray_axF]
utype_defer
  cobox_axG
  m_axB (b_axC i_axz e_axA)
  t_ax4
  a type equality m_axB (b_axC i_axz e_axA) ~ t_ax4
  In a stmt of a 'do' block: v <- thaw tmp
  In the expression:
    do { let sL = [1, 4, 6, 3, 2, 5]
             dim = length sL
             help :: [FlatVector]
             help = [listFlatVector (1, s) [0 | i <- [1 .. s]] | s <- sL]
             tmp :: Vector FlatVector
             tmp = listVector (1, dim) help;
         v <- thaw tmp;
         return () }
tcPolyExprNC a_axy i_axz e_axA
tcGen
utype_defer
  cobox_axH
  Vector FlatVector
  a_axy i_axz e_axA
  a type equality Vector FlatVector ~ a_axy i_axz e_axA
  In the first argument of ‘thaw’, namely ‘tmp’
  In a stmt of a 'do' block: v <- thaw tmp
env2 [(v, Identifier[v::t_ax5, <NotTopLevel>])]
Instantiating
  return with [m_axJ]
              [Monad m_axJ]
instCallConstraints [$dMonad_axK]
utype_defer
  cobox_axN
  m_axJ a_axL
  t_ax6
  a type equality m_axJ a_axL ~ t_ax6
  In a stmt of a 'do' block: return ()
  In the expression:
    do { let sL = [1, 4, 6, 3, 2, 5]
             dim = length sL
             help :: [FlatVector]
             help = [listFlatVector (1, s) [0 | i <- [1 .. s]] | s <- sL]
             tmp :: Vector FlatVector
             tmp = listVector (1, dim) help;
         v <- thaw tmp;
         return () }
tcPolyExprNC a_axL
tcGen
utype_defer
  cobox_axO
  ()
  a_axL
  a type equality () ~ a_axL
  In the first argument of ‘return’, namely ‘()’
  In a stmt of a 'do' block: return ()
addInlinePrags
  main
  []
csb2 [main]
} End of bindings for
  [main]
  NonRecursive
  main IO ()
env2 [(main, Identifier[main::IO (), <TopLevel>])]
Tc6
env2 []
Tc7
End of tcVectDecls: LIE:
  WC {wc_flat = [W] $dIArray_ar9 :: Data.Array.Base.IArray
                                      a_ar8
                                      e_ar7 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                [W] $dIx_ara :: GHC.Arr.Ix
                                  i_ar6 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                [W] cobox_arb :: ((i_ar6, i_ar6) -> [e_ar7] -> a_ar8 i_ar6 e_ar7)
                                 ~ ((Int, Int) -> [Double] -> FlatVector) [" a type equality (i_ar6,
                                                                                              i_ar6)
                                                                                             -> [e_ar7]
                                                                                             -> a_ar8 i_ar6 e_ar7
                                                                                             ~
                                                                                             (Int,
                                                                                              Int)
                                                                                             -> [Double]
                                                                                             -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
                [W] $dNum_atO :: Num
                                   a_au2 [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                [W] cobox_auU :: [a_au2] ~ [t_auT] [" a type equality [a_au2]
                                                                      ~
                                                                      [t_auT] " p4.hs:16:61-62] (CNonCanonical)
                [W] cobox_auV :: FlatVector
                                 ~ FlatVector [" a type equality FlatVector
                                                                 ~
                                                                 FlatVector " p4.hs:16:23-56] (CNonCanonical)
                [W] cobox_auW :: t_auT ~ Int [" a type equality t_auT
                                                                ~
                                                                Int " p4.hs:16:41] (CNonCanonical)
                [W] $dNum_auZ :: Num
                                   a_auY [" the literal ‘1’ " p4.hs:16:51] (CNonCanonical)
                [W] cobox_av0 :: (Integer -> a_auY)
                                 ~ (Integer -> t_auX) [" a type equality Integer -> a_auY
                                                                         ~
                                                                         Integer
                                                                         -> t_auX " p4.hs:16:51] (CNonCanonical)
                [W] cobox_av1 :: t_auT ~ t_auX [" a type equality t_auT
                                                                  ~
                                                                  t_auX " p4.hs:16:54] (CNonCanonical)
                [W] $dEnum_awY :: Enum
                                    t_auX [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CNonCanonical)
                [W] cobox_ax1 :: Vector a_ax0
                                 ~ Vector FlatVector [" a type equality Vector a_ax0
                                                                        ~
                                                                        Vector
                                                                          FlatVector " p4.hs:18:21-43] (CNonCanonical)
                [W] cobox_ax2 :: Int ~ Int [" a type equality Int
                                                              ~
                                                              Int " p4.hs:18:35-37] (CNonCanonical)
                [W] cobox_ax3 :: [FlatVector]
                                 ~ [a_ax0] [" a type equality [FlatVector]
                                                              ~
                                                              [a_ax0] " p4.hs:18:40-43] (CNonCanonical)
                [W] $dMonad_axa :: Monad
                                     m_ax9 [" a do statement " p4.hs:19:11-23] (CNonCanonical)
                [W] cobox_axe :: (m_ax9 a_axb
                                  -> (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc)
                                 ~ (t_ax4
                                    -> (t_ax5 -> t_ax6) -> IO ()) [" a type equality m_ax9 a_axb
                                                                                     -> (a_axb
                                                                                         -> m_ax9 b_axc)
                                                                                     -> m_ax9 b_axc
                                                                                     ~
                                                                                     t_ax4
                                                                                     -> (t_ax5
                                                                                         -> t_ax6)
                                                                                     -> IO
                                                                                          () " p4.hs:19:11-23] (CNonCanonical)
                [W] $dIx_axD :: GHC.Arr.Ix
                                  i_axz [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                [W] $dIArray_axE :: Data.Array.Base.IArray
                                      a_axy
                                      e_axA [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                [W] $dMArray_axF :: Data.Array.Base.MArray
                                      b_axC
                                      e_axA
                                      m_axB [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                [W] cobox_axG :: m_axB (b_axC i_axz e_axA)
                                 ~ t_ax4 [" a type equality m_axB (b_axC i_axz e_axA)
                                                            ~
                                                            t_ax4 " p4.hs:19:16-23] (CNonCanonical)
                [W] cobox_axH :: Vector FlatVector
                                 ~ a_axy i_axz e_axA [" a type equality Vector FlatVector
                                                                        ~
                                                                        a_axy i_axz e_axA " p4.hs:19:21-23] (CNonCanonical)
                [W] $dMonad_axK :: Monad
                                     m_axJ [" a use of ‘return’ " p4.hs:20:11-16] (CNonCanonical)
                [W] cobox_axN :: m_axJ a_axL ~ t_ax6 [" a type equality m_axJ a_axL
                                                                        ~
                                                                        t_ax6 " p4.hs:20:11-19] (CNonCanonical)
                [W] cobox_axO :: () ~ a_axL [" a type equality ()
                                                               ~
                                                               a_axL " p4.hs:20:18-19] (CNonCanonical)
      wc_impl = Implic {Untouchables = 1
                        Skolems = a
                        Flatten-skolems =
                        No-eqs = False
                        Given =
                        Wanted = WC {wc_flat = [W] $dIArray_ar1 :: Data.Array.Base.IArray
                                                                     a_ar0
                                                                     e_aqZ [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                               [W] $dIx_ar2 :: GHC.Arr.Ix
                                                                 i_aqY [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                               [W] cobox_ar3 :: ((i_aqY, i_aqY)
                                                                 -> [e_aqZ] -> a_ar0 i_aqY e_aqZ)
                                                                ~ ((Int, Int)
                                                                   -> [a]
                                                                   -> Vector
                                                                        a) [" a type equality (i_aqY,
                                                                                               i_aqY)
                                                                                              -> [e_aqZ]
                                                                                              -> a_ar0 i_aqY e_aqZ
                                                                                              ~
                                                                                              (Int,
                                                                                               Int)
                                                                                              -> [a]
                                                                                              -> Vector
                                                                                                   a " p4.hs:30:14-25] (CNonCanonical)}
                        Binds = EvBindsVar<ar4>
                        the type signature for
                          listVector :: (Int, Int) -> [a] -> Vector a}}
Tc7a
checkMain found Main main
utype_defer
  cobox_axQ
  IO ()
  IO t_axP
  a type equality IO () ~ IO t_axP
  In the expression: main
  When checking the type of the IO action ‘main’
Tc8
simplifyTop {
  wanted =  WC {wc_flat = [W] $dIArray_ar9 :: Data.Array.Base.IArray
                                                a_ar8
                                                e_ar7 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                          [W] $dIx_ara :: GHC.Arr.Ix
                                            i_ar6 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                          [W] cobox_arb :: ((i_ar6, i_ar6) -> [e_ar7] -> a_ar8 i_ar6 e_ar7)
                                           ~ ((Int, Int)
                                              -> [Double] -> FlatVector) [" a type equality (i_ar6,
                                                                                             i_ar6)
                                                                                            -> [e_ar7]
                                                                                            -> a_ar8 i_ar6 e_ar7
                                                                                            ~
                                                                                            (Int,
                                                                                             Int)
                                                                                            -> [Double]
                                                                                            -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
                          [W] $dNum_atO :: Num
                                             a_au2 [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                          [W] cobox_auU :: [a_au2] ~ [t_auT] [" a type equality [a_au2]
                                                                                ~
                                                                                [t_auT] " p4.hs:16:61-62] (CNonCanonical)
                          [W] cobox_auV :: FlatVector
                                           ~ FlatVector [" a type equality FlatVector
                                                                           ~
                                                                           FlatVector " p4.hs:16:23-56] (CNonCanonical)
                          [W] cobox_auW :: t_auT ~ Int [" a type equality t_auT
                                                                          ~
                                                                          Int " p4.hs:16:41] (CNonCanonical)
                          [W] $dNum_auZ :: Num
                                             a_auY [" the literal ‘1’ " p4.hs:16:51] (CNonCanonical)
                          [W] cobox_av0 :: (Integer -> a_auY)
                                           ~ (Integer -> t_auX) [" a type equality Integer -> a_auY
                                                                                   ~
                                                                                   Integer
                                                                                   -> t_auX " p4.hs:16:51] (CNonCanonical)
                          [W] cobox_av1 :: t_auT ~ t_auX [" a type equality t_auT
                                                                            ~
                                                                            t_auX " p4.hs:16:54] (CNonCanonical)
                          [W] $dEnum_awY :: Enum
                                              t_auX [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CNonCanonical)
                          [W] cobox_ax1 :: Vector a_ax0
                                           ~ Vector FlatVector [" a type equality Vector a_ax0
                                                                                  ~
                                                                                  Vector
                                                                                    FlatVector " p4.hs:18:21-43] (CNonCanonical)
                          [W] cobox_ax2 :: Int ~ Int [" a type equality Int
                                                                        ~
                                                                        Int " p4.hs:18:35-37] (CNonCanonical)
                          [W] cobox_ax3 :: [FlatVector]
                                           ~ [a_ax0] [" a type equality [FlatVector]
                                                                        ~
                                                                        [a_ax0] " p4.hs:18:40-43] (CNonCanonical)
                          [W] $dMonad_axa :: Monad
                                               m_ax9 [" a do statement " p4.hs:19:11-23] (CNonCanonical)
                          [W] cobox_axe :: (m_ax9 a_axb
                                            -> (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc)
                                           ~ (t_ax4
                                              -> (t_ax5 -> t_ax6)
                                              -> IO ()) [" a type equality m_ax9 a_axb
                                                                           -> (a_axb -> m_ax9 b_axc)
                                                                           -> m_ax9 b_axc
                                                                           ~
                                                                           t_ax4
                                                                           -> (t_ax5 -> t_ax6)
                                                                           -> IO
                                                                                () " p4.hs:19:11-23] (CNonCanonical)
                          [W] $dIx_axD :: GHC.Arr.Ix
                                            i_axz [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                          [W] $dIArray_axE :: Data.Array.Base.IArray
                                                a_axy
                                                e_axA [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                          [W] $dMArray_axF :: Data.Array.Base.MArray
                                                b_axC
                                                e_axA
                                                m_axB [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                          [W] cobox_axG :: m_axB (b_axC i_axz e_axA)
                                           ~ t_ax4 [" a type equality m_axB (b_axC i_axz e_axA)
                                                                      ~
                                                                      t_ax4 " p4.hs:19:16-23] (CNonCanonical)
                          [W] cobox_axH :: Vector FlatVector
                                           ~ a_axy i_axz e_axA [" a type equality Vector FlatVector
                                                                                  ~
                                                                                  a_axy i_axz e_axA " p4.hs:19:21-23] (CNonCanonical)
                          [W] $dMonad_axK :: Monad
                                               m_axJ [" a use of ‘return’ " p4.hs:20:11-16] (CNonCanonical)
                          [W] cobox_axN :: m_axJ a_axL ~ t_ax6 [" a type equality m_axJ a_axL
                                                                                  ~
                                                                                  t_ax6 " p4.hs:20:11-19] (CNonCanonical)
                          [W] cobox_axO :: () ~ a_axL [" a type equality ()
                                                                         ~
                                                                         a_axL " p4.hs:20:18-19] (CNonCanonical)
                          [W] cobox_axQ :: IO () ~ IO t_axP [" a type equality IO ()
                                                                               ~
                                                                               IO
                                                                                 t_axP " p4.hs:13:1] (CNonCanonical)
                wc_impl = Implic {Untouchables = 1
                                  Skolems = a
                                  Flatten-skolems =
                                  No-eqs = False
                                  Given =
                                  Wanted = WC {wc_flat = [W] $dIArray_ar1 :: Data.Array.Base.IArray
                                                                               a_ar0
                                                                               e_aqZ [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                                         [W] $dIx_ar2 :: GHC.Arr.Ix
                                                                           i_aqY [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                                         [W] cobox_ar3 :: ((i_aqY, i_aqY)
                                                                           -> [e_aqZ]
                                                                           -> a_ar0 i_aqY e_aqZ)
                                                                          ~ ((Int, Int)
                                                                             -> [a]
                                                                             -> Vector
                                                                                  a) [" a type equality (i_aqY,
                                                                                                         i_aqY)
                                                                                                        -> [e_aqZ]
                                                                                                        -> a_ar0 i_aqY e_aqZ
                                                                                                        ~
                                                                                                        (Int,
                                                                                                         Int)
                                                                                                        -> [a]
                                                                                                        -> Vector
                                                                                                             a " p4.hs:30:14-25] (CNonCanonical)}
                                  Binds = EvBindsVar<ar4>
                                  the type signature for
                                    listVector :: (Int, Int) -> [a] -> Vector a}}
solveWantedsTcMWithEvBinds
  wanted= WC {wc_flat = [W] $dIArray_ar9 :: Data.Array.Base.IArray
                                              a_ar8
                                              e_ar7 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                        [W] $dIx_ara :: GHC.Arr.Ix
                                          i_ar6 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                        [W] cobox_arb :: ((i_ar6, i_ar6) -> [e_ar7] -> a_ar8 i_ar6 e_ar7)
                                         ~ ((Int, Int)
                                            -> [Double] -> FlatVector) [" a type equality (i_ar6,
                                                                                           i_ar6)
                                                                                          -> [e_ar7]
                                                                                          -> a_ar8 i_ar6 e_ar7
                                                                                          ~
                                                                                          (Int, Int)
                                                                                          -> [Double]
                                                                                          -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
                        [W] $dNum_atO :: Num
                                           a_au2 [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                        [W] cobox_auU :: [a_au2] ~ [t_auT] [" a type equality [a_au2]
                                                                              ~
                                                                              [t_auT] " p4.hs:16:61-62] (CNonCanonical)
                        [W] cobox_auV :: FlatVector
                                         ~ FlatVector [" a type equality FlatVector
                                                                         ~
                                                                         FlatVector " p4.hs:16:23-56] (CNonCanonical)
                        [W] cobox_auW :: t_auT ~ Int [" a type equality t_auT
                                                                        ~
                                                                        Int " p4.hs:16:41] (CNonCanonical)
                        [W] $dNum_auZ :: Num
                                           a_auY [" the literal ‘1’ " p4.hs:16:51] (CNonCanonical)
                        [W] cobox_av0 :: (Integer -> a_auY)
                                         ~ (Integer -> t_auX) [" a type equality Integer -> a_auY
                                                                                 ~
                                                                                 Integer
                                                                                 -> t_auX " p4.hs:16:51] (CNonCanonical)
                        [W] cobox_av1 :: t_auT ~ t_auX [" a type equality t_auT
                                                                          ~
                                                                          t_auX " p4.hs:16:54] (CNonCanonical)
                        [W] $dEnum_awY :: Enum
                                            t_auX [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CNonCanonical)
                        [W] cobox_ax1 :: Vector a_ax0
                                         ~ Vector FlatVector [" a type equality Vector a_ax0
                                                                                ~
                                                                                Vector
                                                                                  FlatVector " p4.hs:18:21-43] (CNonCanonical)
                        [W] cobox_ax2 :: Int ~ Int [" a type equality Int
                                                                      ~
                                                                      Int " p4.hs:18:35-37] (CNonCanonical)
                        [W] cobox_ax3 :: [FlatVector]
                                         ~ [a_ax0] [" a type equality [FlatVector]
                                                                      ~
                                                                      [a_ax0] " p4.hs:18:40-43] (CNonCanonical)
                        [W] $dMonad_axa :: Monad
                                             m_ax9 [" a do statement " p4.hs:19:11-23] (CNonCanonical)
                        [W] cobox_axe :: (m_ax9 a_axb
                                          -> (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc)
                                         ~ (t_ax4
                                            -> (t_ax5 -> t_ax6)
                                            -> IO ()) [" a type equality m_ax9 a_axb
                                                                         -> (a_axb -> m_ax9 b_axc)
                                                                         -> m_ax9 b_axc
                                                                         ~
                                                                         t_ax4
                                                                         -> (t_ax5 -> t_ax6)
                                                                         -> IO
                                                                              () " p4.hs:19:11-23] (CNonCanonical)
                        [W] $dIx_axD :: GHC.Arr.Ix
                                          i_axz [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                        [W] $dIArray_axE :: Data.Array.Base.IArray
                                              a_axy
                                              e_axA [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                        [W] $dMArray_axF :: Data.Array.Base.MArray
                                              b_axC
                                              e_axA
                                              m_axB [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                        [W] cobox_axG :: m_axB (b_axC i_axz e_axA)
                                         ~ t_ax4 [" a type equality m_axB (b_axC i_axz e_axA)
                                                                    ~
                                                                    t_ax4 " p4.hs:19:16-23] (CNonCanonical)
                        [W] cobox_axH :: Vector FlatVector
                                         ~ a_axy i_axz e_axA [" a type equality Vector FlatVector
                                                                                ~
                                                                                a_axy i_axz e_axA " p4.hs:19:21-23] (CNonCanonical)
                        [W] $dMonad_axK :: Monad
                                             m_axJ [" a use of ‘return’ " p4.hs:20:11-16] (CNonCanonical)
                        [W] cobox_axN :: m_axJ a_axL ~ t_ax6 [" a type equality m_axJ a_axL
                                                                                ~
                                                                                t_ax6 " p4.hs:20:11-19] (CNonCanonical)
                        [W] cobox_axO :: () ~ a_axL [" a type equality ()
                                                                       ~
                                                                       a_axL " p4.hs:20:18-19] (CNonCanonical)
                        [W] cobox_axQ :: IO () ~ IO t_axP [" a type equality IO ()
                                                                             ~
                                                                             IO
                                                                               t_axP " p4.hs:13:1] (CNonCanonical)
              wc_impl = Implic {Untouchables = 1
                                Skolems = a
                                Flatten-skolems =
                                No-eqs = False
                                Given =
                                Wanted = WC {wc_flat = [W] $dIArray_ar1 :: Data.Array.Base.IArray
                                                                             a_ar0
                                                                             e_aqZ [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                                       [W] $dIx_ar2 :: GHC.Arr.Ix
                                                                         i_aqY [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                                       [W] cobox_ar3 :: ((i_aqY, i_aqY)
                                                                         -> [e_aqZ]
                                                                         -> a_ar0 i_aqY e_aqZ)
                                                                        ~ ((Int, Int)
                                                                           -> [a]
                                                                           -> Vector
                                                                                a) [" a type equality (i_aqY,
                                                                                                       i_aqY)
                                                                                                      -> [e_aqZ]
                                                                                                      -> a_ar0 i_aqY e_aqZ
                                                                                                      ~
                                                                                                      (Int,
                                                                                                       Int)
                                                                                                      -> [a]
                                                                                                      -> Vector
                                                                                                           a " p4.hs:30:14-25] (CNonCanonical)}
                                Binds = EvBindsVar<ar4>
                                the type signature for
                                  listVector :: (Int, Int) -> [a] -> Vector a}}
solveWanteds {
  WC {wc_flat = [W] $dIArray_ar9 :: Data.Array.Base.IArray
                                      a_ar8
                                      e_ar7 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                [W] $dIx_ara :: GHC.Arr.Ix
                                  i_ar6 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                [W] cobox_arb :: ((i_ar6, i_ar6) -> [e_ar7] -> a_ar8 i_ar6 e_ar7)
                                 ~ ((Int, Int) -> [Double] -> FlatVector) [" a type equality (i_ar6,
                                                                                              i_ar6)
                                                                                             -> [e_ar7]
                                                                                             -> a_ar8 i_ar6 e_ar7
                                                                                             ~
                                                                                             (Int,
                                                                                              Int)
                                                                                             -> [Double]
                                                                                             -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
                [W] $dNum_atO :: Num
                                   a_au2 [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                [W] cobox_auU :: [a_au2] ~ [t_auT] [" a type equality [a_au2]
                                                                      ~
                                                                      [t_auT] " p4.hs:16:61-62] (CNonCanonical)
                [W] cobox_auV :: FlatVector
                                 ~ FlatVector [" a type equality FlatVector
                                                                 ~
                                                                 FlatVector " p4.hs:16:23-56] (CNonCanonical)
                [W] cobox_auW :: t_auT ~ Int [" a type equality t_auT
                                                                ~
                                                                Int " p4.hs:16:41] (CNonCanonical)
                [W] $dNum_auZ :: Num
                                   a_auY [" the literal ‘1’ " p4.hs:16:51] (CNonCanonical)
                [W] cobox_av0 :: (Integer -> a_auY)
                                 ~ (Integer -> t_auX) [" a type equality Integer -> a_auY
                                                                         ~
                                                                         Integer
                                                                         -> t_auX " p4.hs:16:51] (CNonCanonical)
                [W] cobox_av1 :: t_auT ~ t_auX [" a type equality t_auT
                                                                  ~
                                                                  t_auX " p4.hs:16:54] (CNonCanonical)
                [W] $dEnum_awY :: Enum
                                    t_auX [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CNonCanonical)
                [W] cobox_ax1 :: Vector a_ax0
                                 ~ Vector FlatVector [" a type equality Vector a_ax0
                                                                        ~
                                                                        Vector
                                                                          FlatVector " p4.hs:18:21-43] (CNonCanonical)
                [W] cobox_ax2 :: Int ~ Int [" a type equality Int
                                                              ~
                                                              Int " p4.hs:18:35-37] (CNonCanonical)
                [W] cobox_ax3 :: [FlatVector]
                                 ~ [a_ax0] [" a type equality [FlatVector]
                                                              ~
                                                              [a_ax0] " p4.hs:18:40-43] (CNonCanonical)
                [W] $dMonad_axa :: Monad
                                     m_ax9 [" a do statement " p4.hs:19:11-23] (CNonCanonical)
                [W] cobox_axe :: (m_ax9 a_axb
                                  -> (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc)
                                 ~ (t_ax4
                                    -> (t_ax5 -> t_ax6) -> IO ()) [" a type equality m_ax9 a_axb
                                                                                     -> (a_axb
                                                                                         -> m_ax9 b_axc)
                                                                                     -> m_ax9 b_axc
                                                                                     ~
                                                                                     t_ax4
                                                                                     -> (t_ax5
                                                                                         -> t_ax6)
                                                                                     -> IO
                                                                                          () " p4.hs:19:11-23] (CNonCanonical)
                [W] $dIx_axD :: GHC.Arr.Ix
                                  i_axz [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                [W] $dIArray_axE :: Data.Array.Base.IArray
                                      a_axy
                                      e_axA [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                [W] $dMArray_axF :: Data.Array.Base.MArray
                                      b_axC
                                      e_axA
                                      m_axB [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                [W] cobox_axG :: m_axB (b_axC i_axz e_axA)
                                 ~ t_ax4 [" a type equality m_axB (b_axC i_axz e_axA)
                                                            ~
                                                            t_ax4 " p4.hs:19:16-23] (CNonCanonical)
                [W] cobox_axH :: Vector FlatVector
                                 ~ a_axy i_axz e_axA [" a type equality Vector FlatVector
                                                                        ~
                                                                        a_axy i_axz e_axA " p4.hs:19:21-23] (CNonCanonical)
                [W] $dMonad_axK :: Monad
                                     m_axJ [" a use of ‘return’ " p4.hs:20:11-16] (CNonCanonical)
                [W] cobox_axN :: m_axJ a_axL ~ t_ax6 [" a type equality m_axJ a_axL
                                                                        ~
                                                                        t_ax6 " p4.hs:20:11-19] (CNonCanonical)
                [W] cobox_axO :: () ~ a_axL [" a type equality ()
                                                               ~
                                                               a_axL " p4.hs:20:18-19] (CNonCanonical)
                [W] cobox_axQ :: IO () ~ IO t_axP [" a type equality IO ()
                                                                     ~
                                                                     IO
                                                                       t_axP " p4.hs:13:1] (CNonCanonical)
      wc_impl = Implic {Untouchables = 1
                        Skolems = a
                        Flatten-skolems =
                        No-eqs = False
                        Given =
                        Wanted = WC {wc_flat = [W] $dIArray_ar1 :: Data.Array.Base.IArray
                                                                     a_ar0
                                                                     e_aqZ [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                               [W] $dIx_ar2 :: GHC.Arr.Ix
                                                                 i_aqY [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                               [W] cobox_ar3 :: ((i_aqY, i_aqY)
                                                                 -> [e_aqZ] -> a_ar0 i_aqY e_aqZ)
                                                                ~ ((Int, Int)
                                                                   -> [a]
                                                                   -> Vector
                                                                        a) [" a type equality (i_aqY,
                                                                                               i_aqY)
                                                                                              -> [e_aqZ]
                                                                                              -> a_ar0 i_aqY e_aqZ
                                                                                              ~
                                                                                              (Int,
                                                                                               Int)
                                                                                              -> [a]
                                                                                              -> Vector
                                                                                                   a " p4.hs:30:14-25] (CNonCanonical)}
                        Binds = EvBindsVar<ar4>
                        the type signature for
                          listVector :: (Int, Int) -> [a] -> Vector a}}
solveFlats {
Start solver pipeline {
  work item =  [W] cobox_arb :: ((i_ar6, i_ar6)
                                 -> [e_ar7] -> a_ar8 i_ar6 e_ar7)
                                ~ ((Int, Int) -> [Double] -> FlatVector) [" a type equality (i_ar6,
                                                                                             i_ar6)
                                                                                            -> [e_ar7]
                                                                                            -> a_ar8 i_ar6 e_ar7
                                                                                            ~
                                                                                            (Int,
                                                                                             Int)
                                                                                            -> [Double]
                                                                                            -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_arb :: ((i_ar6, i_ar6)
                                  -> [e_ar7] -> a_ar8 i_ar6 e_ar7)
                                 ~ ((Int, Int) -> [Double] -> FlatVector) [" a type equality (i_ar6,
                                                                                              i_ar6)
                                                                                             -> [e_ar7]
                                                                                             -> a_ar8 i_ar6 e_ar7
                                                                                             ~
                                                                                             (Int,
                                                                                              Int)
                                                                                             -> [Double]
                                                                                             -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_arb :: ((i_ar6, i_ar6) -> [e_ar7] -> a_ar8 i_ar6 e_ar7)
                   ~ ((Int, Int) -> [Double] -> FlatVector) [" a type equality (i_ar6,
                                                                                i_ar6)
                                                                               -> [e_ar7]
                                                                               -> a_ar8 i_ar6 e_ar7
                                                                               ~
                                                                               (Int, Int)
                                                                               -> [Double]
                                                                               -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canEvNC:eq
  (i_ar6, i_ar6) -> [e_ar7] -> a_ar8 i_ar6 e_ar7
  (Int, Int) -> [Double] -> FlatVector
can_eq_nc
  [W] cobox_arb :: ((i_ar6, i_ar6) -> [e_ar7] -> a_ar8 i_ar6 e_ar7)
                   ~ ((Int, Int) -> [Double] -> FlatVector)
  (i_ar6, i_ar6) -> [e_ar7] -> a_ar8 i_ar6 e_ar7
  (i_ar6, i_ar6) -> [e_ar7] -> a_ar8 i_ar6 e_ar7
  (Int, Int) -> [Double] -> FlatVector
  (Int, Int) -> [Double] -> FlatVector
newWantedEvVar/cache miss
  [W] cobox_ay9 :: (i_ar6, i_ar6) ~ (Int, Int)
newWantedEvVar/cache miss
  [W] cobox_aya :: ([e_ar7] -> a_ar8 i_ar6 e_ar7)
                   ~ ([Double] -> FlatVector)
setEvBind
  ev = cobox_arb
  tm  = CO cobox_ay9 -> cobox_aya
canEvNC:eq
  (i_ar6, i_ar6)
  (Int, Int)
can_eq_nc
  [W] cobox_ay9 :: (i_ar6, i_ar6) ~ (Int, Int)
  (i_ar6, i_ar6)
  (i_ar6, i_ar6)
  (Int, Int)
  (Int, Int)
newWantedEvVar/cache miss [W] cobox_ayb :: i_ar6 ~ Int
newWantedEvVar/cache miss [W] cobox_ayc :: i_ar6 ~ Int
setEvBind
  ev = cobox_ay9
  tm  = CO (cobox_ayb, cobox_ayc)_N
canEvNC:eq
  i_ar6
  Int
can_eq_nc
  [W] cobox_ayb :: i_ar6 ~ Int
  i_ar6
  i_ar6
  Int
  Int
canEqTyVar
  i_ar6
  Int
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayb :: i_ar6
                                 ~ Int [" a type equality (i_ar6, i_ar6)
                                                          -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                          ~
                                                          (Int, Int)
                                                          -> [Double]
                                                          -> FlatVector " p4.hs:25:18-29] (CTyEqCan)
Sneaky unification:
  Unifies: i_ar6 := Int
  Coercion: i_ar6 ~ Int
  Left Kind is: *
  Right Kind is: *
setWantedTyBind i_ar6 := Int
setEvBind
  ev = cobox_ayb
  tm  = CO <Int>_N
kickOutRewritable
  tv =  i_ar6
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
1[<C:0,F:0>] [W] cobox_ayb :: i_ar6 ~ Int: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ayc :: i_ar6
                                ~ Int [" a type equality (i_ar6, i_ar6)
                                                         -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                         ~
                                                         (Int, Int)
                                                         -> [Double]
                                                         -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ayc :: i_ar6
                                 ~ Int [" a type equality (i_ar6, i_ar6)
                                                          -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                          ~
                                                          (Int, Int)
                                                          -> [Double]
                                                          -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ayc :: i_ar6 ~ Int [" a type equality (i_ar6, i_ar6)
                                                  -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                  ~
                                                  (Int, Int)
                                                  -> [Double]
                                                  -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canEvNC:eq
  i_ar6
  Int
can_eq_nc
  [W] cobox_ayc :: i_ar6 ~ Int
  i_ar6
  i_ar6
  Int
  Int
canEqTyVar
  i_ar6
  Int
  Not-swapped
Following bound tyvar i_ar6 = Int
canEqTyVar2
  i_ar6
  Int
  Not-swapped
  Int
  <Int>_N
can_eq_nc
  [W] cobox_ayc :: Int ~ Int
  Int
  Int
  Int
  Int
setEvBind
  ev = cobox_ayc
  tm  = CO <Int>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_aya :: ([e_ar7] -> a_ar8 i_ar6 e_ar7)
                                ~ ([Double] -> FlatVector) [" a type equality (i_ar6, i_ar6)
                                                                              -> [e_ar7]
                                                                              -> a_ar8 i_ar6 e_ar7
                                                                              ~
                                                                              (Int, Int)
                                                                              -> [Double]
                                                                              -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_aya :: ([e_ar7] -> a_ar8 i_ar6 e_ar7)
                                 ~ ([Double] -> FlatVector) [" a type equality (i_ar6, i_ar6)
                                                                               -> [e_ar7]
                                                                               -> a_ar8 i_ar6 e_ar7
                                                                               ~
                                                                               (Int, Int)
                                                                               -> [Double]
                                                                               -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_aya :: ([e_ar7] -> a_ar8 i_ar6 e_ar7)
                   ~ ([Double] -> FlatVector) [" a type equality (i_ar6, i_ar6)
                                                                 -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                                 ~
                                                                 (Int, Int)
                                                                 -> [Double]
                                                                 -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canEvNC:eq
  [e_ar7] -> a_ar8 i_ar6 e_ar7
  [Double] -> FlatVector
can_eq_nc
  [W] cobox_aya :: ([e_ar7] -> a_ar8 i_ar6 e_ar7)
                   ~ ([Double] -> FlatVector)
  [e_ar7] -> a_ar8 i_ar6 e_ar7
  [e_ar7] -> a_ar8 i_ar6 e_ar7
  [Double] -> FlatVector
  [Double] -> FlatVector
newWantedEvVar/cache miss [W] cobox_ayd :: [e_ar7] ~ [Double]
newWantedEvVar/cache miss
  [W] cobox_aye :: a_ar8 i_ar6 e_ar7 ~ FlatVector
setEvBind
  ev = cobox_aya
  tm  = CO cobox_ayd -> cobox_aye
canEvNC:eq
  [e_ar7]
  [Double]
can_eq_nc
  [W] cobox_ayd :: [e_ar7] ~ [Double]
  [e_ar7]
  [e_ar7]
  [Double]
  [Double]
newWantedEvVar/cache miss [W] cobox_ayf :: e_ar7 ~ Double
setEvBind
  ev = cobox_ayd
  tm  = CO [cobox_ayf]_N
canEvNC:eq
  e_ar7
  Double
can_eq_nc
  [W] cobox_ayf :: e_ar7 ~ Double
  e_ar7
  e_ar7
  Double
  Double
canEqTyVar
  e_ar7
  Double
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayf :: e_ar7
                                 ~ Double [" a type equality (i_ar6, i_ar6)
                                                             -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                             ~
                                                             (Int, Int)
                                                             -> [Double]
                                                             -> FlatVector " p4.hs:25:18-29] (CTyEqCan)
Sneaky unification:
  Unifies: e_ar7 := Double
  Coercion: e_ar7 ~ Double
  Left Kind is: *
  Right Kind is: *
setWantedTyBind e_ar7 := Double
setEvBind
  ev = cobox_ayf
  tm  = CO <Double>_N
kickOutRewritable
  tv =  e_ar7
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
3[<C:0,F:0>] [W] cobox_ayf :: e_ar7 ~ Double: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_aye :: a_ar8 i_ar6 e_ar7
                                ~ FlatVector [" a type equality (i_ar6, i_ar6)
                                                                -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                                ~
                                                                (Int, Int)
                                                                -> [Double]
                                                                -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_aye :: a_ar8 i_ar6 e_ar7
                                 ~ FlatVector [" a type equality (i_ar6, i_ar6)
                                                                 -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                                 ~
                                                                 (Int, Int)
                                                                 -> [Double]
                                                                 -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_aye :: a_ar8 i_ar6 e_ar7
                   ~ FlatVector [" a type equality (i_ar6, i_ar6)
                                                   -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                   ~
                                                   (Int, Int)
                                                   -> [Double]
                                                   -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canEvNC:eq
  a_ar8 i_ar6 e_ar7
  FlatVector
can_eq_nc
  [W] cobox_aye :: a_ar8 i_ar6 e_ar7 ~ FlatVector
  a_ar8 i_ar6 e_ar7
  a_ar8 i_ar6 e_ar7
  FlatVector
  FlatVector
can_eq_nc
  [W] cobox_aye :: a_ar8 i_ar6 e_ar7 ~ FlatVector
  a_ar8 i_ar6 e_ar7
  a_ar8 i_ar6 e_ar7
  UArray Int Double
  FlatVector
can_eq_app 1
  [W] cobox_aye :: a_ar8 i_ar6 e_ar7 ~ FlatVector
  Not-swapped
  a_ar8 i_ar6
  e_ar7
  UArray Int Double
Following bound tyvar i_ar6 = Int
flatten/appty
  a_ar8
  i_ar6
  a_ar8
  <a_ar8>_N
  Int
  <Int>_N
can_eq_app 2
  [W] cobox_aye :: a_ar8 i_ar6 e_ar7 ~ FlatVector
  a_ar8 Int
Following bound tyvar e_ar7 = Double
can_eq_app 3
  [W] cobox_aye :: a_ar8 i_ar6 e_ar7 ~ FlatVector
  a_ar8 Int Double
  <a_ar8 Int Double>_N
can_eq_app 4
  [W] cobox_aye :: a_ar8 i_ar6 e_ar7 ~ FlatVector
  a_ar8 Int Double
  <a_ar8 Int Double>_N
can_eq_nc
  [W] cobox_aye :: a_ar8 Int Double ~ FlatVector
  a_ar8 Int Double
  a_ar8 Int Double
  UArray Int Double
  FlatVector
can_eq_app 1
  [W] cobox_aye :: a_ar8 Int Double ~ FlatVector
  Not-swapped
  a_ar8 Int
  Double
  UArray Int Double
flatten/appty
  a_ar8
  Int
  a_ar8
  <a_ar8>_N
  Int
  <Int>_N
can_eq_app 2
  [W] cobox_aye :: a_ar8 Int Double ~ FlatVector
  a_ar8 Int
newWantedEvVar/cache miss [W] cobox_ayg :: a_ar8 Int ~ UArray Int
newWantedEvVar/cache miss [W] cobox_ayh :: Double ~ Double
setEvBind
  ev = cobox_aye
  tm  = CO cobox_ayg cobox_ayh
canEvNC:eq
  a_ar8 Int
  UArray Int
can_eq_nc
  [W] cobox_ayg :: a_ar8 Int ~ UArray Int
  a_ar8 Int
  a_ar8 Int
  UArray Int
  UArray Int
can_eq_app 1
  [W] cobox_ayg :: a_ar8 Int ~ UArray Int
  Not-swapped
  a_ar8
  Int
  UArray Int
can_eq_app 2
  [W] cobox_ayg :: a_ar8 Int ~ UArray Int
  a_ar8
newWantedEvVar/cache miss [W] cobox_ayi :: a_ar8 ~ UArray
newWantedEvVar/cache miss [W] cobox_ayj :: Int ~ Int
setEvBind
  ev = cobox_ayg
  tm  = CO cobox_ayi cobox_ayj
canEvNC:eq
  a_ar8
  UArray
can_eq_nc
  [W] cobox_ayi :: a_ar8 ~ UArray
  a_ar8
  a_ar8
  UArray
  UArray
canEqTyVar
  a_ar8
  UArray
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayi :: a_ar8
                                 ~ UArray [" a type equality (i_ar6, i_ar6)
                                                             -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                             ~
                                                             (Int, Int)
                                                             -> [Double]
                                                             -> FlatVector " p4.hs:25:18-29] (CTyEqCan)
Sneaky unification:
  Unifies: a_ar8 := UArray
  Coercion: a_ar8 ~ UArray
  Left Kind is: * -> * -> *
  Right Kind is: * -> * -> *
setWantedTyBind a_ar8 := UArray
setEvBind
  ev = cobox_ayi
  tm  = CO <UArray>_N
kickOutRewritable
  tv =  a_ar8
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
4[<C:0,F:0>] [W] cobox_ayi :: a_ar8 ~ UArray: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ayj :: Int ~ Int [" a type equality (i_ar6,
                                                              i_ar6)
                                                             -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                             ~
                                                             (Int, Int)
                                                             -> [Double]
                                                             -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ayj :: Int ~ Int [" a type equality (i_ar6,
                                                               i_ar6)
                                                              -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                              ~
                                                              (Int, Int)
                                                              -> [Double]
                                                              -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ayj :: Int ~ Int [" a type equality (i_ar6, i_ar6)
                                                -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                ~
                                                (Int, Int)
                                                -> [Double]
                                                -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canEvNC:eq
  Int
  Int
can_eq_nc
  [W] cobox_ayj :: Int ~ Int
  Int
  Int
  Int
  Int
setEvBind
  ev = cobox_ayj
  tm  = CO <Int>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ayh :: Double
                                ~ Double [" a type equality (i_ar6, i_ar6)
                                                            -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                            ~
                                                            (Int, Int)
                                                            -> [Double]
                                                            -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ayh :: Double
                                 ~ Double [" a type equality (i_ar6, i_ar6)
                                                             -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                             ~
                                                             (Int, Int)
                                                             -> [Double]
                                                             -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ayh :: Double ~ Double [" a type equality (i_ar6, i_ar6)
                                                      -> [e_ar7] -> a_ar8 i_ar6 e_ar7
                                                      ~
                                                      (Int, Int)
                                                      -> [Double]
                                                      -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canEvNC:eq
  Double
  Double
can_eq_nc
  [W] cobox_ayh :: Double ~ Double
  Double
  Double
  Double
  Double
setEvBind
  ev = cobox_ayh
  tm  = CO <Double>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_auU :: [a_au2]
                                ~ [t_auT] [" a type equality [a_au2]
                                                             ~
                                                             [t_auT] " p4.hs:16:61-62] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_auU :: [a_au2]
                                 ~ [t_auT] [" a type equality [a_au2]
                                                              ~
                                                              [t_auT] " p4.hs:16:61-62] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_auU :: [a_au2] ~ [t_auT] [" a type equality [a_au2]
                                                        ~
                                                        [t_auT] " p4.hs:16:61-62] (CNonCanonical)
canEvNC:eq
  [a_au2]
  [t_auT]
can_eq_nc
  [W] cobox_auU :: [a_au2] ~ [t_auT]
  [a_au2]
  [a_au2]
  [t_auT]
  [t_auT]
newWantedEvVar/cache miss [W] cobox_ayk :: a_au2 ~ t_auT
setEvBind
  ev = cobox_auU
  tm  = CO [cobox_ayk]_N
canEvNC:eq
  a_au2
  t_auT
can_eq_nc
  [W] cobox_ayk :: a_au2 ~ t_auT
  a_au2
  a_au2
  t_auT
  t_auT
canEqTyVar
  a_au2
  t_auT
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayk :: a_au2
                                 ~ t_auT [" a type equality [a_au2]
                                                            ~
                                                            [t_auT] " p4.hs:16:61-62] (CTyEqCan)
Sneaky unification:
  Unifies: t_auT := a_au2
  Coercion: t_auT ~ a_au2
  Left Kind is: *
  Right Kind is: *
setWantedTyBind t_auT := a_au2
setEvBind
  ev = cobox_ayk
  tm  = CO <a_au2>_N
kickOutRewritable
  tv =  t_auT
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
7[<C:0,F:0>] [W] cobox_ayk :: a_au2 ~ t_auT: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_auV :: FlatVector
                                ~ FlatVector [" a type equality FlatVector
                                                                ~
                                                                FlatVector " p4.hs:16:23-56] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_auV :: FlatVector
                                 ~ FlatVector [" a type equality FlatVector
                                                                 ~
                                                                 FlatVector " p4.hs:16:23-56] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_auV :: FlatVector
                   ~ FlatVector [" a type equality FlatVector
                                                   ~
                                                   FlatVector " p4.hs:16:23-56] (CNonCanonical)
canEvNC:eq
  FlatVector
  FlatVector
can_eq_nc
  [W] cobox_auV :: FlatVector ~ FlatVector
  FlatVector
  FlatVector
  FlatVector
  FlatVector
can_eq_nc
  [W] cobox_auV :: FlatVector ~ FlatVector
  UArray Int Double
  FlatVector
  FlatVector
  FlatVector
can_eq_nc
  [W] cobox_auV :: FlatVector ~ FlatVector
  UArray Int Double
  FlatVector
  UArray Int Double
  FlatVector
newWantedEvVar/cache miss [W] cobox_ayl :: Int ~ Int
newWantedEvVar/cache miss [W] cobox_aym :: Double ~ Double
setEvBind
  ev = cobox_auV
  tm  = CO UArray cobox_ayl cobox_aym_N
canEvNC:eq
  Int
  Int
can_eq_nc
  [W] cobox_ayl :: Int ~ Int
  Int
  Int
  Int
  Int
setEvBind
  ev = cobox_ayl
  tm  = CO <Int>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_aym :: Double
                                ~ Double [" a type equality FlatVector
                                                            ~
                                                            FlatVector " p4.hs:16:23-56] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_aym :: Double
                                 ~ Double [" a type equality FlatVector
                                                             ~
                                                             FlatVector " p4.hs:16:23-56] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_aym :: Double ~ Double [" a type equality FlatVector
                                                      ~
                                                      FlatVector " p4.hs:16:23-56] (CNonCanonical)
canEvNC:eq
  Double
  Double
can_eq_nc
  [W] cobox_aym :: Double ~ Double
  Double
  Double
  Double
  Double
setEvBind
  ev = cobox_aym
  tm  = CO <Double>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_auW :: t_auT ~ Int [" a type equality t_auT
                                                               ~
                                                               Int " p4.hs:16:41] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_auW :: t_auT ~ Int [" a type equality t_auT
                                                                ~
                                                                Int " p4.hs:16:41] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_auW :: t_auT ~ Int [" a type equality t_auT
                                                  ~
                                                  Int " p4.hs:16:41] (CNonCanonical)
canEvNC:eq
  t_auT
  Int
can_eq_nc
  [W] cobox_auW :: t_auT ~ Int
  t_auT
  t_auT
  Int
  Int
canEqTyVar
  t_auT
  Int
  Not-swapped
Following bound tyvar t_auT = a_au2
canEqTyVar2
  t_auT
  Int
  Not-swapped
  a_au2
  <a_au2>_N
can_eq_nc
  [W] cobox_auW :: a_au2 ~ Int
  a_au2
  a_au2
  Int
  Int
canEqTyVar
  a_au2
  Int
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_auW :: a_au2 ~ Int [" a type equality t_auT
                                                                ~
                                                                Int " p4.hs:16:41] (CTyEqCan)
Sneaky unification:
  Unifies: a_au2 := Int
  Coercion: a_au2 ~ Int
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_au2 := Int
setEvBind
  ev = cobox_auW
  tm  = CO <Int>_N
kickOutRewritable
  tv =  a_au2
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
10[<C:0,F:0>] [W] cobox_auW :: a_au2 ~ Int: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_av0 :: (Integer -> a_auY)
                                ~ (Integer -> t_auX) [" a type equality Integer -> a_auY
                                                                        ~
                                                                        Integer
                                                                        -> t_auX " p4.hs:16:51] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_av0 :: (Integer -> a_auY)
                                 ~ (Integer -> t_auX) [" a type equality Integer -> a_auY
                                                                         ~
                                                                         Integer
                                                                         -> t_auX " p4.hs:16:51] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_av0 :: (Integer -> a_auY)
                   ~ (Integer -> t_auX) [" a type equality Integer -> a_auY
                                                           ~
                                                           Integer
                                                           -> t_auX " p4.hs:16:51] (CNonCanonical)
canEvNC:eq
  Integer -> a_auY
  Integer -> t_auX
can_eq_nc
  [W] cobox_av0 :: (Integer -> a_auY) ~ (Integer -> t_auX)
  Integer -> a_auY
  Integer -> a_auY
  Integer -> t_auX
  Integer -> t_auX
newWantedEvVar/cache miss [W] cobox_ayn :: Integer ~ Integer
newWantedEvVar/cache miss [W] cobox_ayo :: a_auY ~ t_auX
setEvBind
  ev = cobox_av0
  tm  = CO cobox_ayn -> cobox_ayo
canEvNC:eq
  Integer
  Integer
can_eq_nc
  [W] cobox_ayn :: Integer ~ Integer
  Integer
  Integer
  Integer
  Integer
setEvBind
  ev = cobox_ayn
  tm  = CO <Integer>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ayo :: a_auY
                                ~ t_auX [" a type equality Integer -> a_auY
                                                           ~
                                                           Integer
                                                           -> t_auX " p4.hs:16:51] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ayo :: a_auY
                                 ~ t_auX [" a type equality Integer -> a_auY
                                                            ~
                                                            Integer
                                                            -> t_auX " p4.hs:16:51] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ayo :: a_auY ~ t_auX [" a type equality Integer -> a_auY
                                                    ~
                                                    Integer -> t_auX " p4.hs:16:51] (CNonCanonical)
canEvNC:eq
  a_auY
  t_auX
can_eq_nc
  [W] cobox_ayo :: a_auY ~ t_auX
  a_auY
  a_auY
  t_auX
  t_auX
canEqTyVar
  a_auY
  t_auX
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayo :: a_auY
                                 ~ t_auX [" a type equality Integer -> a_auY
                                                            ~
                                                            Integer
                                                            -> t_auX " p4.hs:16:51] (CTyEqCan)
Sneaky unification:
  Unifies: t_auX := a_auY
  Coercion: t_auX ~ a_auY
  Left Kind is: *
  Right Kind is: *
setWantedTyBind t_auX := a_auY
setEvBind
  ev = cobox_ayo
  tm  = CO <a_auY>_N
kickOutRewritable
  tv =  t_auX
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
12[<C:0,F:0>] [W] cobox_ayo :: a_auY ~ t_auX: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_av1 :: t_auT
                                ~ t_auX [" a type equality t_auT
                                                           ~
                                                           t_auX " p4.hs:16:54] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_av1 :: t_auT
                                 ~ t_auX [" a type equality t_auT
                                                            ~
                                                            t_auX " p4.hs:16:54] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_av1 :: t_auT ~ t_auX [" a type equality t_auT
                                                    ~
                                                    t_auX " p4.hs:16:54] (CNonCanonical)
canEvNC:eq
  t_auT
  t_auX
can_eq_nc
  [W] cobox_av1 :: t_auT ~ t_auX
  t_auT
  t_auT
  t_auX
  t_auX
canEqTyVar
  t_auT
  t_auX
  Not-swapped
Following bound tyvar t_auT = a_au2
canEqTyVar2
  t_auT
  t_auX
  Not-swapped
  a_au2
  <a_au2>_N
can_eq_nc
  [W] cobox_av1 :: a_au2 ~ t_auX
  a_au2
  a_au2
  t_auX
  t_auX
canEqTyVar
  a_au2
  t_auX
  Not-swapped
Following bound tyvar a_au2 = Int
canEqTyVar2
  a_au2
  t_auX
  Not-swapped
  Int
  <Int>_N
can_eq_nc
  [W] cobox_av1 :: Int ~ t_auX
  Int
  Int
  t_auX
  t_auX
canEqTyVar
  t_auX
  Int
  Is-swapped
Following bound tyvar t_auX = a_auY
newWantedEvVar/cache miss [W] cobox_ayp :: a_auY ~ Int
setEvBind
  ev = cobox_av1
  tm  = CO Sym cobox_ayp
rewriteEqEvidence
  [W] cobox_av1 :: Int ~ t_auX
  a_auY
  Int
  Sym cobox_ayp
canEqTyVar2
  t_auX
  Int
  Is-swapped
  a_auY
  <a_auY>_N
can_eq_nc
  [W] cobox_ayp :: a_auY ~ Int
  a_auY
  a_auY
  Int
  Int
canEqTyVar
  a_auY
  Int
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayp :: a_auY ~ Int [" a type equality t_auT
                                                                ~
                                                                t_auX " p4.hs:16:54] (CTyEqCan)
Sneaky unification:
  Unifies: a_auY := Int
  Coercion: a_auY ~ Int
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_auY := Int
setEvBind
  ev = cobox_ayp
  tm  = CO <Int>_N
kickOutRewritable
  tv =  a_auY
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
13[<C:0,F:0>] [W] cobox_ayp :: a_auY ~ Int: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ax1 :: Vector a_ax0
                                ~ Vector FlatVector [" a type equality Vector a_ax0
                                                                       ~
                                                                       Vector
                                                                         FlatVector " p4.hs:18:21-43] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ax1 :: Vector a_ax0
                                 ~ Vector FlatVector [" a type equality Vector a_ax0
                                                                        ~
                                                                        Vector
                                                                          FlatVector " p4.hs:18:21-43] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ax1 :: Vector a_ax0
                   ~ Vector FlatVector [" a type equality Vector a_ax0
                                                          ~
                                                          Vector
                                                            FlatVector " p4.hs:18:21-43] (CNonCanonical)
canEvNC:eq
  Vector a_ax0
  Vector FlatVector
can_eq_nc
  [W] cobox_ax1 :: Vector a_ax0 ~ Vector FlatVector
  Vector a_ax0
  Vector a_ax0
  Vector FlatVector
  Vector FlatVector
can_eq_nc
  [W] cobox_ax1 :: Vector a_ax0 ~ Vector FlatVector
  Array Int a_ax0
  Vector a_ax0
  Vector FlatVector
  Vector FlatVector
can_eq_nc
  [W] cobox_ax1 :: Vector a_ax0 ~ Vector FlatVector
  Array Int a_ax0
  Vector a_ax0
  Array Int FlatVector
  Vector FlatVector
newWantedEvVar/cache miss [W] cobox_ayq :: Int ~ Int
newWantedEvVar/cache miss [W] cobox_ayr :: a_ax0 ~ FlatVector
setEvBind
  ev = cobox_ax1
  tm  = CO Array cobox_ayq cobox_ayr_N
canEvNC:eq
  Int
  Int
can_eq_nc
  [W] cobox_ayq :: Int ~ Int
  Int
  Int
  Int
  Int
setEvBind
  ev = cobox_ayq
  tm  = CO <Int>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ayr :: a_ax0
                                ~ FlatVector [" a type equality Vector a_ax0
                                                                ~
                                                                Vector
                                                                  FlatVector " p4.hs:18:21-43] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ayr :: a_ax0
                                 ~ FlatVector [" a type equality Vector a_ax0
                                                                 ~
                                                                 Vector
                                                                   FlatVector " p4.hs:18:21-43] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ayr :: a_ax0 ~ FlatVector [" a type equality Vector a_ax0
                                                         ~
                                                         Vector
                                                           FlatVector " p4.hs:18:21-43] (CNonCanonical)
canEvNC:eq
  a_ax0
  FlatVector
can_eq_nc
  [W] cobox_ayr :: a_ax0 ~ FlatVector
  a_ax0
  a_ax0
  FlatVector
  FlatVector
can_eq_nc
  [W] cobox_ayr :: a_ax0 ~ FlatVector
  a_ax0
  a_ax0
  UArray Int Double
  FlatVector
canEqTyVar
  a_ax0
  UArray Int Double
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayr :: a_ax0
                                 ~ FlatVector [" a type equality Vector a_ax0
                                                                 ~
                                                                 Vector
                                                                   FlatVector " p4.hs:18:21-43] (CTyEqCan)
Sneaky unification:
  Unifies: a_ax0 := FlatVector
  Coercion: a_ax0 ~ FlatVector
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_ax0 := FlatVector
setEvBind
  ev = cobox_ayr
  tm  = CO <FlatVector>_N
kickOutRewritable
  tv =  a_ax0
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
15[<C:0,F:0>] [W] cobox_ayr :: a_ax0
                               ~ FlatVector: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ax2 :: Int ~ Int [" a type equality Int
                                                             ~
                                                             Int " p4.hs:18:35-37] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ax2 :: Int ~ Int [" a type equality Int
                                                              ~
                                                              Int " p4.hs:18:35-37] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ax2 :: Int ~ Int [" a type equality Int
                                                ~
                                                Int " p4.hs:18:35-37] (CNonCanonical)
canEvNC:eq
  Int
  Int
can_eq_nc
  [W] cobox_ax2 :: Int ~ Int
  Int
  Int
  Int
  Int
setEvBind
  ev = cobox_ax2
  tm  = CO <Int>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ax3 :: [FlatVector]
                                ~ [a_ax0] [" a type equality [FlatVector]
                                                             ~
                                                             [a_ax0] " p4.hs:18:40-43] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ax3 :: [FlatVector]
                                 ~ [a_ax0] [" a type equality [FlatVector]
                                                              ~
                                                              [a_ax0] " p4.hs:18:40-43] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ax3 :: [FlatVector]
                   ~ [a_ax0] [" a type equality [FlatVector]
                                                ~
                                                [a_ax0] " p4.hs:18:40-43] (CNonCanonical)
canEvNC:eq
  [FlatVector]
  [a_ax0]
can_eq_nc
  [W] cobox_ax3 :: [FlatVector] ~ [a_ax0]
  [FlatVector]
  [FlatVector]
  [a_ax0]
  [a_ax0]
newWantedEvVar/cache miss [W] cobox_ays :: FlatVector ~ a_ax0
setEvBind
  ev = cobox_ax3
  tm  = CO [cobox_ays]_N
canEvNC:eq
  FlatVector
  a_ax0
can_eq_nc
  [W] cobox_ays :: FlatVector ~ a_ax0
  FlatVector
  FlatVector
  a_ax0
  a_ax0
can_eq_nc
  [W] cobox_ays :: FlatVector ~ a_ax0
  UArray Int Double
  FlatVector
  a_ax0
  a_ax0
canEqTyVar
  a_ax0
  UArray Int Double
  Is-swapped
Following bound tyvar a_ax0 = FlatVector
newWantedEvVar/cache miss [W] cobox_ayt :: FlatVector ~ FlatVector
setEvBind
  ev = cobox_ays
  tm  = CO Sym cobox_ayt
rewriteEqEvidence
  [W] cobox_ays :: FlatVector ~ a_ax0
  FlatVector
  FlatVector
  Sym cobox_ayt
canEqTyVar2
  a_ax0
  UArray Int Double
  Is-swapped
  FlatVector
  <FlatVector>_N
can_eq_nc
  [W] cobox_ayt :: FlatVector ~ FlatVector
  FlatVector
  FlatVector
  UArray Int Double
  FlatVector
can_eq_nc
  [W] cobox_ayt :: FlatVector ~ FlatVector
  UArray Int Double
  FlatVector
  UArray Int Double
  FlatVector
newWantedEvVar/cache miss [W] cobox_ayu :: Int ~ Int
newWantedEvVar/cache miss [W] cobox_ayv :: Double ~ Double
setEvBind
  ev = cobox_ayt
  tm  = CO UArray cobox_ayu cobox_ayv_N
canEvNC:eq
  Int
  Int
can_eq_nc
  [W] cobox_ayu :: Int ~ Int
  Int
  Int
  Int
  Int
setEvBind
  ev = cobox_ayu
  tm  = CO <Int>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ayv :: Double
                                ~ Double [" a type equality [FlatVector]
                                                            ~
                                                            [a_ax0] " p4.hs:18:40-43] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ayv :: Double
                                 ~ Double [" a type equality [FlatVector]
                                                             ~
                                                             [a_ax0] " p4.hs:18:40-43] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ayv :: Double ~ Double [" a type equality [FlatVector]
                                                      ~
                                                      [a_ax0] " p4.hs:18:40-43] (CNonCanonical)
canEvNC:eq
  Double
  Double
can_eq_nc
  [W] cobox_ayv :: Double ~ Double
  Double
  Double
  Double
  Double
setEvBind
  ev = cobox_ayv
  tm  = CO <Double>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_axe :: (m_ax9 a_axb
                                 -> (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc)
                                ~ (t_ax4
                                   -> (t_ax5 -> t_ax6) -> IO ()) [" a type equality m_ax9 a_axb
                                                                                    -> (a_axb
                                                                                        -> m_ax9 b_axc)
                                                                                    -> m_ax9 b_axc
                                                                                    ~
                                                                                    t_ax4
                                                                                    -> (t_ax5
                                                                                        -> t_ax6)
                                                                                    -> IO
                                                                                         () " p4.hs:19:11-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_axe :: (m_ax9 a_axb
                                  -> (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc)
                                 ~ (t_ax4
                                    -> (t_ax5 -> t_ax6) -> IO ()) [" a type equality m_ax9 a_axb
                                                                                     -> (a_axb
                                                                                         -> m_ax9 b_axc)
                                                                                     -> m_ax9 b_axc
                                                                                     ~
                                                                                     t_ax4
                                                                                     -> (t_ax5
                                                                                         -> t_ax6)
                                                                                     -> IO
                                                                                          () " p4.hs:19:11-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_axe :: (m_ax9 a_axb
                    -> (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc)
                   ~ (t_ax4
                      -> (t_ax5 -> t_ax6) -> IO ()) [" a type equality m_ax9 a_axb
                                                                       -> (a_axb -> m_ax9 b_axc)
                                                                       -> m_ax9 b_axc
                                                                       ~
                                                                       t_ax4
                                                                       -> (t_ax5 -> t_ax6)
                                                                       -> IO
                                                                            () " p4.hs:19:11-23] (CNonCanonical)
canEvNC:eq
  m_ax9 a_axb -> (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc
  t_ax4 -> (t_ax5 -> t_ax6) -> IO ()
can_eq_nc
  [W] cobox_axe :: (m_ax9 a_axb
                    -> (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc)
                   ~ (t_ax4 -> (t_ax5 -> t_ax6) -> IO ())
  m_ax9 a_axb -> (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc
  m_ax9 a_axb -> (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc
  t_ax4 -> (t_ax5 -> t_ax6) -> IO ()
  t_ax4 -> (t_ax5 -> t_ax6) -> IO ()
newWantedEvVar/cache miss [W] cobox_ayw :: m_ax9 a_axb ~ t_ax4
newWantedEvVar/cache miss
  [W] cobox_ayx :: ((a_axb -> m_ax9 b_axc) -> m_ax9 b_axc)
                   ~ ((t_ax5 -> t_ax6) -> IO ())
setEvBind
  ev = cobox_axe
  tm  = CO cobox_ayw -> cobox_ayx
canEvNC:eq
  m_ax9 a_axb
  t_ax4
can_eq_nc
  [W] cobox_ayw :: m_ax9 a_axb ~ t_ax4
  m_ax9 a_axb
  m_ax9 a_axb
  t_ax4
  t_ax4
canEqTyVar
  t_ax4
  m_ax9 a_axb
  Is-swapped
flatten/appty
  m_ax9
  a_axb
  m_ax9
  <m_ax9>_N
  a_axb
  <a_axb>_N
newWantedEvVar/cache miss [W] cobox_ayy :: t_ax4 ~ m_ax9 a_axb
setEvBind
  ev = cobox_ayw
  tm  = CO Sym cobox_ayy
rewriteEqEvidence
  [W] cobox_ayw :: m_ax9 a_axb ~ t_ax4
  t_ax4
  m_ax9 a_axb
  Sym cobox_ayy
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayy :: t_ax4
                                 ~ m_ax9 a_axb [" a type equality m_ax9 a_axb
                                                                  -> (a_axb -> m_ax9 b_axc)
                                                                  -> m_ax9 b_axc
                                                                  ~
                                                                  t_ax4
                                                                  -> (t_ax5 -> t_ax6)
                                                                  -> IO
                                                                       () " p4.hs:19:11-23] (CTyEqCan)
Sneaky unification:
  Unifies: t_ax4 := m_ax9 a_axb
  Coercion: t_ax4 ~ m_ax9 a_axb
  Left Kind is: *
  Right Kind is: *
setWantedTyBind t_ax4 := m_ax9 a_axb
setEvBind
  ev = cobox_ayy
  tm  = CO <m_ax9 a_axb>_N
kickOutRewritable
  tv =  t_ax4
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
19[<C:0,F:0>] [W] cobox_ayy :: t_ax4
                               ~ m_ax9 a_axb: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ayx :: ((a_axb -> m_ax9 b_axc)
                                 -> m_ax9 b_axc)
                                ~ ((t_ax5 -> t_ax6) -> IO ()) [" a type equality m_ax9 a_axb
                                                                                 -> (a_axb
                                                                                     -> m_ax9 b_axc)
                                                                                 -> m_ax9 b_axc
                                                                                 ~
                                                                                 t_ax4
                                                                                 -> (t_ax5 -> t_ax6)
                                                                                 -> IO
                                                                                      () " p4.hs:19:11-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ayx :: ((a_axb -> m_ax9 b_axc)
                                  -> m_ax9 b_axc)
                                 ~ ((t_ax5 -> t_ax6) -> IO ()) [" a type equality m_ax9 a_axb
                                                                                  -> (a_axb
                                                                                      -> m_ax9 b_axc)
                                                                                  -> m_ax9 b_axc
                                                                                  ~
                                                                                  t_ax4
                                                                                  -> (t_ax5
                                                                                      -> t_ax6)
                                                                                  -> IO
                                                                                       () " p4.hs:19:11-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ayx :: ((a_axb -> m_ax9 b_axc) -> m_ax9 b_axc)
                   ~ ((t_ax5 -> t_ax6) -> IO ()) [" a type equality m_ax9 a_axb
                                                                    -> (a_axb -> m_ax9 b_axc)
                                                                    -> m_ax9 b_axc
                                                                    ~
                                                                    t_ax4
                                                                    -> (t_ax5 -> t_ax6)
                                                                    -> IO
                                                                         () " p4.hs:19:11-23] (CNonCanonical)
canEvNC:eq
  (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc
  (t_ax5 -> t_ax6) -> IO ()
can_eq_nc
  [W] cobox_ayx :: ((a_axb -> m_ax9 b_axc) -> m_ax9 b_axc)
                   ~ ((t_ax5 -> t_ax6) -> IO ())
  (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc
  (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc
  (t_ax5 -> t_ax6) -> IO ()
  (t_ax5 -> t_ax6) -> IO ()
newWantedEvVar/cache miss
  [W] cobox_ayz :: (a_axb -> m_ax9 b_axc) ~ (t_ax5 -> t_ax6)
newWantedEvVar/cache miss [W] cobox_ayA :: m_ax9 b_axc ~ IO ()
setEvBind
  ev = cobox_ayx
  tm  = CO cobox_ayz -> cobox_ayA
canEvNC:eq
  a_axb -> m_ax9 b_axc
  t_ax5 -> t_ax6
can_eq_nc
  [W] cobox_ayz :: (a_axb -> m_ax9 b_axc) ~ (t_ax5 -> t_ax6)
  a_axb -> m_ax9 b_axc
  a_axb -> m_ax9 b_axc
  t_ax5 -> t_ax6
  t_ax5 -> t_ax6
newWantedEvVar/cache miss [W] cobox_ayB :: a_axb ~ t_ax5
newWantedEvVar/cache miss [W] cobox_ayC :: m_ax9 b_axc ~ t_ax6
setEvBind
  ev = cobox_ayz
  tm  = CO cobox_ayB -> cobox_ayC
canEvNC:eq
  a_axb
  t_ax5
can_eq_nc
  [W] cobox_ayB :: a_axb ~ t_ax5
  a_axb
  a_axb
  t_ax5
  t_ax5
canEqTyVar
  a_axb
  t_ax5
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayB :: a_axb
                                 ~ t_ax5 [" a type equality m_ax9 a_axb
                                                            -> (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc
                                                            ~
                                                            t_ax4
                                                            -> (t_ax5 -> t_ax6)
                                                            -> IO () " p4.hs:19:11-23] (CTyEqCan)
Sneaky unification:
  Unifies: t_ax5 := a_axb
  Coercion: t_ax5 ~ a_axb
  Left Kind is: *
  Right Kind is: *
setWantedTyBind t_ax5 := a_axb
setEvBind
  ev = cobox_ayB
  tm  = CO <a_axb>_N
kickOutRewritable
  tv =  t_ax5
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
20[<C:0,F:0>] [W] cobox_ayB :: a_axb ~ t_ax5: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ayC :: m_ax9 b_axc
                                ~ t_ax6 [" a type equality m_ax9 a_axb
                                                           -> (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc
                                                           ~
                                                           t_ax4
                                                           -> (t_ax5 -> t_ax6)
                                                           -> IO
                                                                () " p4.hs:19:11-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ayC :: m_ax9 b_axc
                                 ~ t_ax6 [" a type equality m_ax9 a_axb
                                                            -> (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc
                                                            ~
                                                            t_ax4
                                                            -> (t_ax5 -> t_ax6)
                                                            -> IO
                                                                 () " p4.hs:19:11-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ayC :: m_ax9 b_axc ~ t_ax6 [" a type equality m_ax9 a_axb
                                                          -> (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc
                                                          ~
                                                          t_ax4
                                                          -> (t_ax5 -> t_ax6)
                                                          -> IO () " p4.hs:19:11-23] (CNonCanonical)
canEvNC:eq
  m_ax9 b_axc
  t_ax6
can_eq_nc
  [W] cobox_ayC :: m_ax9 b_axc ~ t_ax6
  m_ax9 b_axc
  m_ax9 b_axc
  t_ax6
  t_ax6
canEqTyVar
  t_ax6
  m_ax9 b_axc
  Is-swapped
flatten/appty
  m_ax9
  b_axc
  m_ax9
  <m_ax9>_N
  b_axc
  <b_axc>_N
newWantedEvVar/cache miss [W] cobox_ayD :: t_ax6 ~ m_ax9 b_axc
setEvBind
  ev = cobox_ayC
  tm  = CO Sym cobox_ayD
rewriteEqEvidence
  [W] cobox_ayC :: m_ax9 b_axc ~ t_ax6
  t_ax6
  m_ax9 b_axc
  Sym cobox_ayD
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayD :: t_ax6
                                 ~ m_ax9 b_axc [" a type equality m_ax9 a_axb
                                                                  -> (a_axb -> m_ax9 b_axc)
                                                                  -> m_ax9 b_axc
                                                                  ~
                                                                  t_ax4
                                                                  -> (t_ax5 -> t_ax6)
                                                                  -> IO
                                                                       () " p4.hs:19:11-23] (CTyEqCan)
Sneaky unification:
  Unifies: t_ax6 := m_ax9 b_axc
  Coercion: t_ax6 ~ m_ax9 b_axc
  Left Kind is: *
  Right Kind is: *
setWantedTyBind t_ax6 := m_ax9 b_axc
setEvBind
  ev = cobox_ayD
  tm  = CO <m_ax9 b_axc>_N
kickOutRewritable
  tv =  t_ax6
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
21[<C:0,F:0>] [W] cobox_ayD :: t_ax6
                               ~ m_ax9 b_axc: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ayA :: m_ax9 b_axc
                                ~ IO () [" a type equality m_ax9 a_axb
                                                           -> (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc
                                                           ~
                                                           t_ax4
                                                           -> (t_ax5 -> t_ax6)
                                                           -> IO
                                                                () " p4.hs:19:11-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ayA :: m_ax9 b_axc
                                 ~ IO () [" a type equality m_ax9 a_axb
                                                            -> (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc
                                                            ~
                                                            t_ax4
                                                            -> (t_ax5 -> t_ax6)
                                                            -> IO
                                                                 () " p4.hs:19:11-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ayA :: m_ax9 b_axc ~ IO () [" a type equality m_ax9 a_axb
                                                          -> (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc
                                                          ~
                                                          t_ax4
                                                          -> (t_ax5 -> t_ax6)
                                                          -> IO () " p4.hs:19:11-23] (CNonCanonical)
canEvNC:eq
  m_ax9 b_axc
  IO ()
can_eq_nc
  [W] cobox_ayA :: m_ax9 b_axc ~ IO ()
  m_ax9 b_axc
  m_ax9 b_axc
  IO ()
  IO ()
can_eq_app 1
  [W] cobox_ayA :: m_ax9 b_axc ~ IO ()
  Not-swapped
  m_ax9
  b_axc
  IO ()
can_eq_app 2
  [W] cobox_ayA :: m_ax9 b_axc ~ IO ()
  m_ax9
newWantedEvVar/cache miss [W] cobox_ayE :: m_ax9 ~ IO
newWantedEvVar/cache miss [W] cobox_ayF :: b_axc ~ ()
setEvBind
  ev = cobox_ayA
  tm  = CO cobox_ayE cobox_ayF
canEvNC:eq
  m_ax9
  IO
can_eq_nc
  [W] cobox_ayE :: m_ax9 ~ IO
  m_ax9
  m_ax9
  IO
  IO
canEqTyVar
  m_ax9
  IO
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayE :: m_ax9
                                 ~ IO [" a type equality m_ax9 a_axb
                                                         -> (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc
                                                         ~
                                                         t_ax4
                                                         -> (t_ax5 -> t_ax6)
                                                         -> IO () " p4.hs:19:11-23] (CTyEqCan)
Sneaky unification:
  Unifies: m_ax9 := IO
  Coercion: m_ax9 ~ IO
  Left Kind is: * -> *
  Right Kind is: * -> *
setWantedTyBind m_ax9 := IO
setEvBind
  ev = cobox_ayE
  tm  = CO <IO>_N
kickOutRewritable
  tv =  m_ax9
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
22[<C:0,F:0>] [W] cobox_ayE :: m_ax9 ~ IO: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ayF :: b_axc
                                ~ () [" a type equality m_ax9 a_axb
                                                        -> (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc
                                                        ~
                                                        t_ax4
                                                        -> (t_ax5 -> t_ax6)
                                                        -> IO () " p4.hs:19:11-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ayF :: b_axc
                                 ~ () [" a type equality m_ax9 a_axb
                                                         -> (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc
                                                         ~
                                                         t_ax4
                                                         -> (t_ax5 -> t_ax6)
                                                         -> IO () " p4.hs:19:11-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ayF :: b_axc ~ () [" a type equality m_ax9 a_axb
                                                 -> (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc
                                                 ~
                                                 t_ax4
                                                 -> (t_ax5 -> t_ax6)
                                                 -> IO () " p4.hs:19:11-23] (CNonCanonical)
canEvNC:eq
  b_axc
  ()
can_eq_nc
  [W] cobox_ayF :: b_axc ~ ()
  b_axc
  b_axc
  ()
  ()
canEqTyVar
  b_axc
  ()
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayF :: b_axc
                                 ~ () [" a type equality m_ax9 a_axb
                                                         -> (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc
                                                         ~
                                                         t_ax4
                                                         -> (t_ax5 -> t_ax6)
                                                         -> IO () " p4.hs:19:11-23] (CTyEqCan)
Sneaky unification:
  Unifies: b_axc := ()
  Coercion: b_axc ~ ()
  Left Kind is: *
  Right Kind is: *
setWantedTyBind b_axc := ()
setEvBind
  ev = cobox_ayF
  tm  = CO <()>_N
kickOutRewritable
  tv =  b_axc
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
23[<C:0,F:0>] [W] cobox_ayF :: b_axc ~ (): Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_axG :: m_axB (b_axC i_axz e_axA)
                                ~ t_ax4 [" a type equality m_axB (b_axC i_axz e_axA)
                                                           ~
                                                           t_ax4 " p4.hs:19:16-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_axG :: m_axB (b_axC i_axz e_axA)
                                 ~ t_ax4 [" a type equality m_axB (b_axC i_axz e_axA)
                                                            ~
                                                            t_ax4 " p4.hs:19:16-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_axG :: m_axB (b_axC i_axz e_axA)
                   ~ t_ax4 [" a type equality m_axB (b_axC i_axz e_axA)
                                              ~
                                              t_ax4 " p4.hs:19:16-23] (CNonCanonical)
canEvNC:eq
  m_axB (b_axC i_axz e_axA)
  t_ax4
can_eq_nc
  [W] cobox_axG :: m_axB (b_axC i_axz e_axA) ~ t_ax4
  m_axB (b_axC i_axz e_axA)
  m_axB (b_axC i_axz e_axA)
  t_ax4
  t_ax4
canEqTyVar
  t_ax4
  m_axB (b_axC i_axz e_axA)
  Is-swapped
Following bound tyvar t_ax4 = m_ax9 a_axb
newWantedEvVar/cache miss
  [W] cobox_ayG :: m_ax9 a_axb ~ m_axB (b_axC i_axz e_axA)
setEvBind
  ev = cobox_axG
  tm  = CO Sym cobox_ayG
rewriteEqEvidence
  [W] cobox_axG :: m_axB (b_axC i_axz e_axA) ~ t_ax4
  m_ax9 a_axb
  m_axB (b_axC i_axz e_axA)
  Sym cobox_ayG
canEqTyVar2
  t_ax4
  m_axB (b_axC i_axz e_axA)
  Is-swapped
  m_ax9 a_axb
  <m_ax9 a_axb>_N
can_eq_nc
  [W] cobox_ayG :: m_ax9 a_axb ~ m_axB (b_axC i_axz e_axA)
  m_ax9 a_axb
  m_ax9 a_axb
  m_axB (b_axC i_axz e_axA)
  m_axB (b_axC i_axz e_axA)
can_eq_app 1
  [W] cobox_ayG :: m_ax9 a_axb ~ m_axB (b_axC i_axz e_axA)
  Not-swapped
  m_ax9
  a_axb
  m_axB (b_axC i_axz e_axA)
Following bound tyvar m_ax9 = IO
can_eq_app 2
  [W] cobox_ayG :: m_ax9 a_axb ~ m_axB (b_axC i_axz e_axA)
  IO
can_eq_app 3
  [W] cobox_ayG :: m_ax9 a_axb ~ m_axB (b_axC i_axz e_axA)
  IO a_axb
  <IO a_axb>_N
can_eq_app 4
  [W] cobox_ayG :: m_ax9 a_axb ~ m_axB (b_axC i_axz e_axA)
  IO a_axb
  <IO a_axb>_N
can_eq_nc
  [W] cobox_ayG :: IO a_axb ~ m_axB (b_axC i_axz e_axA)
  IO a_axb
  IO a_axb
  m_axB (b_axC i_axz e_axA)
  m_axB (b_axC i_axz e_axA)
can_eq_app 1
  [W] cobox_ayG :: IO a_axb ~ m_axB (b_axC i_axz e_axA)
  Is-swapped
  m_axB
  b_axC i_axz e_axA
  IO a_axb
can_eq_app 2
  [W] cobox_ayG :: IO a_axb ~ m_axB (b_axC i_axz e_axA)
  m_axB
newWantedEvVar/cache miss [W] cobox_ayH :: IO ~ m_axB
newWantedEvVar/cache miss
  [W] cobox_ayI :: a_axb ~ b_axC i_axz e_axA
setEvBind
  ev = cobox_ayG
  tm  = CO cobox_ayH cobox_ayI
canEvNC:eq
  IO
  m_axB
can_eq_nc
  [W] cobox_ayH :: IO ~ m_axB
  IO
  IO
  m_axB
  m_axB
canEqTyVar
  m_axB
  IO
  Is-swapped
newWantedEvVar/cache miss [W] cobox_ayJ :: m_axB ~ IO
setEvBind
  ev = cobox_ayH
  tm  = CO Sym cobox_ayJ
rewriteEqEvidence
  [W] cobox_ayH :: IO ~ m_axB
  m_axB
  IO
  Sym cobox_ayJ
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayJ :: m_axB
                                 ~ IO [" a type equality m_axB (b_axC i_axz e_axA)
                                                         ~
                                                         t_ax4 " p4.hs:19:16-23] (CTyEqCan)
Sneaky unification:
  Unifies: m_axB := IO
  Coercion: m_axB ~ IO
  Left Kind is: * -> *
  Right Kind is: * -> *
setWantedTyBind m_axB := IO
setEvBind
  ev = cobox_ayJ
  tm  = CO <IO>_N
kickOutRewritable
  tv =  m_axB
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
24[<C:0,F:0>] [W] cobox_ayJ :: m_axB ~ IO: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ayI :: a_axb
                                ~ b_axC i_axz e_axA [" a type equality m_axB (b_axC i_axz e_axA)
                                                                       ~
                                                                       t_ax4 " p4.hs:19:16-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ayI :: a_axb
                                 ~ b_axC i_axz e_axA [" a type equality m_axB (b_axC i_axz e_axA)
                                                                        ~
                                                                        t_ax4 " p4.hs:19:16-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ayI :: a_axb
                   ~ b_axC i_axz e_axA [" a type equality m_axB (b_axC i_axz e_axA)
                                                          ~
                                                          t_ax4 " p4.hs:19:16-23] (CNonCanonical)
canEvNC:eq
  a_axb
  b_axC i_axz e_axA
can_eq_nc
  [W] cobox_ayI :: a_axb ~ b_axC i_axz e_axA
  a_axb
  a_axb
  b_axC i_axz e_axA
  b_axC i_axz e_axA
canEqTyVar
  a_axb
  b_axC i_axz e_axA
  Not-swapped
flatten/appty
  b_axC
  i_axz
  b_axC
  <b_axC>_N
  i_axz
  <i_axz>_N
flatten/appty
  b_axC i_axz
  e_axA
  b_axC i_axz
  <b_axC i_axz>_N
  e_axA
  <e_axA>_N
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayI :: a_axb
                                 ~ b_axC i_axz e_axA [" a type equality m_axB (b_axC i_axz e_axA)
                                                                        ~
                                                                        t_ax4 " p4.hs:19:16-23] (CTyEqCan)
Sneaky unification:
  Unifies: a_axb := b_axC i_axz e_axA
  Coercion: a_axb ~ b_axC i_axz e_axA
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_axb := b_axC i_axz e_axA
setEvBind
  ev = cobox_ayI
  tm  = CO <b_axC i_axz e_axA>_N
kickOutRewritable
  tv =  a_axb
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
25[<C:0,F:0>] [W] cobox_ayI :: a_axb
                               ~ b_axC i_axz e_axA: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_axH :: Vector FlatVector
                                ~ a_axy i_axz e_axA [" a type equality Vector FlatVector
                                                                       ~
                                                                       a_axy i_axz e_axA " p4.hs:19:21-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_axH :: Vector FlatVector
                                 ~ a_axy i_axz e_axA [" a type equality Vector FlatVector
                                                                        ~
                                                                        a_axy i_axz e_axA " p4.hs:19:21-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_axH :: Vector FlatVector
                   ~ a_axy i_axz e_axA [" a type equality Vector FlatVector
                                                          ~
                                                          a_axy i_axz e_axA " p4.hs:19:21-23] (CNonCanonical)
canEvNC:eq
  Vector FlatVector
  a_axy i_axz e_axA
can_eq_nc
  [W] cobox_axH :: Vector FlatVector ~ a_axy i_axz e_axA
  Vector FlatVector
  Vector FlatVector
  a_axy i_axz e_axA
  a_axy i_axz e_axA
can_eq_nc
  [W] cobox_axH :: Vector FlatVector ~ a_axy i_axz e_axA
  Array Int FlatVector
  Vector FlatVector
  a_axy i_axz e_axA
  a_axy i_axz e_axA
can_eq_app 1
  [W] cobox_axH :: Vector FlatVector ~ a_axy i_axz e_axA
  Is-swapped
  a_axy i_axz
  e_axA
  Array Int FlatVector
flatten/appty
  a_axy
  i_axz
  a_axy
  <a_axy>_N
  i_axz
  <i_axz>_N
can_eq_app 2
  [W] cobox_axH :: Vector FlatVector ~ a_axy i_axz e_axA
  a_axy i_axz
newWantedEvVar/cache miss [W] cobox_ayK :: Array Int ~ a_axy i_axz
newWantedEvVar/cache miss [W] cobox_ayL :: FlatVector ~ e_axA
setEvBind
  ev = cobox_axH
  tm  = CO cobox_ayK cobox_ayL
canEvNC:eq
  Array Int
  a_axy i_axz
can_eq_nc
  [W] cobox_ayK :: Array Int ~ a_axy i_axz
  Array Int
  Array Int
  a_axy i_axz
  a_axy i_axz
can_eq_app 1
  [W] cobox_ayK :: Array Int ~ a_axy i_axz
  Is-swapped
  a_axy
  i_axz
  Array Int
can_eq_app 2
  [W] cobox_ayK :: Array Int ~ a_axy i_axz
  a_axy
newWantedEvVar/cache miss [W] cobox_ayM :: Array ~ a_axy
newWantedEvVar/cache miss [W] cobox_ayN :: Int ~ i_axz
setEvBind
  ev = cobox_ayK
  tm  = CO cobox_ayM cobox_ayN
canEvNC:eq
  Array
  a_axy
can_eq_nc
  [W] cobox_ayM :: Array ~ a_axy
  Array
  Array
  a_axy
  a_axy
canEqTyVar
  a_axy
  Array
  Is-swapped
newWantedEvVar/cache miss [W] cobox_ayO :: a_axy ~ Array
setEvBind
  ev = cobox_ayM
  tm  = CO Sym cobox_ayO
rewriteEqEvidence
  [W] cobox_ayM :: Array ~ a_axy
  a_axy
  Array
  Sym cobox_ayO
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayO :: a_axy
                                 ~ Array [" a type equality Vector FlatVector
                                                            ~
                                                            a_axy i_axz e_axA " p4.hs:19:21-23] (CTyEqCan)
Sneaky unification:
  Unifies: a_axy := Array
  Coercion: a_axy ~ Array
  Left Kind is: * -> * -> *
  Right Kind is: * -> * -> *
setWantedTyBind a_axy := Array
setEvBind
  ev = cobox_ayO
  tm  = CO <Array>_N
kickOutRewritable
  tv =  a_axy
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
26[<C:0,F:0>] [W] cobox_ayO :: a_axy ~ Array: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ayN :: Int ~ i_axz [" a type equality Vector
                                                                 FlatVector
                                                               ~
                                                               a_axy i_axz e_axA " p4.hs:19:21-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ayN :: Int
                                 ~ i_axz [" a type equality Vector FlatVector
                                                            ~
                                                            a_axy i_axz e_axA " p4.hs:19:21-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ayN :: Int ~ i_axz [" a type equality Vector FlatVector
                                                  ~
                                                  a_axy i_axz e_axA " p4.hs:19:21-23] (CNonCanonical)
canEvNC:eq
  Int
  i_axz
can_eq_nc
  [W] cobox_ayN :: Int ~ i_axz
  Int
  Int
  i_axz
  i_axz
canEqTyVar
  i_axz
  Int
  Is-swapped
newWantedEvVar/cache miss [W] cobox_ayP :: i_axz ~ Int
setEvBind
  ev = cobox_ayN
  tm  = CO Sym cobox_ayP
rewriteEqEvidence
  [W] cobox_ayN :: Int ~ i_axz
  i_axz
  Int
  Sym cobox_ayP
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayP :: i_axz
                                 ~ Int [" a type equality Vector FlatVector
                                                          ~
                                                          a_axy i_axz e_axA " p4.hs:19:21-23] (CTyEqCan)
Sneaky unification:
  Unifies: i_axz := Int
  Coercion: i_axz ~ Int
  Left Kind is: *
  Right Kind is: *
setWantedTyBind i_axz := Int
setEvBind
  ev = cobox_ayP
  tm  = CO <Int>_N
kickOutRewritable
  tv =  i_axz
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
27[<C:0,F:0>] [W] cobox_ayP :: i_axz ~ Int: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ayL :: FlatVector
                                ~ e_axA [" a type equality Vector FlatVector
                                                           ~
                                                           a_axy i_axz e_axA " p4.hs:19:21-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ayL :: FlatVector
                                 ~ e_axA [" a type equality Vector FlatVector
                                                            ~
                                                            a_axy i_axz e_axA " p4.hs:19:21-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ayL :: FlatVector ~ e_axA [" a type equality Vector
                                                           FlatVector
                                                         ~
                                                         a_axy i_axz e_axA " p4.hs:19:21-23] (CNonCanonical)
canEvNC:eq
  FlatVector
  e_axA
can_eq_nc
  [W] cobox_ayL :: FlatVector ~ e_axA
  FlatVector
  FlatVector
  e_axA
  e_axA
can_eq_nc
  [W] cobox_ayL :: FlatVector ~ e_axA
  UArray Int Double
  FlatVector
  e_axA
  e_axA
canEqTyVar
  e_axA
  UArray Int Double
  Is-swapped
newWantedEvVar/cache miss [W] cobox_ayQ :: e_axA ~ FlatVector
setEvBind
  ev = cobox_ayL
  tm  = CO Sym cobox_ayQ
rewriteEqEvidence
  [W] cobox_ayL :: FlatVector ~ e_axA
  e_axA
  FlatVector
  Sym cobox_ayQ
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayQ :: e_axA
                                 ~ FlatVector [" a type equality Vector FlatVector
                                                                 ~
                                                                 a_axy i_axz e_axA " p4.hs:19:21-23] (CTyEqCan)
Sneaky unification:
  Unifies: e_axA := FlatVector
  Coercion: e_axA ~ FlatVector
  Left Kind is: *
  Right Kind is: *
setWantedTyBind e_axA := FlatVector
setEvBind
  ev = cobox_ayQ
  tm  = CO <FlatVector>_N
kickOutRewritable
  tv =  e_axA
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
28[<C:0,F:0>] [W] cobox_ayQ :: e_axA
                               ~ FlatVector: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_axN :: m_axJ a_axL
                                ~ t_ax6 [" a type equality m_axJ a_axL
                                                           ~
                                                           t_ax6 " p4.hs:20:11-19] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_axN :: m_axJ a_axL
                                 ~ t_ax6 [" a type equality m_axJ a_axL
                                                            ~
                                                            t_ax6 " p4.hs:20:11-19] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_axN :: m_axJ a_axL ~ t_ax6 [" a type equality m_axJ a_axL
                                                          ~
                                                          t_ax6 " p4.hs:20:11-19] (CNonCanonical)
canEvNC:eq
  m_axJ a_axL
  t_ax6
can_eq_nc
  [W] cobox_axN :: m_axJ a_axL ~ t_ax6
  m_axJ a_axL
  m_axJ a_axL
  t_ax6
  t_ax6
canEqTyVar
  t_ax6
  m_axJ a_axL
  Is-swapped
Following bound tyvar t_ax6 = m_ax9 b_axc
newWantedEvVar/cache miss
  [W] cobox_ayR :: m_ax9 b_axc ~ m_axJ a_axL
setEvBind
  ev = cobox_axN
  tm  = CO Sym cobox_ayR
rewriteEqEvidence
  [W] cobox_axN :: m_axJ a_axL ~ t_ax6
  m_ax9 b_axc
  m_axJ a_axL
  Sym cobox_ayR
canEqTyVar2
  t_ax6
  m_axJ a_axL
  Is-swapped
  m_ax9 b_axc
  <m_ax9 b_axc>_N
can_eq_nc
  [W] cobox_ayR :: m_ax9 b_axc ~ m_axJ a_axL
  m_ax9 b_axc
  m_ax9 b_axc
  m_axJ a_axL
  m_axJ a_axL
can_eq_app 1
  [W] cobox_ayR :: m_ax9 b_axc ~ m_axJ a_axL
  Not-swapped
  m_ax9
  b_axc
  m_axJ a_axL
Following bound tyvar m_ax9 = IO
can_eq_app 2
  [W] cobox_ayR :: m_ax9 b_axc ~ m_axJ a_axL
  IO
Following bound tyvar b_axc = ()
can_eq_app 3
  [W] cobox_ayR :: m_ax9 b_axc ~ m_axJ a_axL
  IO ()
  <IO ()>_N
can_eq_app 4
  [W] cobox_ayR :: m_ax9 b_axc ~ m_axJ a_axL
  IO ()
  <IO ()>_N
can_eq_nc
  [W] cobox_ayR :: IO () ~ m_axJ a_axL
  IO ()
  IO ()
  m_axJ a_axL
  m_axJ a_axL
can_eq_app 1
  [W] cobox_ayR :: IO () ~ m_axJ a_axL
  Is-swapped
  m_axJ
  a_axL
  IO ()
can_eq_app 2
  [W] cobox_ayR :: IO () ~ m_axJ a_axL
  m_axJ
newWantedEvVar/cache miss [W] cobox_ayS :: IO ~ m_axJ
newWantedEvVar/cache miss [W] cobox_ayT :: () ~ a_axL
setEvBind
  ev = cobox_ayR
  tm  = CO cobox_ayS cobox_ayT
canEvNC:eq
  IO
  m_axJ
can_eq_nc
  [W] cobox_ayS :: IO ~ m_axJ
  IO
  IO
  m_axJ
  m_axJ
canEqTyVar
  m_axJ
  IO
  Is-swapped
newWantedEvVar/cache miss [W] cobox_ayU :: m_axJ ~ IO
setEvBind
  ev = cobox_ayS
  tm  = CO Sym cobox_ayU
rewriteEqEvidence
  [W] cobox_ayS :: IO ~ m_axJ
  m_axJ
  IO
  Sym cobox_ayU
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayU :: m_axJ
                                 ~ IO [" a type equality m_axJ a_axL
                                                         ~
                                                         t_ax6 " p4.hs:20:11-19] (CTyEqCan)
Sneaky unification:
  Unifies: m_axJ := IO
  Coercion: m_axJ ~ IO
  Left Kind is: * -> *
  Right Kind is: * -> *
setWantedTyBind m_axJ := IO
setEvBind
  ev = cobox_ayU
  tm  = CO <IO>_N
kickOutRewritable
  tv =  m_axJ
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
29[<C:0,F:0>] [W] cobox_ayU :: m_axJ ~ IO: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_ayT :: ()
                                ~ a_axL [" a type equality m_axJ a_axL
                                                           ~
                                                           t_ax6 " p4.hs:20:11-19] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ayT :: ()
                                 ~ a_axL [" a type equality m_axJ a_axL
                                                            ~
                                                            t_ax6 " p4.hs:20:11-19] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ayT :: () ~ a_axL [" a type equality m_axJ a_axL
                                                 ~
                                                 t_ax6 " p4.hs:20:11-19] (CNonCanonical)
canEvNC:eq
  ()
  a_axL
can_eq_nc
  [W] cobox_ayT :: () ~ a_axL
  ()
  ()
  a_axL
  a_axL
canEqTyVar
  a_axL
  ()
  Is-swapped
newWantedEvVar/cache miss [W] cobox_ayV :: a_axL ~ ()
setEvBind
  ev = cobox_ayT
  tm  = CO Sym cobox_ayV
rewriteEqEvidence
  [W] cobox_ayT :: () ~ a_axL
  a_axL
  ()
  Sym cobox_ayV
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayV :: a_axL
                                 ~ () [" a type equality m_axJ a_axL
                                                         ~
                                                         t_ax6 " p4.hs:20:11-19] (CTyEqCan)
Sneaky unification:
  Unifies: a_axL := ()
  Coercion: a_axL ~ ()
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_axL := ()
setEvBind
  ev = cobox_ayV
  tm  = CO <()>_N
kickOutRewritable
  tv =  a_axL
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
30[<C:0,F:0>] [W] cobox_ayV :: a_axL ~ (): Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_axO :: () ~ a_axL [" a type equality ()
                                                              ~
                                                              a_axL " p4.hs:20:18-19] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_axO :: () ~ a_axL [" a type equality ()
                                                               ~
                                                               a_axL " p4.hs:20:18-19] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_axO :: () ~ a_axL [" a type equality ()
                                                 ~
                                                 a_axL " p4.hs:20:18-19] (CNonCanonical)
canEvNC:eq
  ()
  a_axL
can_eq_nc
  [W] cobox_axO :: () ~ a_axL
  ()
  ()
  a_axL
  a_axL
canEqTyVar
  a_axL
  ()
  Is-swapped
Following bound tyvar a_axL = ()
newWantedEvVar/cache miss [W] cobox_ayW :: () ~ ()
setEvBind
  ev = cobox_axO
  tm  = CO Sym cobox_ayW
rewriteEqEvidence
  [W] cobox_axO :: () ~ a_axL
  ()
  ()
  Sym cobox_ayW
canEqTyVar2
  a_axL
  ()
  Is-swapped
  ()
  <()>_N
can_eq_nc
  [W] cobox_ayW :: () ~ ()
  ()
  ()
  ()
  ()
setEvBind
  ev = cobox_ayW
  tm  = CO <()>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_axQ :: IO ()
                                ~ IO t_axP [" a type equality IO ()
                                                              ~
                                                              IO t_axP " p4.hs:13:1] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_axQ :: IO ()
                                 ~ IO t_axP [" a type equality IO ()
                                                               ~
                                                               IO
                                                                 t_axP " p4.hs:13:1] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_axQ :: IO () ~ IO t_axP [" a type equality IO ()
                                                       ~
                                                       IO t_axP " p4.hs:13:1] (CNonCanonical)
canEvNC:eq
  IO ()
  IO t_axP
can_eq_nc
  [W] cobox_axQ :: IO () ~ IO t_axP
  IO ()
  IO ()
  IO t_axP
  IO t_axP
newWantedEvVar/cache miss [W] cobox_ayX :: () ~ t_axP
setEvBind
  ev = cobox_axQ
  tm  = CO IO cobox_ayX_N
canEvNC:eq
  ()
  t_axP
can_eq_nc
  [W] cobox_ayX :: () ~ t_axP
  ()
  ()
  t_axP
  t_axP
canEqTyVar
  t_axP
  ()
  Is-swapped
newWantedEvVar/cache miss [W] cobox_ayY :: t_axP ~ ()
setEvBind
  ev = cobox_ayX
  tm  = CO Sym cobox_ayY
rewriteEqEvidence
  [W] cobox_ayX :: () ~ t_axP
  t_axP
  ()
  Sym cobox_ayY
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_ayY :: t_axP ~ () [" a type equality IO ()
                                                               ~
                                                               IO t_axP " p4.hs:13:1] (CTyEqCan)
Sneaky unification:
  Unifies: t_axP := ()
  Coercion: t_axP ~ ()
  Left Kind is: *
  Right Kind is: *
setWantedTyBind t_axP := ()
setEvBind
  ev = cobox_ayY
  tm  = CO <()>_N
kickOutRewritable
  tv =  t_axP
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
32[<C:0,F:0>] [W] cobox_ayY :: t_axP ~ (): Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dIArray_ar9 :: Data.Array.Base.IArray
                                     a_ar8
                                     e_ar7 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dIArray_ar9 :: Data.Array.Base.IArray
                                      a_ar8
                                      e_ar7 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dIArray_ar9 :: Data.Array.Base.IArray
                        a_ar8
                        e_ar7 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
canEvNC:cls Data.Array.Base.IArray [a_ar8, e_ar7]
Following bound tyvar a_ar8 = UArray
Following bound tyvar e_ar7 = Double
canClass
  [W] $dIArray_ar9 :: Data.Array.Base.IArray
                        a_ar8 e_ar7 Data.Array.Base.IArray [a_ar8, e_ar7]
  Data.Array.Base.IArray UArray Double
  Just [W] $dIArray_ar9 :: Data.Array.Base.IArray UArray Double
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dIArray_ar9 :: Data.Array.Base.IArray
                                      UArray
                                      Double [" a use of ‘listArray’ " p4.hs:25:18-29] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dIArray_ar9 :: Data.Array.Base.IArray
                                      UArray
                                      Double [" a use of ‘listArray’ " p4.hs:25:18-29] (CDictCan)
doTopReact
  [W] $dIArray_ar9 :: Data.Array.Base.IArray
                        UArray Double [" a use of ‘listArray’ " p4.hs:25:18-29] (CDictCan)
matchClassInst
  pred = Data.Array.Base.IArray UArray Double
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 0
          Solved funeqs 0
  untouchables= 0
matchClass success
  dict Data.Array.Base.IArray UArray Double
  witness Data.Array.Base.$fIArrayUArrayDouble Data.Array.Base.IArray
                                                 UArray Double
updSolvedSetTcs:
  [W] $dIArray_ar9 :: Data.Array.Base.IArray UArray Double
doTopReact/found nullary instance for $dIArray_ar9
setEvBind
  ev = $dIArray_ar9
  tm  = Data.Array.Base.$fIArrayUArrayDouble @[] []
33[<C:0,F:0>] [W] $dIArray_ar9 :: Data.Array.Base.IArray
                                    UArray Double: Top react: Dict/Top (solved, no new work)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 1
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dIx_ara :: GHC.Arr.Ix
                                 i_ar6 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 1
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dIx_ara :: GHC.Arr.Ix
                                  i_ar6 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dIx_ara :: GHC.Arr.Ix
                    i_ar6 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
canEvNC:cls GHC.Arr.Ix [i_ar6]
Following bound tyvar i_ar6 = Int
canClass
  [W] $dIx_ara :: GHC.Arr.Ix i_ar6 GHC.Arr.Ix [i_ar6]
  GHC.Arr.Ix Int
  Just [W] $dIx_ara :: GHC.Arr.Ix Int
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dIx_ara :: GHC.Arr.Ix
                                  Int [" a use of ‘listArray’ " p4.hs:25:18-29] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dIx_ara :: GHC.Arr.Ix
                                  Int [" a use of ‘listArray’ " p4.hs:25:18-29] (CDictCan)
doTopReact
  [W] $dIx_ara :: GHC.Arr.Ix
                    Int [" a use of ‘listArray’ " p4.hs:25:18-29] (CDictCan)
matchClassInst
  pred = GHC.Arr.Ix Int
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 1
          Solved funeqs 0
  untouchables= 0
matchClass success
  dict GHC.Arr.Ix Int
  witness GHC.Arr.$fIxInt GHC.Arr.Ix Int
updSolvedSetTcs: [W] $dIx_ara :: GHC.Arr.Ix Int
doTopReact/found nullary instance for $dIx_ara
setEvBind
  ev = $dIx_ara
  tm  = GHC.Arr.$fIxInt @[] []
34[<C:0,F:0>] [W] $dIx_ara :: GHC.Arr.Ix
                                Int: Top react: Dict/Top (solved, no new work)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 2
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dNum_atO :: Num
                                  a_au2 [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 2
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_atO :: Num
                                   a_au2 [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_atO :: Num
                     a_au2 [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
canEvNC:cls Num [a_au2]
Following bound tyvar a_au2 = Int
canClass
  [W] $dNum_atO :: Num a_au2 Num [a_au2]
  Num Int
  Just [W] $dNum_atO :: Num Int
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_atO :: Num
                                   Int [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dNum_atO :: Num
                                   Int [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
doTopReact
  [W] $dNum_atO :: Num
                     Int [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
matchClassInst
  pred = Num Int
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 2
          Solved funeqs 0
  untouchables= 0
matchClass success
  dict Num Int
  witness GHC.Num.$fNumInt Num Int
updSolvedSetTcs: [W] $dNum_atO :: Num Int
doTopReact/found nullary instance for $dNum_atO
setEvBind
  ev = $dNum_atO
  tm  = GHC.Num.$fNumInt @[] []
35[<C:0,F:0>] [W] $dNum_atO :: Num
                                 Int: Top react: Dict/Top (solved, no new work)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 3
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dNum_auZ :: Num
                                  a_auY [" the literal ‘1’ " p4.hs:16:51] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 3
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_auZ :: Num
                                   a_auY [" the literal ‘1’ " p4.hs:16:51] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_auZ :: Num
                     a_auY [" the literal ‘1’ " p4.hs:16:51] (CNonCanonical)
canEvNC:cls Num [a_auY]
Following bound tyvar a_auY = Int
canClass
  [W] $dNum_auZ :: Num a_auY Num [a_auY]
  Num Int
  Just [W] $dNum_auZ :: Num Int
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_auZ :: Num
                                   Int [" the literal ‘1’ " p4.hs:16:51] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dNum_auZ :: Num
                                   Int [" the literal ‘1’ " p4.hs:16:51] (CDictCan)
doTopReact
  [W] $dNum_auZ :: Num
                     Int [" the literal ‘1’ " p4.hs:16:51] (CDictCan)
setEvBind
  ev = $dNum_auZ
  tm  = $dNum_atO
36[<C:0,F:0>] [W] $dNum_auZ :: Num
                                 Int: Top react: Dict/Top (cached)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 3
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dEnum_awY :: Enum
                                   t_auX [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 3
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dEnum_awY :: Enum
                                    t_auX [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dEnum_awY :: Enum
                      t_auX [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CNonCanonical)
canEvNC:cls Enum [t_auX]
Following bound tyvar t_auX = a_auY
Following bound tyvar a_auY = Int
canClass
  [W] $dEnum_awY :: Enum t_auX Enum [t_auX]
  Enum Int
  Just [W] $dEnum_awY :: Enum Int
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dEnum_awY :: Enum
                                    Int [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dEnum_awY :: Enum
                                    Int [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CDictCan)
doTopReact
  [W] $dEnum_awY :: Enum
                      Int [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CDictCan)
matchClassInst
  pred = Enum Int
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 3
          Solved funeqs 0
  untouchables= 0
matchClass success
  dict Enum Int
  witness GHC.Enum.$fEnumInt Enum Int
updSolvedSetTcs: [W] $dEnum_awY :: Enum Int
doTopReact/found nullary instance for $dEnum_awY
setEvBind
  ev = $dEnum_awY
  tm  = GHC.Enum.$fEnumInt @[] []
37[<C:0,F:0>] [W] $dEnum_awY :: Enum
                                  Int: Top react: Dict/Top (solved, no new work)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 4
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dMonad_axa :: Monad
                                    m_ax9 [" a do statement " p4.hs:19:11-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 4
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dMonad_axa :: Monad
                                     m_ax9 [" a do statement " p4.hs:19:11-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dMonad_axa :: Monad
                       m_ax9 [" a do statement " p4.hs:19:11-23] (CNonCanonical)
canEvNC:cls Monad [m_ax9]
Following bound tyvar m_ax9 = IO
canClass
  [W] $dMonad_axa :: Monad m_ax9 Monad [m_ax9]
  Monad IO
  Just [W] $dMonad_axa :: Monad IO
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dMonad_axa :: Monad
                                     IO [" a do statement " p4.hs:19:11-23] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dMonad_axa :: Monad
                                     IO [" a do statement " p4.hs:19:11-23] (CDictCan)
doTopReact
  [W] $dMonad_axa :: Monad
                       IO [" a do statement " p4.hs:19:11-23] (CDictCan)
matchClassInst
  pred = Monad IO
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 4
          Solved funeqs 0
  untouchables= 0
matchClass success
  dict Monad IO
  witness GHC.Base.$fMonadIO Monad IO
updSolvedSetTcs: [W] $dMonad_axa :: Monad IO
doTopReact/found nullary instance for $dMonad_axa
setEvBind
  ev = $dMonad_axa
  tm  = GHC.Base.$fMonadIO @[] []
38[<C:0,F:0>] [W] $dMonad_axa :: Monad
                                   IO: Top react: Dict/Top (solved, no new work)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 5
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dIx_axD :: GHC.Arr.Ix
                                 i_axz [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 5
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dIx_axD :: GHC.Arr.Ix
                                  i_axz [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dIx_axD :: GHC.Arr.Ix
                    i_axz [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
canEvNC:cls GHC.Arr.Ix [i_axz]
Following bound tyvar i_axz = Int
canClass
  [W] $dIx_axD :: GHC.Arr.Ix i_axz GHC.Arr.Ix [i_axz]
  GHC.Arr.Ix Int
  Just [W] $dIx_axD :: GHC.Arr.Ix Int
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dIx_axD :: GHC.Arr.Ix
                                  Int [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dIx_axD :: GHC.Arr.Ix
                                  Int [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
doTopReact
  [W] $dIx_axD :: GHC.Arr.Ix
                    Int [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
setEvBind
  ev = $dIx_axD
  tm  = $dIx_ara
39[<C:0,F:0>] [W] $dIx_axD :: GHC.Arr.Ix
                                Int: Top react: Dict/Top (cached)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 5
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dIArray_axE :: Data.Array.Base.IArray
                                     a_axy
                                     e_axA [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 5
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dIArray_axE :: Data.Array.Base.IArray
                                      a_axy
                                      e_axA [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dIArray_axE :: Data.Array.Base.IArray
                        a_axy e_axA [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
canEvNC:cls Data.Array.Base.IArray [a_axy, e_axA]
Following bound tyvar a_axy = Array
Following bound tyvar e_axA = FlatVector
canClass
  [W] $dIArray_axE :: Data.Array.Base.IArray
                        a_axy e_axA Data.Array.Base.IArray [a_axy, e_axA]
  Data.Array.Base.IArray Array FlatVector
  Just [W] $dIArray_axE :: Data.Array.Base.IArray Array FlatVector
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dIArray_axE :: Data.Array.Base.IArray
                                      Array
                                      FlatVector [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dIArray_axE :: Data.Array.Base.IArray
                                      Array
                                      FlatVector [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
doTopReact
  [W] $dIArray_axE :: Data.Array.Base.IArray
                        Array FlatVector [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
matchClassInst
  pred = Data.Array.Base.IArray Array FlatVector
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 5
          Solved funeqs 0
  untouchables= 0
matchClass success
  dict Data.Array.Base.IArray Array FlatVector
  witness Data.Array.Base.$fIArrayArraye forall e.
                                         Data.Array.Base.IArray Array e
updSolvedSetTcs:
  [W] $dIArray_axE :: Data.Array.Base.IArray Array FlatVector
doTopReact/found nullary instance for $dIArray_axE
setEvBind
  ev = $dIArray_axE
  tm  = Data.Array.Base.$fIArrayArraye @[UArray Int Double] []
40[<C:0,F:0>] [W] $dIArray_axE :: Data.Array.Base.IArray
                                    Array FlatVector: Top react: Dict/Top (solved, no new work)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dMArray_axF :: Data.Array.Base.MArray
                                     b_axC
                                     e_axA
                                     m_axB [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dMArray_axF :: Data.Array.Base.MArray
                                      b_axC
                                      e_axA
                                      m_axB [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dMArray_axF :: Data.Array.Base.MArray
                        b_axC
                        e_axA
                        m_axB [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
canEvNC:cls Data.Array.Base.MArray [b_axC, e_axA, m_axB]
Following bound tyvar e_axA = FlatVector
Following bound tyvar m_axB = IO
canClass
  [W] $dMArray_axF :: Data.Array.Base.MArray
                        b_axC e_axA m_axB Data.Array.Base.MArray [b_axC, e_axA, m_axB]
  Data.Array.Base.MArray b_axC FlatVector IO
  Just [W] $dMArray_axF :: Data.Array.Base.MArray b_axC FlatVector IO
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dMArray_axF :: Data.Array.Base.MArray
                                      b_axC
                                      FlatVector
                                      IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dMArray_axF :: Data.Array.Base.MArray
                                      b_axC
                                      FlatVector
                                      IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
doTopReact
  [W] $dMArray_axF :: Data.Array.Base.MArray
                        b_axC FlatVector IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
matchClassInst
  pred = Data.Array.Base.MArray b_axC FlatVector IO
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 6
          Solved funeqs 0
  untouchables= 0
matchClass not matching
  dict Data.Array.Base.MArray b_axC FlatVector IO
end stage top-level reactions }
41[<C:0,F:0>] [W] $dMArray_axF :: Data.Array.Base.MArray
                                    b_axC FlatVector IO: Kept as inert
End solver pipeline (not discharged) }
  final_item =  [W] $dMArray_axF :: Data.Array.Base.MArray
                                      b_axC
                                      FlatVector
                                      IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
  (b_axC :: * -> * -> *)
  inerts     =  Equalities:
                Type-function equalities:
                No-eqs: True
                Dictionaries:
                Irreds:
                Insolubles = {}
                Solved dicts 6
                Solved funeqs 0
insertInertItemTcS {
  Trying to insert new inert item: [W] $dMArray_axF :: Data.Array.Base.MArray
                                                         b_axC
                                                         FlatVector
                                                         IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
insertInertItemTcS }
Start solver pipeline {
  work item =  [W] $dMonad_axK :: Monad
                                    m_axJ [" a use of ‘return’ " p4.hs:20:11-16] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dMArray_axF :: Data.Array.Base.MArray
                                                   b_axC
                                                   FlatVector
                                                   IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dMonad_axK :: Monad
                                     m_axJ [" a use of ‘return’ " p4.hs:20:11-16] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dMonad_axK :: Monad
                       m_axJ [" a use of ‘return’ " p4.hs:20:11-16] (CNonCanonical)
canEvNC:cls Monad [m_axJ]
Following bound tyvar m_axJ = IO
canClass
  [W] $dMonad_axK :: Monad m_axJ Monad [m_axJ]
  Monad IO
  Just [W] $dMonad_axK :: Monad IO
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dMonad_axK :: Monad
                                     IO [" a use of ‘return’ " p4.hs:20:11-16] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dMonad_axK :: Monad
                                     IO [" a use of ‘return’ " p4.hs:20:11-16] (CDictCan)
doTopReact
  [W] $dMonad_axK :: Monad
                       IO [" a use of ‘return’ " p4.hs:20:11-16] (CDictCan)
setEvBind
  ev = $dMonad_axK
  tm  = $dMonad_axa
42[<C:0,F:0>] [W] $dMonad_axK :: Monad
                                   IO: Top react: Dict/Top (cached)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dMArray_axF :: Data.Array.Base.MArray
                                                   b_axC
                                                   FlatVector
                                                   IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
solveFlats end } {}
simpl_loop, iteration 1
solveNestedImplications starting {
  original inerts =  Equalities:
                     Type-function equalities:
                     No-eqs: True
                     Dictionaries: [W] $dMArray_axF :: Data.Array.Base.MArray
                                                         b_axC
                                                         FlatVector
                                                         IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
                     Irreds:
                     Insolubles = {}
                     Solved dicts 6
                     Solved funeqs 0
  thinner_inerts  =  Equalities:
                     Type-function equalities:
                     No-eqs: True
                     Dictionaries:
                     Irreds:
                     Insolubles = {}
                     Solved dicts 6
                     Solved funeqs 0
solveImplication {
  Implic {Untouchables = 1
          Skolems = a
          Flatten-skolems =
          No-eqs = False
          Given =
          Wanted = WC {wc_flat = [W] $dIArray_ar1 :: Data.Array.Base.IArray
                                                       a_ar0
                                                       e_aqZ [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                 [W] $dIx_ar2 :: GHC.Arr.Ix
                                                   i_aqY [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                 [W] cobox_ar3 :: ((i_aqY, i_aqY) -> [e_aqZ] -> a_ar0 i_aqY e_aqZ)
                                                  ~ ((Int, Int)
                                                     -> [a] -> Vector a) [" a type equality (i_aqY,
                                                                                             i_aqY)
                                                                                            -> [e_aqZ]
                                                                                            -> a_ar0 i_aqY e_aqZ
                                                                                            ~
                                                                                            (Int,
                                                                                             Int)
                                                                                            -> [a]
                                                                                            -> Vector
                                                                                                 a " p4.hs:30:14-25] (CNonCanonical)}
          Binds = EvBindsVar<ar4>
          the type signature for listVector :: (Int, Int) -> [a] -> Vector a}
solveWanteds {
  WC {wc_flat = [W] $dIArray_ar1 :: Data.Array.Base.IArray
                                      a_ar0
                                      e_aqZ [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                [W] $dIx_ar2 :: GHC.Arr.Ix
                                  i_aqY [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                [W] cobox_ar3 :: ((i_aqY, i_aqY) -> [e_aqZ] -> a_ar0 i_aqY e_aqZ)
                                 ~ ((Int, Int) -> [a] -> Vector a) [" a type equality (i_aqY, i_aqY)
                                                                                      -> [e_aqZ]
                                                                                      -> a_ar0 i_aqY e_aqZ
                                                                                      ~
                                                                                      (Int, Int)
                                                                                      -> [a]
                                                                                      -> Vector
                                                                                           a " p4.hs:30:14-25] (CNonCanonical)}
solveFlats {
Start solver pipeline {
  work item =  [W] cobox_ar3 :: ((i_aqY, i_aqY)
                                 -> [e_aqZ] -> a_ar0 i_aqY e_aqZ)
                                ~ ((Int, Int) -> [a] -> Vector a) [" a type equality (i_aqY, i_aqY)
                                                                                     -> [e_aqZ]
                                                                                     -> a_ar0 i_aqY e_aqZ
                                                                                     ~
                                                                                     (Int, Int)
                                                                                     -> [a]
                                                                                     -> Vector
                                                                                          a " p4.hs:30:14-25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_ar3 :: ((i_aqY, i_aqY)
                                  -> [e_aqZ] -> a_ar0 i_aqY e_aqZ)
                                 ~ ((Int, Int) -> [a] -> Vector a) [" a type equality (i_aqY, i_aqY)
                                                                                      -> [e_aqZ]
                                                                                      -> a_ar0 i_aqY e_aqZ
                                                                                      ~
                                                                                      (Int, Int)
                                                                                      -> [a]
                                                                                      -> Vector
                                                                                           a " p4.hs:30:14-25] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_ar3 :: ((i_aqY, i_aqY) -> [e_aqZ] -> a_ar0 i_aqY e_aqZ)
                   ~ ((Int, Int) -> [a] -> Vector a) [" a type equality (i_aqY, i_aqY)
                                                                        -> [e_aqZ]
                                                                        -> a_ar0 i_aqY e_aqZ
                                                                        ~
                                                                        (Int, Int)
                                                                        -> [a]
                                                                        -> Vector
                                                                             a " p4.hs:30:14-25] (CNonCanonical)
canEvNC:eq
  (i_aqY, i_aqY) -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
  (Int, Int) -> [a] -> Vector a
can_eq_nc
  [W] cobox_ar3 :: ((i_aqY, i_aqY) -> [e_aqZ] -> a_ar0 i_aqY e_aqZ)
                   ~ ((Int, Int) -> [a] -> Vector a)
  (i_aqY, i_aqY) -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
  (i_aqY, i_aqY) -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
  (Int, Int) -> [a] -> Vector a
  (Int, Int) -> [a] -> Vector a
newWantedEvVar/cache miss
  [W] cobox_aIP :: (i_aqY, i_aqY) ~ (Int, Int)
newWantedEvVar/cache miss
  [W] cobox_aIQ :: ([e_aqZ] -> a_ar0 i_aqY e_aqZ) ~ ([a] -> Vector a)
setEvBind
  ev = cobox_ar3
  tm  = CO cobox_aIP -> cobox_aIQ
canEvNC:eq
  (i_aqY, i_aqY)
  (Int, Int)
can_eq_nc
  [W] cobox_aIP :: (i_aqY, i_aqY) ~ (Int, Int)
  (i_aqY, i_aqY)
  (i_aqY, i_aqY)
  (Int, Int)
  (Int, Int)
newWantedEvVar/cache miss [W] cobox_aIR :: i_aqY ~ Int
newWantedEvVar/cache miss [W] cobox_aIS :: i_aqY ~ Int
setEvBind
  ev = cobox_aIP
  tm  = CO (cobox_aIR, cobox_aIS)_N
canEvNC:eq
  i_aqY
  Int
can_eq_nc
  [W] cobox_aIR :: i_aqY ~ Int
  i_aqY
  i_aqY
  Int
  Int
canEqTyVar
  i_aqY
  Int
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_aIR :: i_aqY
                                 ~ Int [" a type equality (i_aqY, i_aqY)
                                                          -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                          ~
                                                          (Int, Int)
                                                          -> [a]
                                                          -> Vector a " p4.hs:30:14-25] (CTyEqCan)
Sneaky unification:
  Unifies: i_aqY := Int
  Coercion: i_aqY ~ Int
  Left Kind is: *
  Right Kind is: *
setWantedTyBind i_aqY := Int
setEvBind
  ev = cobox_aIR
  tm  = CO <Int>_N
kickOutRewritable
  tv =  i_aqY
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
43[<C:0,F:0>] [W] cobox_aIR :: i_aqY ~ Int: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_aIS :: i_aqY
                                ~ Int [" a type equality (i_aqY, i_aqY)
                                                         -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                         ~
                                                         (Int, Int)
                                                         -> [a]
                                                         -> Vector
                                                              a " p4.hs:30:14-25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_aIS :: i_aqY
                                 ~ Int [" a type equality (i_aqY, i_aqY)
                                                          -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                          ~
                                                          (Int, Int)
                                                          -> [a]
                                                          -> Vector
                                                               a " p4.hs:30:14-25] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_aIS :: i_aqY ~ Int [" a type equality (i_aqY, i_aqY)
                                                  -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                  ~
                                                  (Int, Int)
                                                  -> [a]
                                                  -> Vector a " p4.hs:30:14-25] (CNonCanonical)
canEvNC:eq
  i_aqY
  Int
can_eq_nc
  [W] cobox_aIS :: i_aqY ~ Int
  i_aqY
  i_aqY
  Int
  Int
canEqTyVar
  i_aqY
  Int
  Not-swapped
Following bound tyvar i_aqY = Int
canEqTyVar2
  i_aqY
  Int
  Not-swapped
  Int
  <Int>_N
can_eq_nc
  [W] cobox_aIS :: Int ~ Int
  Int
  Int
  Int
  Int
setEvBind
  ev = cobox_aIS
  tm  = CO <Int>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_aIQ :: ([e_aqZ] -> a_ar0 i_aqY e_aqZ)
                                ~ ([a] -> Vector a) [" a type equality (i_aqY, i_aqY)
                                                                       -> [e_aqZ]
                                                                       -> a_ar0 i_aqY e_aqZ
                                                                       ~
                                                                       (Int, Int)
                                                                       -> [a]
                                                                       -> Vector
                                                                            a " p4.hs:30:14-25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_aIQ :: ([e_aqZ] -> a_ar0 i_aqY e_aqZ)
                                 ~ ([a] -> Vector a) [" a type equality (i_aqY, i_aqY)
                                                                        -> [e_aqZ]
                                                                        -> a_ar0 i_aqY e_aqZ
                                                                        ~
                                                                        (Int, Int)
                                                                        -> [a]
                                                                        -> Vector
                                                                             a " p4.hs:30:14-25] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_aIQ :: ([e_aqZ] -> a_ar0 i_aqY e_aqZ)
                   ~ ([a] -> Vector a) [" a type equality (i_aqY, i_aqY)
                                                          -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                          ~
                                                          (Int, Int)
                                                          -> [a]
                                                          -> Vector
                                                               a " p4.hs:30:14-25] (CNonCanonical)
canEvNC:eq
  [e_aqZ] -> a_ar0 i_aqY e_aqZ
  [a] -> Vector a
can_eq_nc
  [W] cobox_aIQ :: ([e_aqZ] -> a_ar0 i_aqY e_aqZ) ~ ([a] -> Vector a)
  [e_aqZ] -> a_ar0 i_aqY e_aqZ
  [e_aqZ] -> a_ar0 i_aqY e_aqZ
  [a] -> Vector a
  [a] -> Vector a
newWantedEvVar/cache miss [W] cobox_aIT :: [e_aqZ] ~ [a]
newWantedEvVar/cache miss
  [W] cobox_aIU :: a_ar0 i_aqY e_aqZ ~ Vector a
setEvBind
  ev = cobox_aIQ
  tm  = CO cobox_aIT -> cobox_aIU
canEvNC:eq
  [e_aqZ]
  [a]
can_eq_nc
  [W] cobox_aIT :: [e_aqZ] ~ [a]
  [e_aqZ]
  [e_aqZ]
  [a]
  [a]
newWantedEvVar/cache miss [W] cobox_aIV :: e_aqZ ~ a
setEvBind
  ev = cobox_aIT
  tm  = CO [cobox_aIV]_N
canEvNC:eq
  e_aqZ
  a
can_eq_nc
  [W] cobox_aIV :: e_aqZ ~ a
  e_aqZ
  e_aqZ
  a
  a
canEqTyVar
  e_aqZ
  a
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_aIV :: e_aqZ ~ a [" a type equality (i_aqY,
                                                               i_aqY)
                                                              -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                              ~
                                                              (Int, Int)
                                                              -> [a]
                                                              -> Vector
                                                                   a " p4.hs:30:14-25] (CTyEqCan)
Sneaky unification:
  Unifies: e_aqZ := a
  Coercion: e_aqZ ~ a
  Left Kind is: *
  Right Kind is: *
setWantedTyBind e_aqZ := a
setEvBind
  ev = cobox_aIV
  tm  = CO <a>_N
kickOutRewritable
  tv =  e_aqZ
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
45[<C:0,F:0>] [W] cobox_aIV :: e_aqZ ~ a: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_aIU :: a_ar0 i_aqY e_aqZ
                                ~ Vector a [" a type equality (i_aqY, i_aqY)
                                                              -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                              ~
                                                              (Int, Int)
                                                              -> [a]
                                                              -> Vector
                                                                   a " p4.hs:30:14-25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_aIU :: a_ar0 i_aqY e_aqZ
                                 ~ Vector a [" a type equality (i_aqY, i_aqY)
                                                               -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                               ~
                                                               (Int, Int)
                                                               -> [a]
                                                               -> Vector
                                                                    a " p4.hs:30:14-25] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_aIU :: a_ar0 i_aqY e_aqZ
                   ~ Vector a [" a type equality (i_aqY, i_aqY)
                                                 -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                 ~
                                                 (Int, Int)
                                                 -> [a]
                                                 -> Vector a " p4.hs:30:14-25] (CNonCanonical)
canEvNC:eq
  a_ar0 i_aqY e_aqZ
  Vector a
can_eq_nc
  [W] cobox_aIU :: a_ar0 i_aqY e_aqZ ~ Vector a
  a_ar0 i_aqY e_aqZ
  a_ar0 i_aqY e_aqZ
  Vector a
  Vector a
can_eq_nc
  [W] cobox_aIU :: a_ar0 i_aqY e_aqZ ~ Vector a
  a_ar0 i_aqY e_aqZ
  a_ar0 i_aqY e_aqZ
  Array Int a
  Vector a
can_eq_app 1
  [W] cobox_aIU :: a_ar0 i_aqY e_aqZ ~ Vector a
  Not-swapped
  a_ar0 i_aqY
  e_aqZ
  Array Int a
Following bound tyvar i_aqY = Int
flatten/appty
  a_ar0
  i_aqY
  a_ar0
  <a_ar0>_N
  Int
  <Int>_N
can_eq_app 2
  [W] cobox_aIU :: a_ar0 i_aqY e_aqZ ~ Vector a
  a_ar0 Int
Following bound tyvar e_aqZ = a
can_eq_app 3
  [W] cobox_aIU :: a_ar0 i_aqY e_aqZ ~ Vector a
  a_ar0 Int a
  <a_ar0 Int a>_N
can_eq_app 4
  [W] cobox_aIU :: a_ar0 i_aqY e_aqZ ~ Vector a
  a_ar0 Int a
  <a_ar0 Int a>_N
can_eq_nc
  [W] cobox_aIU :: a_ar0 Int a ~ Vector a
  a_ar0 Int a
  a_ar0 Int a
  Array Int a
  Vector a
can_eq_app 1
  [W] cobox_aIU :: a_ar0 Int a ~ Vector a
  Not-swapped
  a_ar0 Int
  a
  Array Int a
flatten/appty
  a_ar0
  Int
  a_ar0
  <a_ar0>_N
  Int
  <Int>_N
can_eq_app 2
  [W] cobox_aIU :: a_ar0 Int a ~ Vector a
  a_ar0 Int
newWantedEvVar/cache miss [W] cobox_aIW :: a_ar0 Int ~ Array Int
newWantedEvVar/cache miss [W] cobox_aIX :: a ~ a
setEvBind
  ev = cobox_aIU
  tm  = CO cobox_aIW cobox_aIX
canEvNC:eq
  a_ar0 Int
  Array Int
can_eq_nc
  [W] cobox_aIW :: a_ar0 Int ~ Array Int
  a_ar0 Int
  a_ar0 Int
  Array Int
  Array Int
can_eq_app 1
  [W] cobox_aIW :: a_ar0 Int ~ Array Int
  Not-swapped
  a_ar0
  Int
  Array Int
can_eq_app 2
  [W] cobox_aIW :: a_ar0 Int ~ Array Int
  a_ar0
newWantedEvVar/cache miss [W] cobox_aIY :: a_ar0 ~ Array
newWantedEvVar/cache miss [W] cobox_aIZ :: Int ~ Int
setEvBind
  ev = cobox_aIW
  tm  = CO cobox_aIY cobox_aIZ
canEvNC:eq
  a_ar0
  Array
can_eq_nc
  [W] cobox_aIY :: a_ar0 ~ Array
  a_ar0
  a_ar0
  Array
  Array
canEqTyVar
  a_ar0
  Array
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_aIY :: a_ar0
                                 ~ Array [" a type equality (i_aqY, i_aqY)
                                                            -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                            ~
                                                            (Int, Int)
                                                            -> [a]
                                                            -> Vector a " p4.hs:30:14-25] (CTyEqCan)
Sneaky unification:
  Unifies: a_ar0 := Array
  Coercion: a_ar0 ~ Array
  Left Kind is: * -> * -> *
  Right Kind is: * -> * -> *
setWantedTyBind a_ar0 := Array
setEvBind
  ev = cobox_aIY
  tm  = CO <Array>_N
kickOutRewritable
  tv =  a_ar0
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
46[<C:0,F:0>] [W] cobox_aIY :: a_ar0 ~ Array: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_aIZ :: Int ~ Int [" a type equality (i_aqY,
                                                              i_aqY)
                                                             -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                             ~
                                                             (Int, Int)
                                                             -> [a]
                                                             -> Vector
                                                                  a " p4.hs:30:14-25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_aIZ :: Int ~ Int [" a type equality (i_aqY,
                                                               i_aqY)
                                                              -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                              ~
                                                              (Int, Int)
                                                              -> [a]
                                                              -> Vector
                                                                   a " p4.hs:30:14-25] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_aIZ :: Int ~ Int [" a type equality (i_aqY, i_aqY)
                                                -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                ~
                                                (Int, Int)
                                                -> [a] -> Vector a " p4.hs:30:14-25] (CNonCanonical)
canEvNC:eq
  Int
  Int
can_eq_nc
  [W] cobox_aIZ :: Int ~ Int
  Int
  Int
  Int
  Int
setEvBind
  ev = cobox_aIZ
  tm  = CO <Int>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_aIX :: a ~ a [" a type equality (i_aqY,
                                                          i_aqY)
                                                         -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                         ~
                                                         (Int, Int)
                                                         -> [a]
                                                         -> Vector
                                                              a " p4.hs:30:14-25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_aIX :: a ~ a [" a type equality (i_aqY,
                                                           i_aqY)
                                                          -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                                          ~
                                                          (Int, Int)
                                                          -> [a]
                                                          -> Vector
                                                               a " p4.hs:30:14-25] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_aIX :: a ~ a [" a type equality (i_aqY, i_aqY)
                                            -> [e_aqZ] -> a_ar0 i_aqY e_aqZ
                                            ~
                                            (Int, Int)
                                            -> [a] -> Vector a " p4.hs:30:14-25] (CNonCanonical)
canEvNC:eq
  a
  a
can_eq_nc
  [W] cobox_aIX :: a ~ a
  a
  a
  a
  a
canEqTyVar
  a
  a
  Not-swapped
setEvBind
  ev = cobox_aIX
  tm  = CO <a>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dIArray_ar1 :: Data.Array.Base.IArray
                                     a_ar0
                                     e_aqZ [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dIArray_ar1 :: Data.Array.Base.IArray
                                      a_ar0
                                      e_aqZ [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dIArray_ar1 :: Data.Array.Base.IArray
                        a_ar0
                        e_aqZ [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
canEvNC:cls Data.Array.Base.IArray [a_ar0, e_aqZ]
Following bound tyvar a_ar0 = Array
Following bound tyvar e_aqZ = a
canClass
  [W] $dIArray_ar1 :: Data.Array.Base.IArray
                        a_ar0 e_aqZ Data.Array.Base.IArray [a_ar0, e_aqZ]
  Data.Array.Base.IArray Array a
  Just [W] $dIArray_ar1 :: Data.Array.Base.IArray Array a
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dIArray_ar1 :: Data.Array.Base.IArray
                                      Array a [" a use of ‘listArray’ " p4.hs:30:14-25] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dIArray_ar1 :: Data.Array.Base.IArray
                                      Array a [" a use of ‘listArray’ " p4.hs:30:14-25] (CDictCan)
doTopReact
  [W] $dIArray_ar1 :: Data.Array.Base.IArray
                        Array a [" a use of ‘listArray’ " p4.hs:30:14-25] (CDictCan)
matchClassInst
  pred = Data.Array.Base.IArray Array a
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 6
          Solved funeqs 0
  untouchables= 1
matchClass success
  dict Data.Array.Base.IArray Array a
  witness Data.Array.Base.$fIArrayArraye forall e.
                                         Data.Array.Base.IArray Array e
updSolvedSetTcs: [W] $dIArray_ar1 :: Data.Array.Base.IArray Array a
doTopReact/found nullary instance for $dIArray_ar1
setEvBind
  ev = $dIArray_ar1
  tm  = Data.Array.Base.$fIArrayArraye @[a] []
49[<C:0,F:0>] [W] $dIArray_ar1 :: Data.Array.Base.IArray
                                    Array a: Top react: Dict/Top (solved, no new work)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 7
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dIx_ar2 :: GHC.Arr.Ix
                                 i_aqY [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 7
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dIx_ar2 :: GHC.Arr.Ix
                                  i_aqY [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dIx_ar2 :: GHC.Arr.Ix
                    i_aqY [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
canEvNC:cls GHC.Arr.Ix [i_aqY]
Following bound tyvar i_aqY = Int
canClass
  [W] $dIx_ar2 :: GHC.Arr.Ix i_aqY GHC.Arr.Ix [i_aqY]
  GHC.Arr.Ix Int
  Just [W] $dIx_ar2 :: GHC.Arr.Ix Int
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dIx_ar2 :: GHC.Arr.Ix
                                  Int [" a use of ‘listArray’ " p4.hs:30:14-25] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dIx_ar2 :: GHC.Arr.Ix
                                  Int [" a use of ‘listArray’ " p4.hs:30:14-25] (CDictCan)
doTopReact
  [W] $dIx_ar2 :: GHC.Arr.Ix
                    Int [" a use of ‘listArray’ " p4.hs:30:14-25] (CDictCan)
setEvBind
  ev = $dIx_ar2
  tm  = $dIx_ara
50[<C:0,F:0>] [W] $dIx_ar2 :: GHC.Arr.Ix
                                Int: Top react: Dict/Top (cached)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 7
               Solved funeqs 0
solveFlats end } {}
simpl_loop, iteration 1
solveWanteds }
  unsolved_flats   = {}
  unsolved_implics = {}
  current evbinds  = {$dIArray_ar1
                        = Data.Array.Base.$fIArrayArraye @[a] [],
                      $dIx_ar2 = $dIx_ara, cobox_ar3 = CO cobox_aIP -> cobox_aIQ,
                      cobox_aIP = CO (cobox_aIR, cobox_aIS)_N,
                      cobox_aIQ = CO cobox_aIT -> cobox_aIU, cobox_aIR = CO <Int>_N,
                      cobox_aIS = CO <Int>_N, cobox_aIT = CO [cobox_aIV]_N,
                      cobox_aIU = CO cobox_aIW cobox_aIX, cobox_aIV = CO <a>_N,
                      cobox_aIW = CO cobox_aIY cobox_aIZ, cobox_aIX = CO <a>_N,
                      cobox_aIY = CO <Array>_N, cobox_aIZ = CO <Int>_N}
  current tybinds  = (i_aqY, Int)
                     (e_aqZ, a)
                     (a_ar0, Array)
                     (i_ar6, Int)
                     (e_ar7, Double)
                     (a_ar8, UArray)
                     (a_au2, Int)
                     (t_auT, a_au2)
                     (t_auX, a_auY)
                     (a_auY, Int)
                     (a_ax0, FlatVector)
                     (t_ax4, m_ax9 a_axb)
                     (t_ax5, a_axb)
                     (t_ax6, m_ax9 b_axc)
                     (m_ax9, IO)
                     (a_axb, b_axC i_axz e_axA)
                     (b_axc, ())
                     (a_axy, Array)
                     (i_axz, Int)
                     (e_axA, FlatVector)
                     (m_axB, IO)
                     (m_axJ, IO)
                     (a_axL, ())
                     (t_axP, ())
  final wc = WC {}
floatEqualities
  Flats = {}
  Floated eqs = {}
  Ty binds = [(aqY, (i_aqY, Int)), (aqZ, (e_aqZ, a)),
              (ar0, (a_ar0, Array)), (ar6, (i_ar6, Int)), (ar7, (e_ar7, Double)),
              (ar8, (a_ar8, UArray)), (au2, (a_au2, Int)), (auT, (t_auT, a_au2)),
              (auX, (t_auX, a_auY)), (auY, (a_auY, Int)),
              (ax0, (a_ax0, FlatVector)), (ax4, (t_ax4, m_ax9 a_axb)),
              (ax5, (t_ax5, a_axb)), (ax6, (t_ax6, m_ax9 b_axc)),
              (ax9, (m_ax9, IO)), (axb, (a_axb, b_axC i_axz e_axA)),
              (axc, (b_axc, ())), (axy, (a_axy, Array)), (axz, (i_axz, Int)),
              (axA, (e_axA, FlatVector)), (axB, (m_axB, IO)), (axJ, (m_axJ, IO)),
              (axL, (a_axL, ())), (axP, (t_axP, ()))]
solveImplication end }
  no_given_eqs = True
  floated_eqs = {}
  new_fsks = []
  res_implic = {}
  implication evbinds =  {$dIArray_ar9
                            = Data.Array.Base.$fIArrayUArrayDouble @[] [],
                          $dIx_ara = GHC.Arr.$fIxInt @[] [],
                          cobox_arb = CO cobox_ay9 -> cobox_aya,
                          $dNum_atO = GHC.Num.$fNumInt @[] [], cobox_auU = CO [cobox_ayk]_N,
                          cobox_auV = CO UArray cobox_ayl cobox_aym_N,
                          cobox_auW = CO <Int>_N, $dNum_auZ = $dNum_atO,
                          cobox_av0 = CO cobox_ayn -> cobox_ayo,
                          cobox_av1 = CO Sym cobox_ayp,
                          $dEnum_awY = GHC.Enum.$fEnumInt @[] [],
                          cobox_ax1 = CO Array cobox_ayq cobox_ayr_N, cobox_ax2 = CO <Int>_N,
                          cobox_ax3 = CO [cobox_ays]_N,
                          $dMonad_axa = GHC.Base.$fMonadIO @[] [],
                          cobox_axe = CO cobox_ayw -> cobox_ayx, $dIx_axD = $dIx_ara,
                          $dIArray_axE
                            = Data.Array.Base.$fIArrayArraye @[UArray Int Double] [],
                          cobox_axG = CO Sym cobox_ayG, cobox_axH = CO cobox_ayK cobox_ayL,
                          $dMonad_axK = $dMonad_axa, cobox_axN = CO Sym cobox_ayR,
                          cobox_axO = CO Sym cobox_ayW, cobox_axQ = CO IO cobox_ayX_N,
                          cobox_ay9 = CO (cobox_ayb, cobox_ayc)_N,
                          cobox_aya = CO cobox_ayd -> cobox_aye, cobox_ayb = CO <Int>_N,
                          cobox_ayc = CO <Int>_N, cobox_ayd = CO [cobox_ayf]_N,
                          cobox_aye = CO cobox_ayg cobox_ayh, cobox_ayf = CO <Double>_N,
                          cobox_ayg = CO cobox_ayi cobox_ayj, cobox_ayh = CO <Double>_N,
                          cobox_ayi = CO <UArray>_N, cobox_ayj = CO <Int>_N,
                          cobox_ayk = CO <a_au2>_N, cobox_ayl = CO <Int>_N,
                          cobox_aym = CO <Double>_N, cobox_ayn = CO <Integer>_N,
                          cobox_ayo = CO <a_auY>_N, cobox_ayp = CO <Int>_N,
                          cobox_ayq = CO <Int>_N, cobox_ayr = CO <FlatVector>_N,
                          cobox_ays = CO Sym cobox_ayt,
                          cobox_ayt = CO UArray cobox_ayu cobox_ayv_N,
                          cobox_ayu = CO <Int>_N, cobox_ayv = CO <Double>_N,
                          cobox_ayw = CO Sym cobox_ayy,
                          cobox_ayx = CO cobox_ayz -> cobox_ayA,
                          cobox_ayy = CO <m_ax9 a_axb>_N,
                          cobox_ayz = CO cobox_ayB -> cobox_ayC,
                          cobox_ayA = CO cobox_ayE cobox_ayF, cobox_ayB = CO <a_axb>_N,
                          cobox_ayC = CO Sym cobox_ayD, cobox_ayD = CO <m_ax9 b_axc>_N,
                          cobox_ayE = CO <IO>_N, cobox_ayF = CO <()>_N,
                          cobox_ayG = CO cobox_ayH cobox_ayI, cobox_ayH = CO Sym cobox_ayJ,
                          cobox_ayI = CO <b_axC i_axz e_axA>_N, cobox_ayJ = CO <IO>_N,
                          cobox_ayK = CO cobox_ayM cobox_ayN, cobox_ayL = CO Sym cobox_ayQ,
                          cobox_ayM = CO Sym cobox_ayO, cobox_ayN = CO Sym cobox_ayP,
                          cobox_ayO = CO <Array>_N, cobox_ayP = CO <Int>_N,
                          cobox_ayQ = CO <FlatVector>_N, cobox_ayR = CO cobox_ayS cobox_ayT,
                          cobox_ayS = CO Sym cobox_ayU, cobox_ayT = CO Sym cobox_ayV,
                          cobox_ayU = CO <IO>_N, cobox_ayV = CO <()>_N,
                          cobox_ayW = CO <()>_N, cobox_ayX = CO Sym cobox_ayY,
                          cobox_ayY = CO <()>_N}
solveNestedImplications end }
  all floated_eqs = {}
  unsolved_implics = {}
solveWanteds }
  unsolved_flats   = {[W] $dMArray_axF :: Data.Array.Base.MArray
                                            b_axC
                                            FlatVector
                                            IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)}
  unsolved_implics = {}
  current evbinds  = {$dIArray_ar9
                        = Data.Array.Base.$fIArrayUArrayDouble @[] [],
                      $dIx_ara = GHC.Arr.$fIxInt @[] [],
                      cobox_arb = CO cobox_ay9 -> cobox_aya,
                      $dNum_atO = GHC.Num.$fNumInt @[] [], cobox_auU = CO [cobox_ayk]_N,
                      cobox_auV = CO UArray cobox_ayl cobox_aym_N,
                      cobox_auW = CO <Int>_N, $dNum_auZ = $dNum_atO,
                      cobox_av0 = CO cobox_ayn -> cobox_ayo,
                      cobox_av1 = CO Sym cobox_ayp,
                      $dEnum_awY = GHC.Enum.$fEnumInt @[] [],
                      cobox_ax1 = CO Array cobox_ayq cobox_ayr_N, cobox_ax2 = CO <Int>_N,
                      cobox_ax3 = CO [cobox_ays]_N,
                      $dMonad_axa = GHC.Base.$fMonadIO @[] [],
                      cobox_axe = CO cobox_ayw -> cobox_ayx, $dIx_axD = $dIx_ara,
                      $dIArray_axE
                        = Data.Array.Base.$fIArrayArraye @[UArray Int Double] [],
                      cobox_axG = CO Sym cobox_ayG, cobox_axH = CO cobox_ayK cobox_ayL,
                      $dMonad_axK = $dMonad_axa, cobox_axN = CO Sym cobox_ayR,
                      cobox_axO = CO Sym cobox_ayW, cobox_axQ = CO IO cobox_ayX_N,
                      cobox_ay9 = CO (cobox_ayb, cobox_ayc)_N,
                      cobox_aya = CO cobox_ayd -> cobox_aye, cobox_ayb = CO <Int>_N,
                      cobox_ayc = CO <Int>_N, cobox_ayd = CO [cobox_ayf]_N,
                      cobox_aye = CO cobox_ayg cobox_ayh, cobox_ayf = CO <Double>_N,
                      cobox_ayg = CO cobox_ayi cobox_ayj, cobox_ayh = CO <Double>_N,
                      cobox_ayi = CO <UArray>_N, cobox_ayj = CO <Int>_N,
                      cobox_ayk = CO <a_au2>_N, cobox_ayl = CO <Int>_N,
                      cobox_aym = CO <Double>_N, cobox_ayn = CO <Integer>_N,
                      cobox_ayo = CO <a_auY>_N, cobox_ayp = CO <Int>_N,
                      cobox_ayq = CO <Int>_N, cobox_ayr = CO <FlatVector>_N,
                      cobox_ays = CO Sym cobox_ayt,
                      cobox_ayt = CO UArray cobox_ayu cobox_ayv_N,
                      cobox_ayu = CO <Int>_N, cobox_ayv = CO <Double>_N,
                      cobox_ayw = CO Sym cobox_ayy,
                      cobox_ayx = CO cobox_ayz -> cobox_ayA,
                      cobox_ayy = CO <m_ax9 a_axb>_N,
                      cobox_ayz = CO cobox_ayB -> cobox_ayC,
                      cobox_ayA = CO cobox_ayE cobox_ayF, cobox_ayB = CO <a_axb>_N,
                      cobox_ayC = CO Sym cobox_ayD, cobox_ayD = CO <m_ax9 b_axc>_N,
                      cobox_ayE = CO <IO>_N, cobox_ayF = CO <()>_N,
                      cobox_ayG = CO cobox_ayH cobox_ayI, cobox_ayH = CO Sym cobox_ayJ,
                      cobox_ayI = CO <b_axC i_axz e_axA>_N, cobox_ayJ = CO <IO>_N,
                      cobox_ayK = CO cobox_ayM cobox_ayN, cobox_ayL = CO Sym cobox_ayQ,
                      cobox_ayM = CO Sym cobox_ayO, cobox_ayN = CO Sym cobox_ayP,
                      cobox_ayO = CO <Array>_N, cobox_ayP = CO <Int>_N,
                      cobox_ayQ = CO <FlatVector>_N, cobox_ayR = CO cobox_ayS cobox_ayT,
                      cobox_ayS = CO Sym cobox_ayU, cobox_ayT = CO Sym cobox_ayV,
                      cobox_ayU = CO <IO>_N, cobox_ayV = CO <()>_N,
                      cobox_ayW = CO <()>_N, cobox_ayX = CO Sym cobox_ayY,
                      cobox_ayY = CO <()>_N}
  current tybinds  = (i_aqY, Int)
                     (e_aqZ, a)
                     (a_ar0, Array)
                     (i_ar6, Int)
                     (e_ar7, Double)
                     (a_ar8, UArray)
                     (a_au2, Int)
                     (t_auT, a_au2)
                     (t_auX, a_auY)
                     (a_auY, Int)
                     (a_ax0, FlatVector)
                     (t_ax4, m_ax9 a_axb)
                     (t_ax5, a_axb)
                     (t_ax6, m_ax9 b_axc)
                     (m_ax9, IO)
                     (a_axb, b_axC i_axz e_axA)
                     (b_axc, ())
                     (a_axy, Array)
                     (i_axz, Int)
                     (e_axA, FlatVector)
                     (m_axB, IO)
                     (m_axJ, IO)
                     (a_axL, ())
                     (t_axP, ())
  final wc = WC {wc_flat = [W] $dMArray_axF :: Data.Array.Base.MArray
                                                 b_axC
                                                 FlatVector
                                                 IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)}
applyDefaultingRules { 
  wanteds = {[W] $dMArray_axF :: Data.Array.Base.MArray
                                   b_axC
                                   FlatVector
                                   IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)}
findDefaultableGroups
  groups= []
  info= ([Integer, Double], (False, False))
applyDefaultingRules } []
writeMetaTyVar i_aqY := Int
writeMetaTyVar e_aqZ := a
writeMetaTyVar a_ar0 := Array
writeMetaTyVar i_ar6 := Int
writeMetaTyVar e_ar7 := Double
writeMetaTyVar a_ar8 := UArray
writeMetaTyVar a_au2 := Int
writeMetaTyVar t_auT := a_au2
writeMetaTyVar t_auX := a_auY
writeMetaTyVar a_auY := Int
writeMetaTyVar a_ax0 := FlatVector
writeMetaTyVar t_ax4 := m_ax9 a_axb
writeMetaTyVar t_ax5 := a_axb
writeMetaTyVar t_ax6 := m_ax9 b_axc
writeMetaTyVar m_ax9 := IO
writeMetaTyVar a_axb := b_axC i_axz e_axA
writeMetaTyVar b_axc := ()
writeMetaTyVar a_axy := Array
writeMetaTyVar i_axz := Int
writeMetaTyVar e_axA := FlatVector
writeMetaTyVar m_axB := IO
writeMetaTyVar m_axJ := IO
writeMetaTyVar a_axL := ()
writeMetaTyVar t_axP := ()
Constraint solver steps = 50
End simplifyTop }
reportUnsolved {
reportUnsolved (before unflattening)
  WC {wc_flat = [W] $dMArray_axF :: Data.Array.Base.MArray
                                      b_axC
                                      FlatVector
                                      IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)}
reportUnsolved (after unflattening):
  (b_axC :: * -> * -> *)
  WC {wc_flat = [W] $dMArray_axF :: Data.Array.Base.MArray
                                      b_axC
                                      FlatVector
                                      IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)}
reportFlats
  Flats = {}
  Suppress = False
tryReporters { []
tryReporters: no Utterly wrong
tryReporters: no Holes
tryReporters: no Skolem equalities
tryReporters: no Equalities
tryReporters: no Implicit params
tryReporters: no Irreds
tryReporters: no Dicts
tryReporters }
reportFlats
  Flats = {}
  Suppress = False
tryReporters { []
tryReporters: no Utterly wrong
tryReporters: no Holes
tryReporters: no Skolem equalities
tryReporters: no Equalities
tryReporters: no Implicit params
tryReporters: no Irreds
tryReporters: no Dicts
tryReporters }
reportFlats
  Flats = {[W] $dMArray_axF :: Data.Array.Base.MArray
                                 b0
                                 FlatVector
                                 IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)}
  Suppress = False
tryReporters {
  [[W] $dMArray_axF :: Data.Array.Base.MArray
                         b0
                         FlatVector
                         IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)]
tryReporters: no Utterly wrong
tryReporters: no Holes
tryReporters: no Skolem equalities
tryReporters: no Equalities
tryReporters: no Implicit params
tryReporters: no Irreds
tryReporters: yes
  Dicts [[W] $dMArray_axF :: Data.Array.Base.MArray
                               b0
                               FlatVector
                               IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)]
relevantBindings
  [tmp, help, dim, sL, main, listFlatVector, listVector]
mk_dict_err
  [W] $dMArray_axF :: Data.Array.Base.MArray
                        b0
                        FlatVector
                        IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
  True
  The type variable ‘b0’ is ambiguous
Adding error:
  p4.hs:19:16:
      No instance for (Data.Array.Base.MArray b0 FlatVector IO)
        arising from a use of ‘thaw’
      The type variable ‘b0’ is ambiguous
      Note: there is a potential instance available:
        instance Data.Array.Base.MArray GHC.IOArray.IOArray e IO
          -- Defined in ‘Data.Array.Base’
      In a stmt of a 'do' block: v <- thaw tmp
      In the expression:
        do { let sL = ...
                 dim = length sL
                 ....;
             v <- thaw tmp;
             return () }
      In an equation for ‘main’:
          main
            = do { let sL = ...
                       ....;
                   v <- thaw tmp;
                   return () }
tryReporters }
reportUnsolved }
InstEnvs (External) {
  instance Control.Applicative.Alternative []
    -- Defined in ‘Control.Applicative’
  instance Control.Monad.MonadPlus m =>
           Control.Applicative.Alternative
             (Control.Applicative.WrappedMonad m)
    -- Defined in ‘Control.Applicative’
  instance (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) =>
           Control.Applicative.Alternative
             (Control.Applicative.WrappedArrow a b)
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Alternative GHC.Conc.Sync.STM
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Alternative
             Text.ParserCombinators.ReadPrec.ReadPrec
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Alternative
             Text.ParserCombinators.ReadP.ReadP
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Alternative Maybe
    -- Defined in ‘Control.Applicative’
  instance Control.Arrow.ArrowPlus a =>
           Control.Applicative.Alternative (Control.Arrow.ArrowMonad a)
    -- Defined in ‘Control.Applicative’
  instance Bounded GHC.Int.Int8 -- Defined in ‘GHC.Int’
  instance Bounded GHC.Int.Int64 -- Defined in ‘GHC.Int’
  instance Bounded GHC.Int.Int32 -- Defined in ‘GHC.Int’
  instance Bounded GHC.Int.Int16 -- Defined in ‘GHC.Int’
  instance Bounded GHC.Word.Word8 -- Defined in ‘GHC.Word’
  instance Bounded GHC.Word.Word64 -- Defined in ‘GHC.Word’
  instance Bounded GHC.Word.Word32 -- Defined in ‘GHC.Word’
  instance Bounded GHC.Word.Word16 -- Defined in ‘GHC.Word’
  instance Bounded GHC.Types.Word -- Defined in ‘GHC.Enum’
  instance Bounded Ordering -- Defined in ‘GHC.Enum’
  instance Bounded Int -- Defined in ‘GHC.Enum’
  instance Bounded Char -- Defined in ‘GHC.Enum’
  instance Bounded Bool -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
            Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k,
            Bounded l, Bounded m, Bounded n, Bounded o) =>
           Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
    -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
            Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k,
            Bounded l, Bounded m, Bounded n) =>
           Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
    -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
            Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k,
            Bounded l, Bounded m) =>
           Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m)
    -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
            Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k,
            Bounded l) =>
           Bounded (a, b, c, d, e, f, g, h, i, j, k, l)
    -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
            Bounded f, Bounded g, Bounded h, Bounded i, Bounded j,
            Bounded k) =>
           Bounded (a, b, c, d, e, f, g, h, i, j, k)
    -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
            Bounded f, Bounded g, Bounded h, Bounded i, Bounded j) =>
           Bounded (a, b, c, d, e, f, g, h, i, j)
    -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
            Bounded f, Bounded g, Bounded h, Bounded i) =>
           Bounded (a, b, c, d, e, f, g, h, i)
    -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
            Bounded f, Bounded g, Bounded h) =>
           Bounded (a, b, c, d, e, f, g, h)
    -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
            Bounded f, Bounded g) =>
           Bounded (a, b, c, d, e, f, g)
    -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
            Bounded f) =>
           Bounded (a, b, c, d, e, f)
    -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e) =>
           Bounded (a, b, c, d, e)
    -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b, Bounded c, Bounded d) =>
           Bounded (a, b, c, d)
    -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b, Bounded c) => Bounded (a, b, c)
    -- Defined in ‘GHC.Enum’
  instance (Bounded a, Bounded b) => Bounded (a, b)
    -- Defined in ‘GHC.Enum’
  instance Bounded () -- Defined in ‘GHC.Enum’
  instance Enum GHC.Int.Int8 -- Defined in ‘GHC.Int’
  instance Enum GHC.Int.Int64 -- Defined in ‘GHC.Int’
  instance Enum GHC.Int.Int32 -- Defined in ‘GHC.Int’
  instance Enum GHC.Int.Int16 -- Defined in ‘GHC.Int’
  instance Enum GHC.Word.Word8 -- Defined in ‘GHC.Word’
  instance Enum GHC.Word.Word64 -- Defined in ‘GHC.Word’
  instance Enum GHC.Word.Word32 -- Defined in ‘GHC.Word’
  instance Enum GHC.Word.Word16 -- Defined in ‘GHC.Word’
  instance Enum Ordering -- Defined in ‘GHC.Enum’
  instance Enum Integer -- Defined in ‘GHC.Enum’
  instance Enum Int -- Defined in ‘GHC.Enum’
  instance Enum Char -- Defined in ‘GHC.Enum’
  instance Enum Bool -- Defined in ‘GHC.Enum’
  instance Enum () -- Defined in ‘GHC.Enum’
  instance Enum GHC.Types.Word -- Defined in ‘GHC.Real’
  instance Integral a => Enum (GHC.Real.Ratio a)
    -- Defined in ‘GHC.Real’
  instance Enum Float -- Defined in ‘GHC.Float’
  instance Enum Double -- Defined in ‘GHC.Float’
  instance Eq (GHC.IOArray.IOArray i e) -- Defined in ‘GHC.IOArray’
  instance Eq GHC.Int.Int8 -- Defined in ‘GHC.Int’
  instance Eq GHC.Int.Int64 -- Defined in ‘GHC.Int’
  instance Eq GHC.Int.Int32 -- Defined in ‘GHC.Int’
  instance Eq GHC.Int.Int16 -- Defined in ‘GHC.Int’
  instance Eq (GHC.Ptr.Ptr a) -- Defined in ‘GHC.Ptr’
  instance Eq (GHC.Ptr.FunPtr a) -- Defined in ‘GHC.Ptr’
  instance Eq (GHC.Stable.StablePtr a) -- Defined in ‘GHC.Stable’
  instance Eq GHC.Word.Word8 -- Defined in ‘GHC.Word’
  instance Eq GHC.Word.Word64 -- Defined in ‘GHC.Word’
  instance Eq GHC.Word.Word32 -- Defined in ‘GHC.Word’
  instance Eq GHC.Word.Word16 -- Defined in ‘GHC.Word’
  instance Eq Integer -- Defined in ‘integer-gmp:GHC.Integer.Type’
  instance Eq a => Eq (Control.Applicative.ZipList a)
    -- Defined in ‘Control.Applicative’
  instance (GHC.Arr.Ix ix, Eq e, Data.Array.Base.IArray UArray e) =>
           Eq (UArray ix e)
    -- Defined in ‘Data.Array.Base’
  instance Eq (Data.Array.Base.STUArray s i e)
    -- Defined in ‘Data.Array.Base’
  instance Eq (GHC.Arr.STArray s i e) -- Defined in ‘GHC.Arr’
  instance (GHC.Arr.Ix i, Eq e) => Eq (Array i e)
    -- Defined in ‘GHC.Arr’
  instance Eq a => Eq (GHC.Real.Ratio a) -- Defined in ‘GHC.Real’
  instance Floating Float -- Defined in ‘GHC.Float’
  instance Floating Double -- Defined in ‘GHC.Float’
  instance Integral a => Fractional (GHC.Real.Ratio a)
    -- Defined in ‘GHC.Real’
  instance Fractional Float -- Defined in ‘GHC.Float’
  instance Fractional Double -- Defined in ‘GHC.Float’
  instance Integral GHC.Int.Int8 -- Defined in ‘GHC.Int’
  instance Integral GHC.Int.Int64 -- Defined in ‘GHC.Int’
  instance Integral GHC.Int.Int32 -- Defined in ‘GHC.Int’
  instance Integral GHC.Int.Int16 -- Defined in ‘GHC.Int’
  instance Integral GHC.Word.Word8 -- Defined in ‘GHC.Word’
  instance Integral GHC.Word.Word64 -- Defined in ‘GHC.Word’
  instance Integral GHC.Word.Word32 -- Defined in ‘GHC.Word’
  instance Integral GHC.Word.Word16 -- Defined in ‘GHC.Word’
  instance Integral GHC.Types.Word -- Defined in ‘GHC.Real’
  instance Integral Integer -- Defined in ‘GHC.Real’
  instance Integral Int -- Defined in ‘GHC.Real’
  instance Monad (base:Control.Monad.ST.Lazy.Imp.ST s)
    -- Defined in ‘base:Control.Monad.ST.Lazy.Imp’
  instance Monad (GHC.ST.ST s) -- Defined in ‘GHC.ST’
  instance Monad m => Monad (Control.Applicative.WrappedMonad m)
    -- Defined in ‘Control.Applicative’
  instance Monad [] -- Defined in ‘GHC.Base’
  instance Monad IO -- Defined in ‘GHC.Base’
  instance Monad ((->) r) -- Defined in ‘GHC.Base’
  instance Functor (base:Control.Monad.ST.Lazy.Imp.ST s)
    -- Defined in ‘base:Control.Monad.ST.Lazy.Imp’
  instance Functor (GHC.ST.ST s) -- Defined in ‘GHC.ST’
  instance Functor Control.Applicative.ZipList
    -- Defined in ‘Control.Applicative’
  instance Monad m => Functor (Control.Applicative.WrappedMonad m)
    -- Defined in ‘Control.Applicative’
  instance Control.Arrow.Arrow a =>
           Functor (Control.Applicative.WrappedArrow a b)
    -- Defined in ‘Control.Applicative’
  instance Functor (Control.Applicative.Const m)
    -- Defined in ‘Control.Applicative’
  instance Functor [] -- Defined in ‘GHC.Base’
  instance Functor IO -- Defined in ‘GHC.Base’
  instance Functor ((->) r) -- Defined in ‘GHC.Base’
  instance Functor ((,) a) -- Defined in ‘GHC.Base’
  instance GHC.Arr.Ix i => Functor (Array i) -- Defined in ‘GHC.Arr’
  instance Num GHC.Int.Int8 -- Defined in ‘GHC.Int’
  instance Num GHC.Int.Int64 -- Defined in ‘GHC.Int’
  instance Num GHC.Int.Int32 -- Defined in ‘GHC.Int’
  instance Num GHC.Int.Int16 -- Defined in ‘GHC.Int’
  instance Num GHC.Word.Word8 -- Defined in ‘GHC.Word’
  instance Num GHC.Word.Word64 -- Defined in ‘GHC.Word’
  instance Num GHC.Word.Word32 -- Defined in ‘GHC.Word’
  instance Num GHC.Word.Word16 -- Defined in ‘GHC.Word’
  instance Num GHC.Types.Word -- Defined in ‘GHC.Num’
  instance Num Integer -- Defined in ‘GHC.Num’
  instance Num Int -- Defined in ‘GHC.Num’
  instance Integral a => Num (GHC.Real.Ratio a)
    -- Defined in ‘GHC.Real’
  instance Num Float -- Defined in ‘GHC.Float’
  instance Num Double -- Defined in ‘GHC.Float’
  instance Ord GHC.Int.Int8 -- Defined in ‘GHC.Int’
  instance Ord GHC.Int.Int64 -- Defined in ‘GHC.Int’
  instance Ord GHC.Int.Int32 -- Defined in ‘GHC.Int’
  instance Ord GHC.Int.Int16 -- Defined in ‘GHC.Int’
  instance Ord (GHC.Ptr.Ptr a) -- Defined in ‘GHC.Ptr’
  instance Ord (GHC.Ptr.FunPtr a) -- Defined in ‘GHC.Ptr’
  instance Ord GHC.Word.Word8 -- Defined in ‘GHC.Word’
  instance Ord GHC.Word.Word64 -- Defined in ‘GHC.Word’
  instance Ord GHC.Word.Word32 -- Defined in ‘GHC.Word’
  instance Ord GHC.Word.Word16 -- Defined in ‘GHC.Word’
  instance Ord Integer -- Defined in ‘integer-gmp:GHC.Integer.Type’
  instance Ord a => Ord (Control.Applicative.ZipList a)
    -- Defined in ‘Control.Applicative’
  instance (GHC.Arr.Ix ix, Ord e, Data.Array.Base.IArray UArray e) =>
           Ord (UArray ix e)
    -- Defined in ‘Data.Array.Base’
  instance (GHC.Arr.Ix i, Ord e) => Ord (Array i e)
    -- Defined in ‘GHC.Arr’
  instance Integral a => Ord (GHC.Real.Ratio a)
    -- Defined in ‘GHC.Real’
  instance Read GHC.Int.Int8 -- Defined in ‘GHC.Int’
  instance Read GHC.Int.Int64 -- Defined in ‘GHC.Int’
  instance Read GHC.Int.Int32 -- Defined in ‘GHC.Int’
  instance Read GHC.Int.Int16 -- Defined in ‘GHC.Int’
  instance Read GHC.Word.Word8 -- Defined in ‘GHC.Word’
  instance Read GHC.Word.Word64 -- Defined in ‘GHC.Word’
  instance Read GHC.Word.Word32 -- Defined in ‘GHC.Word’
  instance Read GHC.Word.Word16 -- Defined in ‘GHC.Word’
  instance Read a => Read (Control.Applicative.ZipList a)
    -- Defined in ‘Control.Applicative’
  instance Real GHC.Int.Int8 -- Defined in ‘GHC.Int’
  instance Real GHC.Int.Int64 -- Defined in ‘GHC.Int’
  instance Real GHC.Int.Int32 -- Defined in ‘GHC.Int’
  instance Real GHC.Int.Int16 -- Defined in ‘GHC.Int’
  instance Real GHC.Word.Word8 -- Defined in ‘GHC.Word’
  instance Real GHC.Word.Word64 -- Defined in ‘GHC.Word’
  instance Real GHC.Word.Word32 -- Defined in ‘GHC.Word’
  instance Real GHC.Word.Word16 -- Defined in ‘GHC.Word’
  instance Real GHC.Types.Word -- Defined in ‘GHC.Real’
  instance Integral a => Real (GHC.Real.Ratio a)
    -- Defined in ‘GHC.Real’
  instance Real Integer -- Defined in ‘GHC.Real’
  instance Real Int -- Defined in ‘GHC.Real’
  instance Real Float -- Defined in ‘GHC.Float’
  instance Real Double -- Defined in ‘GHC.Float’
  instance RealFloat Float -- Defined in ‘GHC.Float’
  instance RealFloat Double -- Defined in ‘GHC.Float’
  instance Integral a => RealFrac (GHC.Real.Ratio a)
    -- Defined in ‘GHC.Real’
  instance RealFrac Float -- Defined in ‘GHC.Float’
  instance RealFrac Double -- Defined in ‘GHC.Float’
  instance Show GHC.Int.Int8 -- Defined in ‘GHC.Int’
  instance Show GHC.Int.Int64 -- Defined in ‘GHC.Int’
  instance Show GHC.Int.Int32 -- Defined in ‘GHC.Int’
  instance Show GHC.Int.Int16 -- Defined in ‘GHC.Int’
  instance Show (GHC.Ptr.Ptr a) -- Defined in ‘GHC.Ptr’
  instance Show (GHC.Ptr.FunPtr a) -- Defined in ‘GHC.Ptr’
  instance Show GHC.Word.Word8 -- Defined in ‘GHC.Word’
  instance Show GHC.Word.Word64 -- Defined in ‘GHC.Word’
  instance Show GHC.Word.Word32 -- Defined in ‘GHC.Word’
  instance Show GHC.Word.Word16 -- Defined in ‘GHC.Word’
  instance Show (GHC.ST.ST s a) -- Defined in ‘GHC.ST’
  instance Show a => Show (Control.Applicative.ZipList a)
    -- Defined in ‘Control.Applicative’
  instance (GHC.Arr.Ix ix, Show ix, Show e,
            Data.Array.Base.IArray UArray e) =>
           Show (UArray ix e)
    -- Defined in ‘Data.Array.Base’
  instance (GHC.Arr.Ix a, Show a, Show b) => Show (Array a b)
    -- Defined in ‘GHC.Arr’
  instance (Integral a, Show a) => Show (GHC.Real.Ratio a)
    -- Defined in ‘GHC.Real’
  instance Show Float -- Defined in ‘GHC.Float’
  instance Show Double -- Defined in ‘GHC.Float’
  instance GHC.Arr.Ix GHC.Int.Int8 -- Defined in ‘GHC.Int’
  instance GHC.Arr.Ix GHC.Int.Int64 -- Defined in ‘GHC.Int’
  instance GHC.Arr.Ix GHC.Int.Int32 -- Defined in ‘GHC.Int’
  instance GHC.Arr.Ix GHC.Int.Int16 -- Defined in ‘GHC.Int’
  instance GHC.Arr.Ix GHC.Word.Word8 -- Defined in ‘GHC.Word’
  instance GHC.Arr.Ix GHC.Word.Word64 -- Defined in ‘GHC.Word’
  instance GHC.Arr.Ix GHC.Word.Word32 -- Defined in ‘GHC.Word’
  instance GHC.Arr.Ix GHC.Word.Word16 -- Defined in ‘GHC.Word’
  instance GHC.Arr.Ix GHC.Types.Word -- Defined in ‘GHC.Arr’
  instance GHC.Arr.Ix Ordering -- Defined in ‘GHC.Arr’
  instance GHC.Arr.Ix Integer -- Defined in ‘GHC.Arr’
  instance GHC.Arr.Ix Int -- Defined in ‘GHC.Arr’
  instance GHC.Arr.Ix Char -- Defined in ‘GHC.Arr’
  instance GHC.Arr.Ix Bool -- Defined in ‘GHC.Arr’
  instance (GHC.Arr.Ix a1, GHC.Arr.Ix a2, GHC.Arr.Ix a3,
            GHC.Arr.Ix a4, GHC.Arr.Ix a5) =>
           GHC.Arr.Ix (a1, a2, a3, a4, a5)
    -- Defined in ‘GHC.Arr’
  instance (GHC.Arr.Ix a1, GHC.Arr.Ix a2, GHC.Arr.Ix a3,
            GHC.Arr.Ix a4) =>
           GHC.Arr.Ix (a1, a2, a3, a4)
    -- Defined in ‘GHC.Arr’
  instance (GHC.Arr.Ix a1, GHC.Arr.Ix a2, GHC.Arr.Ix a3) =>
           GHC.Arr.Ix (a1, a2, a3)
    -- Defined in ‘GHC.Arr’
  instance (GHC.Arr.Ix a, GHC.Arr.Ix b) => GHC.Arr.Ix (a, b)
    -- Defined in ‘GHC.Arr’
  instance GHC.Arr.Ix () -- Defined in ‘GHC.Arr’
  instance Data.Typeable.Internal.Typeable GHC.IOArray.IOArray
    -- Defined in ‘GHC.IOArray’
  instance Data.Typeable.Internal.Typeable GHC.Int.Int8
    -- Defined in ‘GHC.Int’
  instance Data.Typeable.Internal.Typeable GHC.Int.Int64
    -- Defined in ‘GHC.Int’
  instance Data.Typeable.Internal.Typeable GHC.Int.Int32
    -- Defined in ‘GHC.Int’
  instance Data.Typeable.Internal.Typeable GHC.Int.Int16
    -- Defined in ‘GHC.Int’
  instance Data.Typeable.Internal.Typeable GHC.Stable.StablePtr
    -- Defined in ‘GHC.Stable’
  instance Data.Typeable.Internal.Typeable
             Control.Applicative.Applicative
    -- Defined in ‘Control.Applicative’
  instance Data.Typeable.Internal.Typeable
             Control.Applicative.Alternative
    -- Defined in ‘Control.Applicative’
  instance Data.Typeable.Internal.Typeable UArray
    -- Defined in ‘Data.Array.Base’
  instance Data.Typeable.Internal.Typeable Data.Array.Base.STUArray
    -- Defined in ‘Data.Array.Base’
  instance Control.Monad.Fix.MonadFix
             (base:Control.Monad.ST.Lazy.Imp.ST s)
    -- Defined in ‘base:Control.Monad.ST.Lazy.Imp’
  instance Control.Monad.MonadPlus [] -- Defined in ‘Control.Monad’
  instance Control.Monad.MonadPlus Maybe
    -- Defined in ‘Control.Monad’
  instance Control.Applicative.Applicative []
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative
             Control.Applicative.ZipList
    -- Defined in ‘Control.Applicative’
  instance Monad m =>
           Control.Applicative.Applicative
             (Control.Applicative.WrappedMonad m)
    -- Defined in ‘Control.Applicative’
  instance Control.Arrow.Arrow a =>
           Control.Applicative.Applicative
             (Control.Applicative.WrappedArrow a b)
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative GHC.Conc.Sync.STM
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative (GHC.ST.ST s)
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative
             (base:Control.Monad.ST.Lazy.Imp.ST s)
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative
             Text.ParserCombinators.ReadPrec.ReadPrec
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative
             Text.ParserCombinators.ReadP.ReadP
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative Data.Proxy.Proxy
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative Maybe
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative IO
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative (Either e)
    -- Defined in ‘Control.Applicative’
  instance Data.Monoid.Monoid m =>
           Control.Applicative.Applicative (Control.Applicative.Const m)
    -- Defined in ‘Control.Applicative’
  instance Control.Arrow.Arrow a =>
           Control.Applicative.Applicative (Control.Arrow.ArrowMonad a)
    -- Defined in ‘Control.Applicative’
  instance Control.Applicative.Applicative ((->) a)
    -- Defined in ‘Control.Applicative’
  instance Data.Monoid.Monoid a =>
           Control.Applicative.Applicative ((,) a)
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Generic (Control.Applicative.ZipList a)
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Generic
             (Control.Applicative.WrappedMonad m a)
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Generic
             (Control.Applicative.WrappedArrow a b c)
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Generic (Control.Applicative.Const a b)
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Generic1 Control.Applicative.ZipList
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Generic1 (Control.Applicative.WrappedMonad m)
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Generic1
             (Control.Applicative.WrappedArrow a b)
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Generic1 (Control.Applicative.Const a)
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Datatype Control.Applicative.D1ZipList
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Datatype Control.Applicative.D1WrappedMonad
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Datatype Control.Applicative.D1WrappedArrow
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Datatype Control.Applicative.D1Const
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Constructor Control.Applicative.C1_0ZipList
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Constructor
             Control.Applicative.C1_0WrappedMonad
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Constructor
             Control.Applicative.C1_0WrappedArrow
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Constructor Control.Applicative.C1_0Const
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Selector Control.Applicative.S1_0_0ZipList
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Selector
             Control.Applicative.S1_0_0WrappedMonad
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Selector
             Control.Applicative.S1_0_0WrappedArrow
    -- Defined in ‘Control.Applicative’
  instance GHC.Generics.Selector Control.Applicative.S1_0_0Const
    -- Defined in ‘Control.Applicative’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) GHC.Types.Word (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) GHC.Word.Word8 (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) GHC.Word.Word64 (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) GHC.Word.Word32 (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) GHC.Word.Word16 (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) (GHC.Stable.StablePtr a) (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) (GHC.Ptr.Ptr a) (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) Int (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) GHC.Int.Int8 (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) GHC.Int.Int64 (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) GHC.Int.Int32 (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) GHC.Int.Int16 (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) (GHC.Ptr.FunPtr a) (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) Float (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) Double (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) Char (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (Data.Array.Base.STUArray s) Bool (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray (GHC.Arr.STArray s) e (GHC.ST.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray
             (GHC.Arr.STArray s) e (base:Control.Monad.ST.Lazy.Imp.ST s)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.MArray GHC.IOArray.IOArray e IO
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray GHC.Word.Word8
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray GHC.Word.Word64
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray GHC.Word.Word32
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray GHC.Word.Word16
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray GHC.Types.Word
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray (GHC.Stable.StablePtr a)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray (GHC.Ptr.Ptr a)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray GHC.Int.Int8
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray GHC.Int.Int64
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray GHC.Int.Int32
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray GHC.Int.Int16
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray Int
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray (GHC.Ptr.FunPtr a)
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray Float
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray Double
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray Char
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray UArray Bool
    -- Defined in ‘Data.Array.Base’
  instance Data.Array.Base.IArray Array e
    -- Defined in ‘Data.Array.Base’
  instance Data.Monoid.Monoid a =>
           Data.Monoid.Monoid (Control.Applicative.Const a b)
    -- Defined in ‘Control.Applicative’
  instance Data.Bits.FiniteBits GHC.Int.Int8 -- Defined in ‘GHC.Int’
  instance Data.Bits.FiniteBits GHC.Int.Int64 -- Defined in ‘GHC.Int’
  instance Data.Bits.FiniteBits GHC.Int.Int32 -- Defined in ‘GHC.Int’
  instance Data.Bits.FiniteBits GHC.Int.Int16 -- Defined in ‘GHC.Int’
  instance Data.Bits.FiniteBits GHC.Word.Word8
    -- Defined in ‘GHC.Word’
  instance Data.Bits.FiniteBits GHC.Word.Word64
    -- Defined in ‘GHC.Word’
  instance Data.Bits.FiniteBits GHC.Word.Word32
    -- Defined in ‘GHC.Word’
  instance Data.Bits.FiniteBits GHC.Word.Word16
    -- Defined in ‘GHC.Word’
  instance Data.Bits.Bits GHC.Int.Int8 -- Defined in ‘GHC.Int’
  instance Data.Bits.Bits GHC.Int.Int64 -- Defined in ‘GHC.Int’
  instance Data.Bits.Bits GHC.Int.Int32 -- Defined in ‘GHC.Int’
  instance Data.Bits.Bits GHC.Int.Int16 -- Defined in ‘GHC.Int’
  instance Data.Bits.Bits GHC.Word.Word8 -- Defined in ‘GHC.Word’
  instance Data.Bits.Bits GHC.Word.Word64 -- Defined in ‘GHC.Word’
  instance Data.Bits.Bits GHC.Word.Word32 -- Defined in ‘GHC.Word’
  instance Data.Bits.Bits GHC.Word.Word16 -- Defined in ‘GHC.Word’
End InstEnvs }
InstEnvs (Internal) {
End InstEnvs }
famInstEnvs (External) {
  type GHC.Generics.Rep Char
    ~ GHC.Generics.D1
        GHC.Generics.D_Char
        (GHC.Generics.C1
           GHC.Generics.C_Char
           (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 Char)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep Double
    ~ GHC.Generics.D1
        GHC.Generics.D_Double
        (GHC.Generics.C1
           GHC.Generics.C_Double
           (GHC.Generics.S1
              GHC.Generics.NoSelector (GHC.Generics.Rec0 Double)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep Float
    ~ GHC.Generics.D1
        GHC.Generics.D_Float
        (GHC.Generics.C1
           GHC.Generics.C_Float
           (GHC.Generics.S1
              GHC.Generics.NoSelector (GHC.Generics.Rec0 Float)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep Int
    ~ GHC.Generics.D1
        GHC.Generics.D_Int
        (GHC.Generics.C1
           GHC.Generics.C_Int
           (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 Int)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (Data.Proxy.Proxy t)
    ~ GHC.Generics.D1
        GHC.Generics.D1Proxy
        (GHC.Generics.C1 GHC.Generics.C1_0Proxy GHC.Generics.U1)
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (a, b, c, d, e, f, g)
    ~ GHC.Generics.D1
        GHC.Generics.D1(,,,,,,)
        (GHC.Generics.C1
           GHC.Generics.C1_0(,,,,,,)
           ((GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
             GHC.Generics.:*: (GHC.Generics.S1
                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 b)
                               GHC.Generics.:*: GHC.Generics.S1
                                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 c)))
            GHC.Generics.:*: ((GHC.Generics.S1
                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 d)
                               GHC.Generics.:*: GHC.Generics.S1
                                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 e))
                              GHC.Generics.:*: (GHC.Generics.S1
                                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 f)
                                                GHC.Generics.:*: GHC.Generics.S1
                                                                   GHC.Generics.NoSelector
                                                                   (GHC.Generics.Rec0 g)))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (a, b, c, d, e, f)
    ~ GHC.Generics.D1
        GHC.Generics.D1(,,,,,)
        (GHC.Generics.C1
           GHC.Generics.C1_0(,,,,,)
           ((GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
             GHC.Generics.:*: (GHC.Generics.S1
                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 b)
                               GHC.Generics.:*: GHC.Generics.S1
                                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 c)))
            GHC.Generics.:*: (GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 d)
                              GHC.Generics.:*: (GHC.Generics.S1
                                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 e)
                                                GHC.Generics.:*: GHC.Generics.S1
                                                                   GHC.Generics.NoSelector
                                                                   (GHC.Generics.Rec0 f)))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (a, b, c, d, e)
    ~ GHC.Generics.D1
        GHC.Generics.D1(,,,,)
        (GHC.Generics.C1
           GHC.Generics.C1_0(,,,,)
           ((GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
             GHC.Generics.:*: GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 b))
            GHC.Generics.:*: (GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 c)
                              GHC.Generics.:*: (GHC.Generics.S1
                                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 d)
                                                GHC.Generics.:*: GHC.Generics.S1
                                                                   GHC.Generics.NoSelector
                                                                   (GHC.Generics.Rec0 e)))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (a, b, c, d)
    ~ GHC.Generics.D1
        GHC.Generics.D1(,,,)
        (GHC.Generics.C1
           GHC.Generics.C1_0(,,,)
           ((GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
             GHC.Generics.:*: GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 b))
            GHC.Generics.:*: (GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 c)
                              GHC.Generics.:*: GHC.Generics.S1
                                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 d))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (a, b, c)
    ~ GHC.Generics.D1
        GHC.Generics.D1(,,)
        (GHC.Generics.C1
           GHC.Generics.C1_0(,,)
           (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
            GHC.Generics.:*: (GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 b)
                              GHC.Generics.:*: GHC.Generics.S1
                                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 c))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (a, b)
    ~ GHC.Generics.D1
        GHC.Generics.D1(,)
        (GHC.Generics.C1
           GHC.Generics.C1_0(,)
           (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
            GHC.Generics.:*: GHC.Generics.S1
                               GHC.Generics.NoSelector (GHC.Generics.Rec0 b)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep ()
    ~ GHC.Generics.D1
        GHC.Generics.D1()
        (GHC.Generics.C1 GHC.Generics.C1_0() GHC.Generics.U1)
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep Ordering
    ~ GHC.Generics.D1
        GHC.Generics.D1Ordering
        (GHC.Generics.C1 GHC.Generics.C1_0Ordering GHC.Generics.U1
         GHC.Generics.:+: (GHC.Generics.C1
                             GHC.Generics.C1_1Ordering GHC.Generics.U1
                           GHC.Generics.:+: GHC.Generics.C1
                                              GHC.Generics.C1_2Ordering GHC.Generics.U1))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep Bool
    ~ GHC.Generics.D1
        GHC.Generics.D1Bool
        (GHC.Generics.C1 GHC.Generics.C1_0Bool GHC.Generics.U1
         GHC.Generics.:+: GHC.Generics.C1
                            GHC.Generics.C1_1Bool GHC.Generics.U1)
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (Either a b)
    ~ GHC.Generics.D1
        GHC.Generics.D1Either
        (GHC.Generics.C1
           GHC.Generics.C1_0Either
           (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a))
         GHC.Generics.:+: GHC.Generics.C1
                            GHC.Generics.C1_1Either
                            (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 b)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (Maybe a)
    ~ GHC.Generics.D1
        GHC.Generics.D1Maybe
        (GHC.Generics.C1 GHC.Generics.C1_0Maybe GHC.Generics.U1
         GHC.Generics.:+: GHC.Generics.C1
                            GHC.Generics.C1_1Maybe
                            (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep [a]
    ~ GHC.Generics.D1
        GHC.Generics.D1[]
        (GHC.Generics.C1 GHC.Generics.C1_0[] GHC.Generics.U1
         GHC.Generics.:+: GHC.Generics.C1
                            GHC.Generics.C1_1[]
                            (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
                             GHC.Generics.:*: GHC.Generics.S1
                                                GHC.Generics.NoSelector (GHC.Generics.Rec0 [a])))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (GHC.Generics.U1 p)
    ~ GHC.Generics.D1
        GHC.Generics.D1U1
        (GHC.Generics.C1 GHC.Generics.C1_0U1 GHC.Generics.U1)
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (GHC.Generics.Par1 p)
    ~ GHC.Generics.D1
        GHC.Generics.D1Par1
        (GHC.Generics.C1
           GHC.Generics.C1_0Par1
           (GHC.Generics.S1 GHC.Generics.S1_0_0Par1 (GHC.Generics.Rec0 p)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (GHC.Generics.Rec1 f p)
    ~ GHC.Generics.D1
        GHC.Generics.D1Rec1
        (GHC.Generics.C1
           GHC.Generics.C1_0Rec1
           (GHC.Generics.S1
              GHC.Generics.S1_0_0Rec1 (GHC.Generics.Rec0 (f p))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (GHC.Generics.K1 i c p)
    ~ GHC.Generics.D1
        GHC.Generics.D1K1
        (GHC.Generics.C1
           GHC.Generics.C1_0K1
           (GHC.Generics.S1 GHC.Generics.S1_0_0K1 (GHC.Generics.Rec0 c)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (GHC.Generics.M1 i c f p)
    ~ GHC.Generics.D1
        GHC.Generics.D1M1
        (GHC.Generics.C1
           GHC.Generics.C1_0M1
           (GHC.Generics.S1 GHC.Generics.S1_0_0M1 (GHC.Generics.Rec0 (f p))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep ((GHC.Generics.:+:) f g p)
    ~ GHC.Generics.D1
        GHC.Generics.D1:+:
        (GHC.Generics.C1
           GHC.Generics.C1_0:+:
           (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 (f p)))
         GHC.Generics.:+: GHC.Generics.C1
                            GHC.Generics.C1_1:+:
                            (GHC.Generics.S1
                               GHC.Generics.NoSelector (GHC.Generics.Rec0 (g p))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep ((GHC.Generics.:*:) f g p)
    ~ GHC.Generics.D1
        GHC.Generics.D1:*:
        (GHC.Generics.C1
           GHC.Generics.C1_0:*:
           (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 (f p))
            GHC.Generics.:*: GHC.Generics.S1
                               GHC.Generics.NoSelector (GHC.Generics.Rec0 (g p))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep ((GHC.Generics.:.:) f g p)
    ~ GHC.Generics.D1
        GHC.Generics.D1:.:
        (GHC.Generics.C1
           GHC.Generics.C1_0:.:
           (GHC.Generics.S1
              GHC.Generics.S1_0_0:.: (GHC.Generics.Rec0 (f (g p)))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep GHC.Generics.Associativity
    ~ GHC.Generics.D1
        GHC.Generics.D1Associativity
        (GHC.Generics.C1 GHC.Generics.C1_0Associativity GHC.Generics.U1
         GHC.Generics.:+: (GHC.Generics.C1
                             GHC.Generics.C1_1Associativity GHC.Generics.U1
                           GHC.Generics.:+: GHC.Generics.C1
                                              GHC.Generics.C1_2Associativity GHC.Generics.U1))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep GHC.Generics.Fixity
    ~ GHC.Generics.D1
        GHC.Generics.D1Fixity
        (GHC.Generics.C1 GHC.Generics.C1_0Fixity GHC.Generics.U1
         GHC.Generics.:+: GHC.Generics.C1
                            GHC.Generics.C1_1Fixity
                            (GHC.Generics.S1
                               GHC.Generics.NoSelector
                               (GHC.Generics.Rec0 GHC.Generics.Associativity)
                             GHC.Generics.:*: GHC.Generics.S1
                                                GHC.Generics.NoSelector (GHC.Generics.Rec0 Int)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep GHC.Generics.Arity
    ~ GHC.Generics.D1
        GHC.Generics.D1Arity
        (GHC.Generics.C1 GHC.Generics.C1_0Arity GHC.Generics.U1
         GHC.Generics.:+: GHC.Generics.C1
                            GHC.Generics.C1_1Arity
                            (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 Int)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep (Data.Monoid.Dual a)
    ~ GHC.Generics.D1
        Data.Monoid.D1Dual
        (GHC.Generics.C1
           Data.Monoid.C1_0Dual
           (GHC.Generics.S1 Data.Monoid.S1_0_0Dual (GHC.Generics.Rec0 a)))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep (Data.Monoid.Endo a)
    ~ GHC.Generics.D1
        Data.Monoid.D1Endo
        (GHC.Generics.C1
           Data.Monoid.C1_0Endo
           (GHC.Generics.S1
              Data.Monoid.S1_0_0Endo (GHC.Generics.Rec0 (a -> a))))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep Data.Monoid.All
    ~ GHC.Generics.D1
        Data.Monoid.D1All
        (GHC.Generics.C1
           Data.Monoid.C1_0All
           (GHC.Generics.S1 Data.Monoid.S1_0_0All (GHC.Generics.Rec0 Bool)))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep Data.Monoid.Any
    ~ GHC.Generics.D1
        Data.Monoid.D1Any
        (GHC.Generics.C1
           Data.Monoid.C1_0Any
           (GHC.Generics.S1 Data.Monoid.S1_0_0Any (GHC.Generics.Rec0 Bool)))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep (Data.Monoid.Sum a)
    ~ GHC.Generics.D1
        Data.Monoid.D1Sum
        (GHC.Generics.C1
           Data.Monoid.C1_0Sum
           (GHC.Generics.S1 Data.Monoid.S1_0_0Sum (GHC.Generics.Rec0 a)))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep (Data.Monoid.Product a)
    ~ GHC.Generics.D1
        Data.Monoid.D1Product
        (GHC.Generics.C1
           Data.Monoid.C1_0Product
           (GHC.Generics.S1 Data.Monoid.S1_0_0Product (GHC.Generics.Rec0 a)))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep (Data.Monoid.First a)
    ~ GHC.Generics.D1
        Data.Monoid.D1First
        (GHC.Generics.C1
           Data.Monoid.C1_0First
           (GHC.Generics.S1
              Data.Monoid.S1_0_0First (GHC.Generics.Rec0 (Maybe a))))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep (Data.Monoid.Last a)
    ~ GHC.Generics.D1
        Data.Monoid.D1Last
        (GHC.Generics.C1
           Data.Monoid.C1_0Last
           (GHC.Generics.S1
              Data.Monoid.S1_0_0Last (GHC.Generics.Rec0 (Maybe a))))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep (Control.Applicative.Const a b)
    ~ GHC.Generics.D1
        Control.Applicative.D1Const
        (GHC.Generics.C1
           Control.Applicative.C1_0Const
           (GHC.Generics.S1
              Control.Applicative.S1_0_0Const (GHC.Generics.Rec0 a)))
    -- Defined in ‘Control.Applicative’
  type GHC.Generics.Rep (Control.Applicative.WrappedMonad m a)
    ~ GHC.Generics.D1
        Control.Applicative.D1WrappedMonad
        (GHC.Generics.C1
           Control.Applicative.C1_0WrappedMonad
           (GHC.Generics.S1
              Control.Applicative.S1_0_0WrappedMonad (GHC.Generics.Rec0 (m a))))
    -- Defined in ‘Control.Applicative’
  type GHC.Generics.Rep (Control.Applicative.WrappedArrow a b c)
    ~ GHC.Generics.D1
        Control.Applicative.D1WrappedArrow
        (GHC.Generics.C1
           Control.Applicative.C1_0WrappedArrow
           (GHC.Generics.S1
              Control.Applicative.S1_0_0WrappedArrow
              (GHC.Generics.Rec0 (a b c))))
    -- Defined in ‘Control.Applicative’
  type GHC.Generics.Rep (Control.Applicative.ZipList a)
    ~ GHC.Generics.D1
        Control.Applicative.D1ZipList
        (GHC.Generics.C1
           Control.Applicative.C1_0ZipList
           (GHC.Generics.S1
              Control.Applicative.S1_0_0ZipList (GHC.Generics.Rec0 [a])))
    -- Defined in ‘Control.Applicative’
  type GHC.Generics.Rep1 ((,,,,,,) a b c d e f)
    ~ GHC.Generics.D1
        GHC.Generics.D1(,,,,,,)
        (GHC.Generics.C1
           GHC.Generics.C1_0(,,,,,,)
           ((GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
             GHC.Generics.:*: (GHC.Generics.S1
                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 b)
                               GHC.Generics.:*: GHC.Generics.S1
                                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 c)))
            GHC.Generics.:*: ((GHC.Generics.S1
                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 d)
                               GHC.Generics.:*: GHC.Generics.S1
                                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 e))
                              GHC.Generics.:*: (GHC.Generics.S1
                                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 f)
                                                GHC.Generics.:*: GHC.Generics.S1
                                                                   GHC.Generics.NoSelector
                                                                   GHC.Generics.Par1))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 ((,,,,,) a b c d e)
    ~ GHC.Generics.D1
        GHC.Generics.D1(,,,,,)
        (GHC.Generics.C1
           GHC.Generics.C1_0(,,,,,)
           ((GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
             GHC.Generics.:*: (GHC.Generics.S1
                                 GHC.Generics.NoSelector (GHC.Generics.Rec0 b)
                               GHC.Generics.:*: GHC.Generics.S1
                                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 c)))
            GHC.Generics.:*: (GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 d)
                              GHC.Generics.:*: (GHC.Generics.S1
                                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 e)
                                                GHC.Generics.:*: GHC.Generics.S1
                                                                   GHC.Generics.NoSelector
                                                                   GHC.Generics.Par1))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 ((,,,,) a b c d)
    ~ GHC.Generics.D1
        GHC.Generics.D1(,,,,)
        (GHC.Generics.C1
           GHC.Generics.C1_0(,,,,)
           ((GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
             GHC.Generics.:*: GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 b))
            GHC.Generics.:*: (GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 c)
                              GHC.Generics.:*: (GHC.Generics.S1
                                                  GHC.Generics.NoSelector (GHC.Generics.Rec0 d)
                                                GHC.Generics.:*: GHC.Generics.S1
                                                                   GHC.Generics.NoSelector
                                                                   GHC.Generics.Par1))))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 ((,,,) a b c)
    ~ GHC.Generics.D1
        GHC.Generics.D1(,,,)
        (GHC.Generics.C1
           GHC.Generics.C1_0(,,,)
           ((GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
             GHC.Generics.:*: GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 b))
            GHC.Generics.:*: (GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 c)
                              GHC.Generics.:*: GHC.Generics.S1
                                                 GHC.Generics.NoSelector GHC.Generics.Par1)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 ((,,) a b)
    ~ GHC.Generics.D1
        GHC.Generics.D1(,,)
        (GHC.Generics.C1
           GHC.Generics.C1_0(,,)
           (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
            GHC.Generics.:*: (GHC.Generics.S1
                                GHC.Generics.NoSelector (GHC.Generics.Rec0 b)
                              GHC.Generics.:*: GHC.Generics.S1
                                                 GHC.Generics.NoSelector GHC.Generics.Par1)))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 ((,) a)
    ~ GHC.Generics.D1
        GHC.Generics.D1(,)
        (GHC.Generics.C1
           GHC.Generics.C1_0(,)
           (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a)
            GHC.Generics.:*: GHC.Generics.S1
                               GHC.Generics.NoSelector GHC.Generics.Par1))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 (Either a)
    ~ GHC.Generics.D1
        GHC.Generics.D1Either
        (GHC.Generics.C1
           GHC.Generics.C1_0Either
           (GHC.Generics.S1 GHC.Generics.NoSelector (GHC.Generics.Rec0 a))
         GHC.Generics.:+: GHC.Generics.C1
                            GHC.Generics.C1_1Either
                            (GHC.Generics.S1 GHC.Generics.NoSelector GHC.Generics.Par1))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 Maybe
    ~ GHC.Generics.D1
        GHC.Generics.D1Maybe
        (GHC.Generics.C1 GHC.Generics.C1_0Maybe GHC.Generics.U1
         GHC.Generics.:+: GHC.Generics.C1
                            GHC.Generics.C1_1Maybe
                            (GHC.Generics.S1 GHC.Generics.NoSelector GHC.Generics.Par1))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 []
    ~ GHC.Generics.D1
        GHC.Generics.D1[]
        (GHC.Generics.C1 GHC.Generics.C1_0[] GHC.Generics.U1
         GHC.Generics.:+: GHC.Generics.C1
                            GHC.Generics.C1_1[]
                            (GHC.Generics.S1 GHC.Generics.NoSelector GHC.Generics.Par1
                             GHC.Generics.:*: GHC.Generics.S1
                                                GHC.Generics.NoSelector (GHC.Generics.Rec1 [])))
    -- Defined in ‘GHC.Generics’
  type GHC.Generics.Rep1 Data.Monoid.Dual
    ~ GHC.Generics.D1
        Data.Monoid.D1Dual
        (GHC.Generics.C1
           Data.Monoid.C1_0Dual
           (GHC.Generics.S1 Data.Monoid.S1_0_0Dual GHC.Generics.Par1))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep1 Data.Monoid.Sum
    ~ GHC.Generics.D1
        Data.Monoid.D1Sum
        (GHC.Generics.C1
           Data.Monoid.C1_0Sum
           (GHC.Generics.S1 Data.Monoid.S1_0_0Sum GHC.Generics.Par1))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep1 Data.Monoid.Product
    ~ GHC.Generics.D1
        Data.Monoid.D1Product
        (GHC.Generics.C1
           Data.Monoid.C1_0Product
           (GHC.Generics.S1 Data.Monoid.S1_0_0Product GHC.Generics.Par1))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep1 Data.Monoid.First
    ~ GHC.Generics.D1
        Data.Monoid.D1First
        (GHC.Generics.C1
           Data.Monoid.C1_0First
           (GHC.Generics.S1
              Data.Monoid.S1_0_0First (GHC.Generics.Rec1 Maybe)))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep1 Data.Monoid.Last
    ~ GHC.Generics.D1
        Data.Monoid.D1Last
        (GHC.Generics.C1
           Data.Monoid.C1_0Last
           (GHC.Generics.S1 Data.Monoid.S1_0_0Last (GHC.Generics.Rec1 Maybe)))
    -- Defined in ‘Data.Monoid’
  type GHC.Generics.Rep1 (Control.Applicative.Const a)
    ~ GHC.Generics.D1
        Control.Applicative.D1Const
        (GHC.Generics.C1
           Control.Applicative.C1_0Const
           (GHC.Generics.S1
              Control.Applicative.S1_0_0Const (GHC.Generics.Rec0 a)))
    -- Defined in ‘Control.Applicative’
  type GHC.Generics.Rep1 (Control.Applicative.WrappedMonad m)
    ~ GHC.Generics.D1
        Control.Applicative.D1WrappedMonad
        (GHC.Generics.C1
           Control.Applicative.C1_0WrappedMonad
           (GHC.Generics.S1
              Control.Applicative.S1_0_0WrappedMonad (GHC.Generics.Rec1 m)))
    -- Defined in ‘Control.Applicative’
  type GHC.Generics.Rep1 (Control.Applicative.WrappedArrow a b)
    ~ GHC.Generics.D1
        Control.Applicative.D1WrappedArrow
        (GHC.Generics.C1
           Control.Applicative.C1_0WrappedArrow
           (GHC.Generics.S1
              Control.Applicative.S1_0_0WrappedArrow (GHC.Generics.Rec1 (a b))))
    -- Defined in ‘Control.Applicative’
  type GHC.Generics.Rep1 Control.Applicative.ZipList
    ~ GHC.Generics.D1
        Control.Applicative.D1ZipList
        (GHC.Generics.C1
           Control.Applicative.C1_0ZipList
           (GHC.Generics.S1
              Control.Applicative.S1_0_0ZipList (GHC.Generics.Rec1 [])))
    -- Defined in ‘Control.Applicative’
  type instance a Data.Type.Equality.== b
    ~ Data.Either.EqEither a b
    -- Defined in ‘Data.Either’
End famInstEnvs }
famInstEnvs (Internal) {
End famInstEnvs }
originalCts (simplifyTop)
  fvars =  [(aqY, i_aqY), (aqZ, e_aqZ), (ar0, a_ar0), (ar6, i_ar6),
            (ar7, e_ar7), (ar8, a_ar8), (au2, a_au2), (auT, t_auT),
            (auX, t_auX), (auY, a_auY), (ax0, a_ax0), (ax4, t_ax4),
            (ax5, t_ax5), (ax6, t_ax6), (ax9, m_ax9), (axb, a_axb),
            (axc, b_axc), (axy, a_axy), (axz, i_axz), (axA, e_axA),
            (axB, m_axB), (axC, b_axC), (axJ, m_axJ), (axL, a_axL),
            (axP, t_axP)]
  wanted =  WC {wc_flat = [W] $dIArray_ar9 :: Data.Array.Base.IArray
                                                a_ar8
                                                e_ar7 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                          [W] $dIx_ara :: GHC.Arr.Ix
                                            i_ar6 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                          [W] cobox_arb :: ((i_ar6, i_ar6) -> [e_ar7] -> a_ar8 i_ar6 e_ar7)
                                           ~ ((Int, Int)
                                              -> [Double] -> FlatVector) [" a type equality (i_ar6,
                                                                                             i_ar6)
                                                                                            -> [e_ar7]
                                                                                            -> a_ar8 i_ar6 e_ar7
                                                                                            ~
                                                                                            (Int,
                                                                                             Int)
                                                                                            -> [Double]
                                                                                            -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
                          [W] $dNum_atO :: Num
                                             a_au2 [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                          [W] cobox_auU :: [a_au2] ~ [t_auT] [" a type equality [a_au2]
                                                                                ~
                                                                                [t_auT] " p4.hs:16:61-62] (CNonCanonical)
                          [W] cobox_auV :: FlatVector
                                           ~ FlatVector [" a type equality FlatVector
                                                                           ~
                                                                           FlatVector " p4.hs:16:23-56] (CNonCanonical)
                          [W] cobox_auW :: t_auT ~ Int [" a type equality t_auT
                                                                          ~
                                                                          Int " p4.hs:16:41] (CNonCanonical)
                          [W] $dNum_auZ :: Num
                                             a_auY [" the literal ‘1’ " p4.hs:16:51] (CNonCanonical)
                          [W] cobox_av0 :: (Integer -> a_auY)
                                           ~ (Integer -> t_auX) [" a type equality Integer -> a_auY
                                                                                   ~
                                                                                   Integer
                                                                                   -> t_auX " p4.hs:16:51] (CNonCanonical)
                          [W] cobox_av1 :: t_auT ~ t_auX [" a type equality t_auT
                                                                            ~
                                                                            t_auX " p4.hs:16:54] (CNonCanonical)
                          [W] $dEnum_awY :: Enum
                                              t_auX [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CNonCanonical)
                          [W] cobox_ax1 :: Vector a_ax0
                                           ~ Vector FlatVector [" a type equality Vector a_ax0
                                                                                  ~
                                                                                  Vector
                                                                                    FlatVector " p4.hs:18:21-43] (CNonCanonical)
                          [W] cobox_ax2 :: Int ~ Int [" a type equality Int
                                                                        ~
                                                                        Int " p4.hs:18:35-37] (CNonCanonical)
                          [W] cobox_ax3 :: [FlatVector]
                                           ~ [a_ax0] [" a type equality [FlatVector]
                                                                        ~
                                                                        [a_ax0] " p4.hs:18:40-43] (CNonCanonical)
                          [W] $dMonad_axa :: Monad
                                               m_ax9 [" a do statement " p4.hs:19:11-23] (CNonCanonical)
                          [W] cobox_axe :: (m_ax9 a_axb
                                            -> (a_axb -> m_ax9 b_axc) -> m_ax9 b_axc)
                                           ~ (t_ax4
                                              -> (t_ax5 -> t_ax6)
                                              -> IO ()) [" a type equality m_ax9 a_axb
                                                                           -> (a_axb -> m_ax9 b_axc)
                                                                           -> m_ax9 b_axc
                                                                           ~
                                                                           t_ax4
                                                                           -> (t_ax5 -> t_ax6)
                                                                           -> IO
                                                                                () " p4.hs:19:11-23] (CNonCanonical)
                          [W] $dIx_axD :: GHC.Arr.Ix
                                            i_axz [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                          [W] $dIArray_axE :: Data.Array.Base.IArray
                                                a_axy
                                                e_axA [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                          [W] $dMArray_axF :: Data.Array.Base.MArray
                                                b_axC
                                                e_axA
                                                m_axB [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                          [W] cobox_axG :: m_axB (b_axC i_axz e_axA)
                                           ~ t_ax4 [" a type equality m_axB (b_axC i_axz e_axA)
                                                                      ~
                                                                      t_ax4 " p4.hs:19:16-23] (CNonCanonical)
                          [W] cobox_axH :: Vector FlatVector
                                           ~ a_axy i_axz e_axA [" a type equality Vector FlatVector
                                                                                  ~
                                                                                  a_axy i_axz e_axA " p4.hs:19:21-23] (CNonCanonical)
                          [W] $dMonad_axK :: Monad
                                               m_axJ [" a use of ‘return’ " p4.hs:20:11-16] (CNonCanonical)
                          [W] cobox_axN :: m_axJ a_axL ~ t_ax6 [" a type equality m_axJ a_axL
                                                                                  ~
                                                                                  t_ax6 " p4.hs:20:11-19] (CNonCanonical)
                          [W] cobox_axO :: () ~ a_axL [" a type equality ()
                                                                         ~
                                                                         a_axL " p4.hs:20:18-19] (CNonCanonical)
                          [W] cobox_axQ :: IO () ~ IO t_axP [" a type equality IO ()
                                                                               ~
                                                                               IO
                                                                                 t_axP " p4.hs:13:1] (CNonCanonical)
                wc_impl = Implic {Untouchables = 1
                                  Skolems = a
                                  Flatten-skolems =
                                  No-eqs = False
                                  Given =
                                  Wanted = WC {wc_flat = [W] $dIArray_ar1 :: Data.Array.Base.IArray
                                                                               a_ar0
                                                                               e_aqZ [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                                         [W] $dIx_ar2 :: GHC.Arr.Ix
                                                                           i_aqY [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                                         [W] cobox_ar3 :: ((i_aqY, i_aqY)
                                                                           -> [e_aqZ]
                                                                           -> a_ar0 i_aqY e_aqZ)
                                                                          ~ ((Int, Int)
                                                                             -> [a]
                                                                             -> Vector
                                                                                  a) [" a type equality (i_aqY,
                                                                                                         i_aqY)
                                                                                                        -> [e_aqZ]
                                                                                                        -> a_ar0 i_aqY e_aqZ
                                                                                                        ~
                                                                                                        (Int,
                                                                                                         Int)
                                                                                                        -> [a]
                                                                                                        -> Vector
                                                                                                             a " p4.hs:30:14-25] (CNonCanonical)}
                                  Binds = EvBindsVar<ar4>
                                  the type signature for
                                    listVector :: (Int, Int) -> [a] -> Vector a}}
Tc9

p4.hs:19:16:
    No instance for (Data.Array.Base.MArray b0 FlatVector IO)
      arising from a use of ‘thaw’
    The type variable ‘b0’ is ambiguous
    Note: there is a potential instance available:
      instance Data.Array.Base.MArray GHC.IOArray.IOArray e IO
        -- Defined in ‘Data.Array.Base’
    In a stmt of a 'do' block: v <- thaw tmp
    In the expression:
      do { let sL = ...
               dim = length sL
               ....;
           v <- thaw tmp;
           return () }
    In an equation for ‘main’:
        main
          = do { let sL = ...
                     ....;
                 v <- thaw tmp;
                 return () }
