rn12
rn13
Tc2 (src)
Tc3
kcTyClGroup
  module Main
  type FlatVector = UArray Int Double
kcTyClGroup: initial kinds []
env2 []
kcd1 FlatVector []
tc_lhs_type:
  UArray Int Double
  Expected kind ‘k_aOY’
tc_lhs_type:
  UArray
  Expected kind ‘k_aOZ’
lk1 UArray
lk2 UArray Type constructor ‘UArray’
writeMetaTyVar k_aOZ := * -> * -> *
tc_lhs_type:
  Int
  The first argument of ‘UArray’ should have kind ‘*’
lk1 Int
lk2 Int Type constructor ‘Int’
tc_lhs_type:
  Double
  The second argument of ‘UArray’ should have kind ‘*’
lk1 Double
lk2 Double Type constructor ‘Double’
writeMetaTyVar k_aOY := *
kcd2 FlatVector
Generalise kind
  FlatVector
  k_aOY
  []
  *
kcTyClGroup result [(FlatVector, *)]
tcTyAndCl generalized kinds [(FlatVector, *)]
tcTyAndCl-x type FlatVector = UArray Int Double
env2 []
env2 []
tc-syn
  FlatVector
  [(rq1, AThing *)]
tc_lhs_type:
  UArray Int Double
  Expected kind ‘*’
tc_lhs_type:
  UArray
  Expected kind ‘k_aP8’
lk1 UArray
lk2 UArray Type constructor ‘UArray’
writeMetaTyVar k_aP8 := * -> * -> *
tc_lhs_type:
  Int
  The first argument of ‘UArray’ should have kind ‘*’
lk1 Int
lk2 Int Type constructor ‘Int’
tc_lhs_type:
  Double
  The second argument of ‘UArray’ should have kind ‘*’
lk1 Double
lk2 Double Type constructor ‘Double’
Starting validity check [Type constructor ‘FlatVector’]
checkValidType UArray Int Double :: *
checkValidType done UArray Int Double :: *
env2 []
kcTyClGroup
  module Main
  type Vector a = Array Int a
kcTyClGroup: initial kinds []
env2 []
kcd1 Vector [a]
tc_lhs_type:
  Array Int a
  Expected kind ‘k_aPa’
tc_lhs_type:
  Array
  Expected kind ‘k_aPb’
lk1 Array
lk2 Array Type constructor ‘Array’
writeMetaTyVar k_aPb := * -> * -> *
tc_lhs_type:
  Int
  The first argument of ‘Array’ should have kind ‘*’
lk1 Int
lk2 Int Type constructor ‘Int’
tc_lhs_type:
  a
  The second argument of ‘Array’ should have kind ‘*’
lk1 a
lk2 a AThing k_aP9
writeMetaTyVar k_aP9 := *
writeMetaTyVar k_aPa := *
kcd2 Vector
Generalise kind
  Vector
  k_aP9 -> k_aPa
  []
  * -> *
kcTyClGroup result [(Vector, * -> *)]
tcTyAndCl generalized kinds [(Vector, * -> *)]
tcTyAndCl-x type Vector a = Array Int a
env2 []
env2 [(a, Type variable ‘a’ = a)]
tc-syn
  Vector
  [(aq6, Type variable ‘a’ = a), (rp0, AThing * -> *)]
tc_lhs_type:
  Array Int a
  Expected kind ‘*’
tc_lhs_type:
  Array
  Expected kind ‘k_aPk’
lk1 Array
lk2 Array Type constructor ‘Array’
writeMetaTyVar k_aPk := * -> * -> *
tc_lhs_type:
  Int
  The first argument of ‘Array’ should have kind ‘*’
lk1 Int
lk2 Int Type constructor ‘Int’
tc_lhs_type:
  a
  The second argument of ‘Array’ should have kind ‘*’
lk1 a
lk2 a Type variable ‘a’ = a
Starting validity check [Type constructor ‘Vector’]
checkValidType Array Int a :: *
checkValidType done Array Int a :: *
env2 []
Adding instances:
addFamInsts
env2 []
tcDeriving
tcDeriving False
tcDeriving 1 []
Adding instances:
Tc3b
tcAmpMissingParentClassWarn/isInsts []
tcAmpMissingParentClassWarn/isInsts []
tcAmpFunctionWarn/wouldBeImported
tcAmpFunctionWarn/amp_prelude_functions Control.Monad.join []
tcAmpFunctionWarn/wouldBeImported
tcAmpFunctionWarn/amp_prelude_functions Control.Applicative.<*> []
tcAmpFunctionWarn/wouldBeImported
tcAmpFunctionWarn/amp_prelude_functions Control.Applicative.pure []
Tc4
Tc4a
env2 []
Tc5
env2 []
tcHsTyVarBndrs {
  Hs kind vars: []
  Hs type vars: [a]
  Kind vars: []
  Type vars: [a]
env2 [(a, Type variable ‘a’ = a)]
tc_lhs_type:
  (Int, Int) -> [a] -> Vector a
  Expected a type
tc_lhs_type:
  (Int, Int)
  Expected a type
tc_lhs_type:
  Int
  Expected kind ‘k_a178’
lk1 Int
lk2 Int Type constructor ‘Int’
writeMetaTyVar k_a178 := *
tc_lhs_type:
  Int
  Expected kind ‘k_a179’
lk1 Int
lk2 Int Type constructor ‘Int’
writeMetaTyVar k_a179 := *
tc_lhs_type:
  [a] -> Vector a
  Expected a type
tc_lhs_type:
  [a]
  Expected a type
tc_lhs_type:
  a
  Expected kind ‘*’
lk1 a
lk2 a Type variable ‘a’ = a
writeMetaTyVar k_a177 := *
tc_lhs_type:
  Vector a
  Expected a type
tc_lhs_type:
  Vector
  Expected kind ‘k_a17a’
lk1 Vector
lk2 Vector Type constructor ‘Vector’
writeMetaTyVar k_a17a := * -> *
tc_lhs_type:
  a
  The first argument of ‘Vector’ should have kind ‘*’
lk1 a
lk2 a Type variable ‘a’ = a
tcHsTyVarBndrs }
  Hs kind vars: []
  Hs type vars: [a]
  Kind vars: []
  Type vars: [a]
tcCheckHsTypeAndGen (Int, Int) -> [a] -> Vector a
checkValidType forall a. (Int, Int) -> [a] -> Vector a :: *
Ambiguity check for forall a. (Int, Int) -> [a] -> Vector a
tcGen
u_tys 
  untch 1
  (Int, Int) -> [a_a17d] -> Vector a_a17d
  ~
  (Int, Int) -> [a] -> Vector a
  a type equality (Int, Int) -> [a_a17d] -> Vector a_a17d
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys 
  untch 1
  (Int, Int) ~ (Int, Int)
  a type equality (Int, Int) -> [a_a17d] -> Vector a_a17d
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys 
  untch 1
  Int ~ Int
  a type equality (Int, Int) -> [a_a17d] -> Vector a_a17d
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys yields no coercion
u_tys 
  untch 1
  Int ~ Int
  a type equality (Int, Int) -> [a_a17d] -> Vector a_a17d
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys yields no coercion
u_tys yields no coercion
u_tys 
  untch 1
  [a_a17d] -> Vector a_a17d ~ [a] -> Vector a
  a type equality (Int, Int) -> [a_a17d] -> Vector a_a17d
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys 
  untch 1
  [a_a17d] ~ [a]
  a type equality (Int, Int) -> [a_a17d] -> Vector a_a17d
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys 
  untch 1
  a_a17d ~ a
  a type equality (Int, Int) -> [a_a17d] -> Vector a_a17d
                  ~
                  (Int, Int) -> [a] -> Vector a
uUnfilledVars trying to unify * with *
writeMetaTyVar a_a17d := a
u_tys yields no coercion
u_tys yields no coercion
u_tys 
  untch 1
  Vector a_a17d ~ Vector a
  a type equality (Int, Int) -> [a_a17d] -> Vector a_a17d
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys 
  untch 1
  Int ~ Int
  a type equality (Int, Int) -> [a_a17d] -> Vector a_a17d
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys yields no coercion
u_tys 
  untch 1
  a_a17d ~ a
  a type equality (Int, Int) -> [a_a17d] -> Vector a_a17d
                  ~
                  (Int, Int) -> [a] -> Vector a
u_tys yields no coercion
u_tys yields no coercion
u_tys yields no coercion
u_tys yields no coercion
simplifyAmbiguityCheck {
  type =  forall a. (Int, Int) -> [a] -> Vector a
  wanted =  WC {}
solveWantedsTcMWithEvBinds wanted= WC {}
solveWanteds { WC {}
solveFlats {
solveFlats end } {}
simpl_loop, iteration 1
solveWanteds }
  unsolved_flats   = {}
  unsolved_implics = {}
  current evbinds  = {}
  current tybinds  =
  final wc = WC {}
End simplifyAmbiguityCheck }
reportUnsolved(ambig) {
reportUnsolved(ambig) }
Done ambiguity check for forall a. (Int, Int) -> [a] -> Vector a
checkValidType done forall a. (Int, Int) -> [a] -> Vector a :: *
tc_lhs_type:
  (Int, Int)
  Expected a type
tc_lhs_type:
  Int
  Expected kind ‘k_a17i’
lk1 Int
lk2 Int Type constructor ‘Int’
writeMetaTyVar k_a17i := *
tc_lhs_type:
  Int
  Expected kind ‘k_a17j’
lk1 Int
lk2 Int Type constructor ‘Int’
writeMetaTyVar k_a17j := *
tc_lhs_type:
  [Double] -> FlatVector
  Expected a type
tc_lhs_type:
  [Double]
  Expected a type
tc_lhs_type:
  Double
  Expected kind ‘*’
lk1 Double
lk2 Double Type constructor ‘Double’
tc_lhs_type:
  FlatVector
  Expected a type
lk1 FlatVector
lk2 FlatVector Type constructor ‘FlatVector’
tcCheckHsTypeAndGen (Int, Int) -> [Double] -> FlatVector
checkValidType (Int, Int) -> [Double] -> FlatVector :: *
checkValidType done (Int, Int) -> [Double] -> FlatVector :: *
tc_lhs_type:
  IO
  Expected kind ‘k_a17k’
lk1 IO
lk2 IO Type constructor ‘IO’
writeMetaTyVar k_a17k := * -> *
tc_lhs_type:
  ()
  The first argument of ‘IO’ should have kind ‘*’
tcCheckHsTypeAndGen IO ()
checkValidType IO () :: *
checkValidType done IO () :: *
env2
  [(listVector,
    Identifier[listVector::forall a.
                           (Int, Int) -> [a] -> Vector a, <NotTopLevel>]),
   (listFlatVector,
    Identifier[listFlatVector::(Int, Int)
                               -> [Double] -> FlatVector, <NotTopLevel>]),
   (main, Identifier[main::IO (), <NotTopLevel>])]
------------------------------------------------
Bindings for { [listVector]
Generalisation plan
  CheckGen listVector :: (Int, Int) -> [a] -> Vector a
                         [Nothing]
env2 []
tcMonoBinds
env2 []
tcRhs: fun bind
  listVector
  (Int, Int) -> [a] -> Vector a
tcMatchesFun
  listVector
  (Int, Int) -> [a] -> Vector a
tcGen
tcBody (Int, Int) -> [a] -> Vector a
Instantiating
  listArray with [i_a17T, e_a17U, a_a17V]
                 [Data.Array.Base.IArray a_a17V e_a17U, GHC.Arr.Ix i_a17T]
instCallConstraints [$dIArray_a17W, $dIx_a17X]
utype_defer
  cobox_a17Y
  (i_a17T, i_a17T) -> [e_a17U] -> a_a17V i_a17T e_a17U
  (Int, Int) -> [a] -> Vector a
  a type equality (i_a17T, i_a17T)
                  -> [e_a17U] -> a_a17V i_a17T e_a17U
                  ~
                  (Int, Int) -> [a] -> Vector a
  In the expression: listArray
  In an equation for ‘listVector’: listVector = listArray
addInlinePrags
  listVector
  []
csb2 [listVector]
} End of bindings for
  [listVector]
  NonRecursive
  listVector forall a. (Int, Int) -> [a] -> Vector a
env2
  [(listVector,
    Identifier[listVector::forall a.
                           (Int, Int) -> [a] -> Vector a, <TopLevel>])]
------------------------------------------------
Bindings for { [listFlatVector]
Generalisation plan
  CheckGen listFlatVector :: (Int, Int) -> [Double] -> FlatVector
                             []
env2 []
tcMonoBinds
env2 []
tcRhs: fun bind
  listFlatVector
  (Int, Int) -> [Double] -> FlatVector
tcMatchesFun
  listFlatVector
  (Int, Int) -> [Double] -> FlatVector
tcGen
tcBody (Int, Int) -> [Double] -> FlatVector
Instantiating
  listArray with [i_a181, e_a182, a_a183]
                 [Data.Array.Base.IArray a_a183 e_a182, GHC.Arr.Ix i_a181]
instCallConstraints [$dIArray_a184, $dIx_a185]
utype_defer
  cobox_a186
  (i_a181, i_a181) -> [e_a182] -> a_a183 i_a181 e_a182
  (Int, Int) -> [Double] -> FlatVector
  a type equality (i_a181, i_a181)
                  -> [e_a182] -> a_a183 i_a181 e_a182
                  ~
                  (Int, Int) -> [Double] -> FlatVector
  In the expression: listArray
  In an equation for ‘listFlatVector’: listFlatVector = listArray
addInlinePrags
  listFlatVector
  []
csb2 [listFlatVector]
} End of bindings for
  [listFlatVector]
  NonRecursive
  listFlatVector (Int, Int) -> [Double] -> FlatVector
env2
  [(listFlatVector,
    Identifier[listFlatVector::(Int, Int)
                               -> [Double] -> FlatVector, <TopLevel>])]
------------------------------------------------
Bindings for { [main]
Generalisation plan
  CheckGen main :: IO ()
                   []
env2 []
tcMonoBinds
env2 []
tcRhs: fun bind
  main
  IO ()
tcMatchesFun
  main
  IO ()
tcGen
tcBody IO ()
tc_lhs_type:
  FlatVector
  Expected kind ‘*’
lk1 FlatVector
lk2 FlatVector Type constructor ‘FlatVector’
tcCheckHsTypeAndGen [FlatVector]
checkValidType [FlatVector] :: *
checkValidType done [FlatVector] :: *
tc_lhs_type:
  Vector
  Expected kind ‘k_a188’
lk1 Vector
lk2 Vector Type constructor ‘Vector’
writeMetaTyVar k_a188 := * -> *
tc_lhs_type:
  FlatVector
  The first argument of ‘Vector’ should have kind ‘*’
lk1 FlatVector
lk2 FlatVector Type constructor ‘FlatVector’
tcCheckHsTypeAndGen Vector FlatVector
checkValidType Vector FlatVector :: *
checkValidType done Vector FlatVector :: *
env2
  [(help, Identifier[help::[FlatVector], <NotTopLevel>]),
   (tmp, Identifier[tmp::Vector FlatVector, <NotTopLevel>])]
------------------------------------------------
Bindings for { [sL]
Generalisation plan InferGen True True
tcMatchesFun
  sL
  t_a189
tcGen
tcBody t_a189
utype_defer
  cobox_a18c
  [t_a18b]
  t_a189
  a type equality [t_a18b] ~ t_a189
  In the expression: [1, 4, 6, 3, 2, 5]
  In an equation for ‘sL’: sL = [1, 4, 6, 3, 2, 5]
  In the expression:
    do { let sL = [1, 4, 6, 3, 2, 5]
             dim = length sL
             help :: [FlatVector]
             help = [listFlatVector (1, s) [0 | i <- [1 .. s]] | s <- sL]
             tmp :: Vector FlatVector
             tmp = listVector (1, dim) help;
         v <- thaw tmp;
         return () }
tcPolyExpr t_a18b
tcPolyExprNC t_a18b
tcGen
Instantiating
  fromInteger with [a_a1bm]
                   [Num a_a1bm]
instCallConstraints [$dNum_a1bn]
utype_defer
  cobox_a1bo
  Integer -> a_a1bm
  Integer -> t_a18b
  a type equality Integer -> a_a1bm ~ Integer -> t_a18b
  In the expression: 1
  In the expression: [1, 4, 6, 3, 2, 5]
  In an equation for ‘sL’: sL = [1, 4, 6, 3, 2, 5]
tcPolyExpr t_a18b
tcPolyExprNC t_a18b
tcGen
Instantiating
  fromInteger with [a_a1bp]
                   [Num a_a1bp]
instCallConstraints [$dNum_a1bq]
utype_defer
  cobox_a1br
  Integer -> a_a1bp
  Integer -> t_a18b
  a type equality Integer -> a_a1bp ~ Integer -> t_a18b
  In the expression: 4
  In the expression: [1, 4, 6, 3, 2, 5]
  In an equation for ‘sL’: sL = [1, 4, 6, 3, 2, 5]
tcPolyExpr t_a18b
tcPolyExprNC t_a18b
tcGen
Instantiating
  fromInteger with [a_a1bs]
                   [Num a_a1bs]
instCallConstraints [$dNum_a1bt]
utype_defer
  cobox_a1bu
  Integer -> a_a1bs
  Integer -> t_a18b
  a type equality Integer -> a_a1bs ~ Integer -> t_a18b
  In the expression: 6
  In the expression: [1, 4, 6, 3, 2, 5]
  In an equation for ‘sL’: sL = [1, 4, 6, 3, 2, 5]
tcPolyExpr t_a18b
tcPolyExprNC t_a18b
tcGen
Instantiating
  fromInteger with [a_a1bv]
                   [Num a_a1bv]
instCallConstraints [$dNum_a1bw]
utype_defer
  cobox_a1bx
  Integer -> a_a1bv
  Integer -> t_a18b
  a type equality Integer -> a_a1bv ~ Integer -> t_a18b
  In the expression: 3
  In the expression: [1, 4, 6, 3, 2, 5]
  In an equation for ‘sL’: sL = [1, 4, 6, 3, 2, 5]
tcPolyExpr t_a18b
tcPolyExprNC t_a18b
tcGen
Instantiating
  fromInteger with [a_a1by]
                   [Num a_a1by]
instCallConstraints [$dNum_a1bz]
utype_defer
  cobox_a1bA
  Integer -> a_a1by
  Integer -> t_a18b
  a type equality Integer -> a_a1by ~ Integer -> t_a18b
  In the expression: 2
  In the expression: [1, 4, 6, 3, 2, 5]
  In an equation for ‘sL’: sL = [1, 4, 6, 3, 2, 5]
tcPolyExpr t_a18b
tcPolyExprNC t_a18b
tcGen
Instantiating
  fromInteger with [a_a1bB]
                   [Num a_a1bB]
instCallConstraints [$dNum_a1bC]
utype_defer
  cobox_a1bD
  Integer -> a_a1bB
  Integer -> t_a18b
  a type equality Integer -> a_a1bB ~ Integer -> t_a18b
  In the expression: 5
  In the expression: [1, 4, 6, 3, 2, 5]
  In an equation for ‘sL’: sL = [1, 4, 6, 3, 2, 5]
simplifyInfer call
  [(sL, t_a189)]
  WC {wc_flat = [W] cobox_a18c :: [t_a18b]
                                  ~ t_a189 [" a type equality [t_a18b]
                                                              ~
                                                              t_a189 " p4.hs:13:20-32] (CNonCanonical)
                [W] $dNum_a1bn :: Num
                                    a_a1bm [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                [W] cobox_a1bo :: (Integer -> a_a1bm)
                                  ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bm
                                                                           ~
                                                                           Integer
                                                                           -> t_a18b " p4.hs:13:21] (CNonCanonical)
                [W] $dNum_a1bq :: Num
                                    a_a1bp [" the literal ‘4’ " p4.hs:13:23] (CNonCanonical)
                [W] cobox_a1br :: (Integer -> a_a1bp)
                                  ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bp
                                                                           ~
                                                                           Integer
                                                                           -> t_a18b " p4.hs:13:23] (CNonCanonical)
                [W] $dNum_a1bt :: Num
                                    a_a1bs [" the literal ‘6’ " p4.hs:13:25] (CNonCanonical)
                [W] cobox_a1bu :: (Integer -> a_a1bs)
                                  ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bs
                                                                           ~
                                                                           Integer
                                                                           -> t_a18b " p4.hs:13:25] (CNonCanonical)
                [W] $dNum_a1bw :: Num
                                    a_a1bv [" the literal ‘3’ " p4.hs:13:27] (CNonCanonical)
                [W] cobox_a1bx :: (Integer -> a_a1bv)
                                  ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bv
                                                                           ~
                                                                           Integer
                                                                           -> t_a18b " p4.hs:13:27] (CNonCanonical)
                [W] $dNum_a1bz :: Num
                                    a_a1by [" the literal ‘2’ " p4.hs:13:29] (CNonCanonical)
                [W] cobox_a1bA :: (Integer -> a_a1by)
                                  ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1by
                                                                           ~
                                                                           Integer
                                                                           -> t_a18b " p4.hs:13:29] (CNonCanonical)
                [W] $dNum_a1bC :: Num
                                    a_a1bB [" the literal ‘5’ " p4.hs:13:31] (CNonCanonical)
                [W] cobox_a1bD :: (Integer -> a_a1bB)
                                  ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bB
                                                                           ~
                                                                           Integer
                                                                           -> t_a18b " p4.hs:13:31] (CNonCanonical)}
simplifyInfer {
  binds = [(sL, t_a189)]
  closed = True
  apply_mr = True
  (unzonked) wanted = WC {wc_flat = [W] cobox_a18c :: [t_a18b]
                                                      ~ t_a189 [" a type equality [t_a18b]
                                                                                  ~
                                                                                  t_a189 " p4.hs:13:20-32] (CNonCanonical)
                                    [W] $dNum_a1bn :: Num
                                                        a_a1bm [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                                    [W] cobox_a1bo :: (Integer -> a_a1bm)
                                                      ~ (Integer
                                                         -> t_a18b) [" a type equality Integer
                                                                                       -> a_a1bm
                                                                                       ~
                                                                                       Integer
                                                                                       -> t_a18b " p4.hs:13:21] (CNonCanonical)
                                    [W] $dNum_a1bq :: Num
                                                        a_a1bp [" the literal ‘4’ " p4.hs:13:23] (CNonCanonical)
                                    [W] cobox_a1br :: (Integer -> a_a1bp)
                                                      ~ (Integer
                                                         -> t_a18b) [" a type equality Integer
                                                                                       -> a_a1bp
                                                                                       ~
                                                                                       Integer
                                                                                       -> t_a18b " p4.hs:13:23] (CNonCanonical)
                                    [W] $dNum_a1bt :: Num
                                                        a_a1bs [" the literal ‘6’ " p4.hs:13:25] (CNonCanonical)
                                    [W] cobox_a1bu :: (Integer -> a_a1bs)
                                                      ~ (Integer
                                                         -> t_a18b) [" a type equality Integer
                                                                                       -> a_a1bs
                                                                                       ~
                                                                                       Integer
                                                                                       -> t_a18b " p4.hs:13:25] (CNonCanonical)
                                    [W] $dNum_a1bw :: Num
                                                        a_a1bv [" the literal ‘3’ " p4.hs:13:27] (CNonCanonical)
                                    [W] cobox_a1bx :: (Integer -> a_a1bv)
                                                      ~ (Integer
                                                         -> t_a18b) [" a type equality Integer
                                                                                       -> a_a1bv
                                                                                       ~
                                                                                       Integer
                                                                                       -> t_a18b " p4.hs:13:27] (CNonCanonical)
                                    [W] $dNum_a1bz :: Num
                                                        a_a1by [" the literal ‘2’ " p4.hs:13:29] (CNonCanonical)
                                    [W] cobox_a1bA :: (Integer -> a_a1by)
                                                      ~ (Integer
                                                         -> t_a18b) [" a type equality Integer
                                                                                       -> a_a1by
                                                                                       ~
                                                                                       Integer
                                                                                       -> t_a18b " p4.hs:13:29] (CNonCanonical)
                                    [W] $dNum_a1bC :: Num
                                                        a_a1bB [" the literal ‘5’ " p4.hs:13:31] (CNonCanonical)
                                    [W] cobox_a1bD :: (Integer -> a_a1bB)
                                                      ~ (Integer
                                                         -> t_a18b) [" a type equality Integer
                                                                                       -> a_a1bB
                                                                                       ~
                                                                                       Integer
                                                                                       -> t_a18b " p4.hs:13:31] (CNonCanonical)}
solveWantedsTcMWithEvBinds
  wanted= WC {wc_flat = [W] cobox_a18c :: [t_a18b]
                                          ~ t_a189 [" a type equality [t_a18b]
                                                                      ~
                                                                      t_a189 " p4.hs:13:20-32] (CNonCanonical)
                        [W] $dNum_a1bn :: Num
                                            a_a1bm [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                        [W] cobox_a1bo :: (Integer -> a_a1bm)
                                          ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bm
                                                                                   ~
                                                                                   Integer
                                                                                   -> t_a18b " p4.hs:13:21] (CNonCanonical)
                        [W] $dNum_a1bq :: Num
                                            a_a1bp [" the literal ‘4’ " p4.hs:13:23] (CNonCanonical)
                        [W] cobox_a1br :: (Integer -> a_a1bp)
                                          ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bp
                                                                                   ~
                                                                                   Integer
                                                                                   -> t_a18b " p4.hs:13:23] (CNonCanonical)
                        [W] $dNum_a1bt :: Num
                                            a_a1bs [" the literal ‘6’ " p4.hs:13:25] (CNonCanonical)
                        [W] cobox_a1bu :: (Integer -> a_a1bs)
                                          ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bs
                                                                                   ~
                                                                                   Integer
                                                                                   -> t_a18b " p4.hs:13:25] (CNonCanonical)
                        [W] $dNum_a1bw :: Num
                                            a_a1bv [" the literal ‘3’ " p4.hs:13:27] (CNonCanonical)
                        [W] cobox_a1bx :: (Integer -> a_a1bv)
                                          ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bv
                                                                                   ~
                                                                                   Integer
                                                                                   -> t_a18b " p4.hs:13:27] (CNonCanonical)
                        [W] $dNum_a1bz :: Num
                                            a_a1by [" the literal ‘2’ " p4.hs:13:29] (CNonCanonical)
                        [W] cobox_a1bA :: (Integer -> a_a1by)
                                          ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1by
                                                                                   ~
                                                                                   Integer
                                                                                   -> t_a18b " p4.hs:13:29] (CNonCanonical)
                        [W] $dNum_a1bC :: Num
                                            a_a1bB [" the literal ‘5’ " p4.hs:13:31] (CNonCanonical)
                        [W] cobox_a1bD :: (Integer -> a_a1bB)
                                          ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bB
                                                                                   ~
                                                                                   Integer
                                                                                   -> t_a18b " p4.hs:13:31] (CNonCanonical)}
solveWanteds {
  WC {wc_flat = [W] cobox_a18c :: [t_a18b]
                                  ~ t_a189 [" a type equality [t_a18b]
                                                              ~
                                                              t_a189 " p4.hs:13:20-32] (CNonCanonical)
                [W] $dNum_a1bn :: Num
                                    a_a1bm [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                [W] cobox_a1bo :: (Integer -> a_a1bm)
                                  ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bm
                                                                           ~
                                                                           Integer
                                                                           -> t_a18b " p4.hs:13:21] (CNonCanonical)
                [W] $dNum_a1bq :: Num
                                    a_a1bp [" the literal ‘4’ " p4.hs:13:23] (CNonCanonical)
                [W] cobox_a1br :: (Integer -> a_a1bp)
                                  ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bp
                                                                           ~
                                                                           Integer
                                                                           -> t_a18b " p4.hs:13:23] (CNonCanonical)
                [W] $dNum_a1bt :: Num
                                    a_a1bs [" the literal ‘6’ " p4.hs:13:25] (CNonCanonical)
                [W] cobox_a1bu :: (Integer -> a_a1bs)
                                  ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bs
                                                                           ~
                                                                           Integer
                                                                           -> t_a18b " p4.hs:13:25] (CNonCanonical)
                [W] $dNum_a1bw :: Num
                                    a_a1bv [" the literal ‘3’ " p4.hs:13:27] (CNonCanonical)
                [W] cobox_a1bx :: (Integer -> a_a1bv)
                                  ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bv
                                                                           ~
                                                                           Integer
                                                                           -> t_a18b " p4.hs:13:27] (CNonCanonical)
                [W] $dNum_a1bz :: Num
                                    a_a1by [" the literal ‘2’ " p4.hs:13:29] (CNonCanonical)
                [W] cobox_a1bA :: (Integer -> a_a1by)
                                  ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1by
                                                                           ~
                                                                           Integer
                                                                           -> t_a18b " p4.hs:13:29] (CNonCanonical)
                [W] $dNum_a1bC :: Num
                                    a_a1bB [" the literal ‘5’ " p4.hs:13:31] (CNonCanonical)
                [W] cobox_a1bD :: (Integer -> a_a1bB)
                                  ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bB
                                                                           ~
                                                                           Integer
                                                                           -> t_a18b " p4.hs:13:31] (CNonCanonical)}
solveFlats {
Start solver pipeline {
  work item =  [W] cobox_a18c :: [t_a18b]
                                 ~ t_a189 [" a type equality [t_a18b]
                                                             ~
                                                             t_a189 " p4.hs:13:20-32] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a18c :: [t_a18b]
                                  ~ t_a189 [" a type equality [t_a18b]
                                                              ~
                                                              t_a189 " p4.hs:13:20-32] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a18c :: [t_a18b] ~ t_a189 [" a type equality [t_a18b]
                                                         ~
                                                         t_a189 " p4.hs:13:20-32] (CNonCanonical)
canEvNC:eq
  [t_a18b]
  t_a189
can_eq_nc
  [W] cobox_a18c :: [t_a18b] ~ t_a189
  [t_a18b]
  [t_a18b]
  t_a189
  t_a189
canEqTyVar
  t_a189
  [t_a18b]
  Is-swapped
newWantedEvVar/cache miss [W] cobox_a1bF :: t_a189 ~ [t_a18b]
setEvBind
  ev = cobox_a18c
  tm  = CO Sym cobox_a1bF
rewriteEqEvidence
  [W] cobox_a18c :: [t_a18b] ~ t_a189
  t_a189
  [t_a18b]
  Sym cobox_a1bF
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1bF :: t_a189
                                  ~ [t_a18b] [" a type equality [t_a18b]
                                                                ~
                                                                t_a189 " p4.hs:13:20-32] (CTyEqCan)
Sneaky unification:
  Unifies: t_a189 := [t_a18b]
  Coercion: t_a189 ~ [t_a18b]
  Left Kind is: OpenKind
  Right Kind is: *
setWantedTyBind t_a189 := [t_a18b]
setEvBind
  ev = cobox_a1bF
  tm  = CO <[t_a18b]>_N
kickOutRewritable
  tv =  t_a189
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
1[<C:0,F:0>] [W] cobox_a1bF :: t_a189
                               ~ [t_a18b]: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1bo :: (Integer -> a_a1bm)
                                 ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bm
                                                                          ~
                                                                          Integer
                                                                          -> t_a18b " p4.hs:13:21] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1bo :: (Integer -> a_a1bm)
                                  ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bm
                                                                           ~
                                                                           Integer
                                                                           -> t_a18b " p4.hs:13:21] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1bo :: (Integer -> a_a1bm)
                    ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bm
                                                             ~
                                                             Integer
                                                             -> t_a18b " p4.hs:13:21] (CNonCanonical)
canEvNC:eq
  Integer -> a_a1bm
  Integer -> t_a18b
can_eq_nc
  [W] cobox_a1bo :: (Integer -> a_a1bm) ~ (Integer -> t_a18b)
  Integer -> a_a1bm
  Integer -> a_a1bm
  Integer -> t_a18b
  Integer -> t_a18b
newWantedEvVar/cache miss [W] cobox_a1bG :: Integer ~ Integer
newWantedEvVar/cache miss [W] cobox_a1bH :: a_a1bm ~ t_a18b
setEvBind
  ev = cobox_a1bo
  tm  = CO cobox_a1bG -> cobox_a1bH
canEvNC:eq
  Integer
  Integer
can_eq_nc
  [W] cobox_a1bG :: Integer ~ Integer
  Integer
  Integer
  Integer
  Integer
setEvBind
  ev = cobox_a1bG
  tm  = CO <Integer>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1bH :: a_a1bm
                                 ~ t_a18b [" a type equality Integer -> a_a1bm
                                                             ~
                                                             Integer
                                                             -> t_a18b " p4.hs:13:21] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1bH :: a_a1bm
                                  ~ t_a18b [" a type equality Integer -> a_a1bm
                                                              ~
                                                              Integer
                                                              -> t_a18b " p4.hs:13:21] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1bH :: a_a1bm ~ t_a18b [" a type equality Integer
                                                       -> a_a1bm
                                                       ~
                                                       Integer
                                                       -> t_a18b " p4.hs:13:21] (CNonCanonical)
canEvNC:eq
  a_a1bm
  t_a18b
can_eq_nc
  [W] cobox_a1bH :: a_a1bm ~ t_a18b
  a_a1bm
  a_a1bm
  t_a18b
  t_a18b
canEqTyVar
  a_a1bm
  t_a18b
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1bH :: a_a1bm
                                  ~ t_a18b [" a type equality Integer -> a_a1bm
                                                              ~
                                                              Integer
                                                              -> t_a18b " p4.hs:13:21] (CTyEqCan)
Sneaky unification:
  Unifies: t_a18b := a_a1bm
  Coercion: t_a18b ~ a_a1bm
  Left Kind is: *
  Right Kind is: *
setWantedTyBind t_a18b := a_a1bm
setEvBind
  ev = cobox_a1bH
  tm  = CO <a_a1bm>_N
kickOutRewritable
  tv =  t_a18b
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
3[<C:0,F:0>] [W] cobox_a1bH :: a_a1bm
                               ~ t_a18b: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1br :: (Integer -> a_a1bp)
                                 ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bp
                                                                          ~
                                                                          Integer
                                                                          -> t_a18b " p4.hs:13:23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1br :: (Integer -> a_a1bp)
                                  ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bp
                                                                           ~
                                                                           Integer
                                                                           -> t_a18b " p4.hs:13:23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1br :: (Integer -> a_a1bp)
                    ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bp
                                                             ~
                                                             Integer
                                                             -> t_a18b " p4.hs:13:23] (CNonCanonical)
canEvNC:eq
  Integer -> a_a1bp
  Integer -> t_a18b
can_eq_nc
  [W] cobox_a1br :: (Integer -> a_a1bp) ~ (Integer -> t_a18b)
  Integer -> a_a1bp
  Integer -> a_a1bp
  Integer -> t_a18b
  Integer -> t_a18b
newWantedEvVar/cache miss [W] cobox_a1bI :: Integer ~ Integer
newWantedEvVar/cache miss [W] cobox_a1bJ :: a_a1bp ~ t_a18b
setEvBind
  ev = cobox_a1br
  tm  = CO cobox_a1bI -> cobox_a1bJ
canEvNC:eq
  Integer
  Integer
can_eq_nc
  [W] cobox_a1bI :: Integer ~ Integer
  Integer
  Integer
  Integer
  Integer
setEvBind
  ev = cobox_a1bI
  tm  = CO <Integer>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1bJ :: a_a1bp
                                 ~ t_a18b [" a type equality Integer -> a_a1bp
                                                             ~
                                                             Integer
                                                             -> t_a18b " p4.hs:13:23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1bJ :: a_a1bp
                                  ~ t_a18b [" a type equality Integer -> a_a1bp
                                                              ~
                                                              Integer
                                                              -> t_a18b " p4.hs:13:23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1bJ :: a_a1bp ~ t_a18b [" a type equality Integer
                                                       -> a_a1bp
                                                       ~
                                                       Integer
                                                       -> t_a18b " p4.hs:13:23] (CNonCanonical)
canEvNC:eq
  a_a1bp
  t_a18b
can_eq_nc
  [W] cobox_a1bJ :: a_a1bp ~ t_a18b
  a_a1bp
  a_a1bp
  t_a18b
  t_a18b
canEqTyVar
  a_a1bp
  t_a18b
  Not-swapped
Following bound tyvar t_a18b = a_a1bm
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1bJ :: a_a1bp
                                  ~ a_a1bm [" a type equality Integer -> a_a1bp
                                                              ~
                                                              Integer
                                                              -> t_a18b " p4.hs:13:23] (CTyEqCan)
Sneaky unification:
  Unifies: a_a1bm := a_a1bp
  Coercion: a_a1bm ~ a_a1bp
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_a1bm := a_a1bp
setEvBind
  ev = cobox_a1bJ
  tm  = CO <a_a1bp>_N
kickOutRewritable
  tv =  a_a1bm
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
5[<C:0,F:0>] [W] cobox_a1bJ :: a_a1bp
                               ~ a_a1bm: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1bu :: (Integer -> a_a1bs)
                                 ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bs
                                                                          ~
                                                                          Integer
                                                                          -> t_a18b " p4.hs:13:25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1bu :: (Integer -> a_a1bs)
                                  ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bs
                                                                           ~
                                                                           Integer
                                                                           -> t_a18b " p4.hs:13:25] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1bu :: (Integer -> a_a1bs)
                    ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bs
                                                             ~
                                                             Integer
                                                             -> t_a18b " p4.hs:13:25] (CNonCanonical)
canEvNC:eq
  Integer -> a_a1bs
  Integer -> t_a18b
can_eq_nc
  [W] cobox_a1bu :: (Integer -> a_a1bs) ~ (Integer -> t_a18b)
  Integer -> a_a1bs
  Integer -> a_a1bs
  Integer -> t_a18b
  Integer -> t_a18b
newWantedEvVar/cache miss [W] cobox_a1bK :: Integer ~ Integer
newWantedEvVar/cache miss [W] cobox_a1bL :: a_a1bs ~ t_a18b
setEvBind
  ev = cobox_a1bu
  tm  = CO cobox_a1bK -> cobox_a1bL
canEvNC:eq
  Integer
  Integer
can_eq_nc
  [W] cobox_a1bK :: Integer ~ Integer
  Integer
  Integer
  Integer
  Integer
setEvBind
  ev = cobox_a1bK
  tm  = CO <Integer>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1bL :: a_a1bs
                                 ~ t_a18b [" a type equality Integer -> a_a1bs
                                                             ~
                                                             Integer
                                                             -> t_a18b " p4.hs:13:25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1bL :: a_a1bs
                                  ~ t_a18b [" a type equality Integer -> a_a1bs
                                                              ~
                                                              Integer
                                                              -> t_a18b " p4.hs:13:25] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1bL :: a_a1bs ~ t_a18b [" a type equality Integer
                                                       -> a_a1bs
                                                       ~
                                                       Integer
                                                       -> t_a18b " p4.hs:13:25] (CNonCanonical)
canEvNC:eq
  a_a1bs
  t_a18b
can_eq_nc
  [W] cobox_a1bL :: a_a1bs ~ t_a18b
  a_a1bs
  a_a1bs
  t_a18b
  t_a18b
canEqTyVar
  a_a1bs
  t_a18b
  Not-swapped
Following bound tyvar t_a18b = a_a1bm
Following bound tyvar a_a1bm = a_a1bp
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1bL :: a_a1bs
                                  ~ a_a1bp [" a type equality Integer -> a_a1bs
                                                              ~
                                                              Integer
                                                              -> t_a18b " p4.hs:13:25] (CTyEqCan)
Sneaky unification:
  Unifies: a_a1bp := a_a1bs
  Coercion: a_a1bp ~ a_a1bs
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_a1bp := a_a1bs
setEvBind
  ev = cobox_a1bL
  tm  = CO <a_a1bs>_N
kickOutRewritable
  tv =  a_a1bp
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
7[<C:0,F:0>] [W] cobox_a1bL :: a_a1bs
                               ~ a_a1bp: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1bx :: (Integer -> a_a1bv)
                                 ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bv
                                                                          ~
                                                                          Integer
                                                                          -> t_a18b " p4.hs:13:27] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1bx :: (Integer -> a_a1bv)
                                  ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bv
                                                                           ~
                                                                           Integer
                                                                           -> t_a18b " p4.hs:13:27] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1bx :: (Integer -> a_a1bv)
                    ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bv
                                                             ~
                                                             Integer
                                                             -> t_a18b " p4.hs:13:27] (CNonCanonical)
canEvNC:eq
  Integer -> a_a1bv
  Integer -> t_a18b
can_eq_nc
  [W] cobox_a1bx :: (Integer -> a_a1bv) ~ (Integer -> t_a18b)
  Integer -> a_a1bv
  Integer -> a_a1bv
  Integer -> t_a18b
  Integer -> t_a18b
newWantedEvVar/cache miss [W] cobox_a1bM :: Integer ~ Integer
newWantedEvVar/cache miss [W] cobox_a1bN :: a_a1bv ~ t_a18b
setEvBind
  ev = cobox_a1bx
  tm  = CO cobox_a1bM -> cobox_a1bN
canEvNC:eq
  Integer
  Integer
can_eq_nc
  [W] cobox_a1bM :: Integer ~ Integer
  Integer
  Integer
  Integer
  Integer
setEvBind
  ev = cobox_a1bM
  tm  = CO <Integer>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1bN :: a_a1bv
                                 ~ t_a18b [" a type equality Integer -> a_a1bv
                                                             ~
                                                             Integer
                                                             -> t_a18b " p4.hs:13:27] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1bN :: a_a1bv
                                  ~ t_a18b [" a type equality Integer -> a_a1bv
                                                              ~
                                                              Integer
                                                              -> t_a18b " p4.hs:13:27] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1bN :: a_a1bv ~ t_a18b [" a type equality Integer
                                                       -> a_a1bv
                                                       ~
                                                       Integer
                                                       -> t_a18b " p4.hs:13:27] (CNonCanonical)
canEvNC:eq
  a_a1bv
  t_a18b
can_eq_nc
  [W] cobox_a1bN :: a_a1bv ~ t_a18b
  a_a1bv
  a_a1bv
  t_a18b
  t_a18b
canEqTyVar
  a_a1bv
  t_a18b
  Not-swapped
Following bound tyvar t_a18b = a_a1bm
Following bound tyvar a_a1bm = a_a1bp
Following bound tyvar a_a1bp = a_a1bs
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1bN :: a_a1bv
                                  ~ a_a1bs [" a type equality Integer -> a_a1bv
                                                              ~
                                                              Integer
                                                              -> t_a18b " p4.hs:13:27] (CTyEqCan)
Sneaky unification:
  Unifies: a_a1bs := a_a1bv
  Coercion: a_a1bs ~ a_a1bv
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_a1bs := a_a1bv
setEvBind
  ev = cobox_a1bN
  tm  = CO <a_a1bv>_N
kickOutRewritable
  tv =  a_a1bs
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
9[<C:0,F:0>] [W] cobox_a1bN :: a_a1bv
                               ~ a_a1bs: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1bA :: (Integer -> a_a1by)
                                 ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1by
                                                                          ~
                                                                          Integer
                                                                          -> t_a18b " p4.hs:13:29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1bA :: (Integer -> a_a1by)
                                  ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1by
                                                                           ~
                                                                           Integer
                                                                           -> t_a18b " p4.hs:13:29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1bA :: (Integer -> a_a1by)
                    ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1by
                                                             ~
                                                             Integer
                                                             -> t_a18b " p4.hs:13:29] (CNonCanonical)
canEvNC:eq
  Integer -> a_a1by
  Integer -> t_a18b
can_eq_nc
  [W] cobox_a1bA :: (Integer -> a_a1by) ~ (Integer -> t_a18b)
  Integer -> a_a1by
  Integer -> a_a1by
  Integer -> t_a18b
  Integer -> t_a18b
newWantedEvVar/cache miss [W] cobox_a1bO :: Integer ~ Integer
newWantedEvVar/cache miss [W] cobox_a1bP :: a_a1by ~ t_a18b
setEvBind
  ev = cobox_a1bA
  tm  = CO cobox_a1bO -> cobox_a1bP
canEvNC:eq
  Integer
  Integer
can_eq_nc
  [W] cobox_a1bO :: Integer ~ Integer
  Integer
  Integer
  Integer
  Integer
setEvBind
  ev = cobox_a1bO
  tm  = CO <Integer>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1bP :: a_a1by
                                 ~ t_a18b [" a type equality Integer -> a_a1by
                                                             ~
                                                             Integer
                                                             -> t_a18b " p4.hs:13:29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1bP :: a_a1by
                                  ~ t_a18b [" a type equality Integer -> a_a1by
                                                              ~
                                                              Integer
                                                              -> t_a18b " p4.hs:13:29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1bP :: a_a1by ~ t_a18b [" a type equality Integer
                                                       -> a_a1by
                                                       ~
                                                       Integer
                                                       -> t_a18b " p4.hs:13:29] (CNonCanonical)
canEvNC:eq
  a_a1by
  t_a18b
can_eq_nc
  [W] cobox_a1bP :: a_a1by ~ t_a18b
  a_a1by
  a_a1by
  t_a18b
  t_a18b
canEqTyVar
  a_a1by
  t_a18b
  Not-swapped
Following bound tyvar t_a18b = a_a1bm
Following bound tyvar a_a1bm = a_a1bp
Following bound tyvar a_a1bp = a_a1bs
Following bound tyvar a_a1bs = a_a1bv
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1bP :: a_a1by
                                  ~ a_a1bv [" a type equality Integer -> a_a1by
                                                              ~
                                                              Integer
                                                              -> t_a18b " p4.hs:13:29] (CTyEqCan)
Sneaky unification:
  Unifies: a_a1bv := a_a1by
  Coercion: a_a1bv ~ a_a1by
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_a1bv := a_a1by
setEvBind
  ev = cobox_a1bP
  tm  = CO <a_a1by>_N
kickOutRewritable
  tv =  a_a1bv
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
11[<C:0,F:0>] [W] cobox_a1bP :: a_a1by
                                ~ a_a1bv: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1bD :: (Integer -> a_a1bB)
                                 ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bB
                                                                          ~
                                                                          Integer
                                                                          -> t_a18b " p4.hs:13:31] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1bD :: (Integer -> a_a1bB)
                                  ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bB
                                                                           ~
                                                                           Integer
                                                                           -> t_a18b " p4.hs:13:31] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1bD :: (Integer -> a_a1bB)
                    ~ (Integer -> t_a18b) [" a type equality Integer -> a_a1bB
                                                             ~
                                                             Integer
                                                             -> t_a18b " p4.hs:13:31] (CNonCanonical)
canEvNC:eq
  Integer -> a_a1bB
  Integer -> t_a18b
can_eq_nc
  [W] cobox_a1bD :: (Integer -> a_a1bB) ~ (Integer -> t_a18b)
  Integer -> a_a1bB
  Integer -> a_a1bB
  Integer -> t_a18b
  Integer -> t_a18b
newWantedEvVar/cache miss [W] cobox_a1bQ :: Integer ~ Integer
newWantedEvVar/cache miss [W] cobox_a1bR :: a_a1bB ~ t_a18b
setEvBind
  ev = cobox_a1bD
  tm  = CO cobox_a1bQ -> cobox_a1bR
canEvNC:eq
  Integer
  Integer
can_eq_nc
  [W] cobox_a1bQ :: Integer ~ Integer
  Integer
  Integer
  Integer
  Integer
setEvBind
  ev = cobox_a1bQ
  tm  = CO <Integer>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1bR :: a_a1bB
                                 ~ t_a18b [" a type equality Integer -> a_a1bB
                                                             ~
                                                             Integer
                                                             -> t_a18b " p4.hs:13:31] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1bR :: a_a1bB
                                  ~ t_a18b [" a type equality Integer -> a_a1bB
                                                              ~
                                                              Integer
                                                              -> t_a18b " p4.hs:13:31] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1bR :: a_a1bB ~ t_a18b [" a type equality Integer
                                                       -> a_a1bB
                                                       ~
                                                       Integer
                                                       -> t_a18b " p4.hs:13:31] (CNonCanonical)
canEvNC:eq
  a_a1bB
  t_a18b
can_eq_nc
  [W] cobox_a1bR :: a_a1bB ~ t_a18b
  a_a1bB
  a_a1bB
  t_a18b
  t_a18b
canEqTyVar
  a_a1bB
  t_a18b
  Not-swapped
Following bound tyvar t_a18b = a_a1bm
Following bound tyvar a_a1bm = a_a1bp
Following bound tyvar a_a1bp = a_a1bs
Following bound tyvar a_a1bs = a_a1bv
Following bound tyvar a_a1bv = a_a1by
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1bR :: a_a1bB
                                  ~ a_a1by [" a type equality Integer -> a_a1bB
                                                              ~
                                                              Integer
                                                              -> t_a18b " p4.hs:13:31] (CTyEqCan)
Sneaky unification:
  Unifies: a_a1by := a_a1bB
  Coercion: a_a1by ~ a_a1bB
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_a1by := a_a1bB
setEvBind
  ev = cobox_a1bR
  tm  = CO <a_a1bB>_N
kickOutRewritable
  tv =  a_a1by
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
13[<C:0,F:0>] [W] cobox_a1bR :: a_a1bB
                                ~ a_a1by: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dNum_a1bn :: Num
                                   a_a1bm [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_a1bn :: Num
                                    a_a1bm [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_a1bn :: Num
                      a_a1bm [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
canEvNC:cls Num [a_a1bm]
Following bound tyvar a_a1bm = a_a1bp
Following bound tyvar a_a1bp = a_a1bs
Following bound tyvar a_a1bs = a_a1bv
Following bound tyvar a_a1bv = a_a1by
Following bound tyvar a_a1by = a_a1bB
canClass
  [W] $dNum_a1bn :: Num a_a1bm Num [a_a1bm]
  Num a_a1bB
  Just [W] $dNum_a1bn :: Num a_a1bB
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_a1bn :: Num
                                    a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dNum_a1bn :: Num
                                    a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
doTopReact
  [W] $dNum_a1bn :: Num
                      a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
matchClassInst
  pred = Num a_a1bB
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 0
          Solved funeqs 0
  untouchables= 0
matchClass not matching dict Num a_a1bB
end stage top-level reactions }
14[<C:0,F:0>] [W] $dNum_a1bn :: Num a_a1bB: Kept as inert
End solver pipeline (not discharged) }
  final_item =  [W] $dNum_a1bn :: Num
                                    a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
  a_a1bB
  inerts     =  Equalities:
                Type-function equalities:
                No-eqs: True
                Dictionaries:
                Irreds:
                Insolubles = {}
                Solved dicts 0
                Solved funeqs 0
insertInertItemTcS {
  Trying to insert new inert item: [W] $dNum_a1bn :: Num
                                                       a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
insertInertItemTcS }
Start solver pipeline {
  work item =  [W] $dNum_a1bq :: Num
                                   a_a1bp [" the literal ‘4’ " p4.hs:13:23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_a1bn :: Num
                                                 a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_a1bq :: Num
                                    a_a1bp [" the literal ‘4’ " p4.hs:13:23] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_a1bq :: Num
                      a_a1bp [" the literal ‘4’ " p4.hs:13:23] (CNonCanonical)
canEvNC:cls Num [a_a1bp]
Following bound tyvar a_a1bp = a_a1bs
Following bound tyvar a_a1bs = a_a1bv
Following bound tyvar a_a1bv = a_a1by
Following bound tyvar a_a1by = a_a1bB
canClass
  [W] $dNum_a1bq :: Num a_a1bp Num [a_a1bp]
  Num a_a1bB
  Just [W] $dNum_a1bq :: Num a_a1bB
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_a1bq :: Num
                                    a_a1bB [" the literal ‘4’ " p4.hs:13:23] (CDictCan)
setEvBind
  ev = $dNum_a1bq
  tm  = $dNum_a1bn
15[<C:0,F:0>] [W] $dNum_a1bq :: Num a_a1bB: Dict equal (keep)
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_a1bn :: Num
                                                 a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dNum_a1bt :: Num
                                   a_a1bs [" the literal ‘6’ " p4.hs:13:25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_a1bn :: Num
                                                 a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_a1bt :: Num
                                    a_a1bs [" the literal ‘6’ " p4.hs:13:25] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_a1bt :: Num
                      a_a1bs [" the literal ‘6’ " p4.hs:13:25] (CNonCanonical)
canEvNC:cls Num [a_a1bs]
Following bound tyvar a_a1bs = a_a1bv
Following bound tyvar a_a1bv = a_a1by
Following bound tyvar a_a1by = a_a1bB
canClass
  [W] $dNum_a1bt :: Num a_a1bs Num [a_a1bs]
  Num a_a1bB
  Just [W] $dNum_a1bt :: Num a_a1bB
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_a1bt :: Num
                                    a_a1bB [" the literal ‘6’ " p4.hs:13:25] (CDictCan)
setEvBind
  ev = $dNum_a1bt
  tm  = $dNum_a1bn
16[<C:0,F:0>] [W] $dNum_a1bt :: Num a_a1bB: Dict equal (keep)
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_a1bn :: Num
                                                 a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dNum_a1bw :: Num
                                   a_a1bv [" the literal ‘3’ " p4.hs:13:27] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_a1bn :: Num
                                                 a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_a1bw :: Num
                                    a_a1bv [" the literal ‘3’ " p4.hs:13:27] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_a1bw :: Num
                      a_a1bv [" the literal ‘3’ " p4.hs:13:27] (CNonCanonical)
canEvNC:cls Num [a_a1bv]
Following bound tyvar a_a1bv = a_a1by
Following bound tyvar a_a1by = a_a1bB
canClass
  [W] $dNum_a1bw :: Num a_a1bv Num [a_a1bv]
  Num a_a1bB
  Just [W] $dNum_a1bw :: Num a_a1bB
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_a1bw :: Num
                                    a_a1bB [" the literal ‘3’ " p4.hs:13:27] (CDictCan)
setEvBind
  ev = $dNum_a1bw
  tm  = $dNum_a1bn
17[<C:0,F:0>] [W] $dNum_a1bw :: Num a_a1bB: Dict equal (keep)
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_a1bn :: Num
                                                 a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dNum_a1bz :: Num
                                   a_a1by [" the literal ‘2’ " p4.hs:13:29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_a1bn :: Num
                                                 a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_a1bz :: Num
                                    a_a1by [" the literal ‘2’ " p4.hs:13:29] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_a1bz :: Num
                      a_a1by [" the literal ‘2’ " p4.hs:13:29] (CNonCanonical)
canEvNC:cls Num [a_a1by]
Following bound tyvar a_a1by = a_a1bB
canClass
  [W] $dNum_a1bz :: Num a_a1by Num [a_a1by]
  Num a_a1bB
  Just [W] $dNum_a1bz :: Num a_a1bB
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_a1bz :: Num
                                    a_a1bB [" the literal ‘2’ " p4.hs:13:29] (CDictCan)
setEvBind
  ev = $dNum_a1bz
  tm  = $dNum_a1bn
18[<C:0,F:0>] [W] $dNum_a1bz :: Num a_a1bB: Dict equal (keep)
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_a1bn :: Num
                                                 a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dNum_a1bC :: Num
                                   a_a1bB [" the literal ‘5’ " p4.hs:13:31] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_a1bn :: Num
                                                 a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_a1bC :: Num
                                    a_a1bB [" the literal ‘5’ " p4.hs:13:31] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_a1bC :: Num
                      a_a1bB [" the literal ‘5’ " p4.hs:13:31] (CNonCanonical)
canEvNC:cls Num [a_a1bB]
canClass
  [W] $dNum_a1bC :: Num a_a1bB Num [a_a1bB]
  Num a_a1bB
  Just [W] $dNum_a1bC :: Num a_a1bB
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_a1bC :: Num
                                    a_a1bB [" the literal ‘5’ " p4.hs:13:31] (CDictCan)
setEvBind
  ev = $dNum_a1bC
  tm  = $dNum_a1bn
19[<C:0,F:0>] [W] $dNum_a1bC :: Num a_a1bB: Dict equal (keep)
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dNum_a1bn :: Num
                                                 a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
solveFlats end } {}
simpl_loop, iteration 1
solveWanteds }
  unsolved_flats   = {[W] $dNum_a1bn :: Num
                                          a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CDictCan)}
  unsolved_implics = {}
  current evbinds  = {cobox_a18c = CO Sym cobox_a1bF,
                      cobox_a1bo = CO cobox_a1bG -> cobox_a1bH, $dNum_a1bq = $dNum_a1bn,
                      cobox_a1br = CO cobox_a1bI -> cobox_a1bJ, $dNum_a1bt = $dNum_a1bn,
                      cobox_a1bu = CO cobox_a1bK -> cobox_a1bL, $dNum_a1bw = $dNum_a1bn,
                      cobox_a1bx = CO cobox_a1bM -> cobox_a1bN, $dNum_a1bz = $dNum_a1bn,
                      cobox_a1bA = CO cobox_a1bO -> cobox_a1bP, $dNum_a1bC = $dNum_a1bn,
                      cobox_a1bD = CO cobox_a1bQ -> cobox_a1bR,
                      cobox_a1bF = CO <[t_a18b]>_N, cobox_a1bG = CO <Integer>_N,
                      cobox_a1bH = CO <a_a1bm>_N, cobox_a1bI = CO <Integer>_N,
                      cobox_a1bJ = CO <a_a1bp>_N, cobox_a1bK = CO <Integer>_N,
                      cobox_a1bL = CO <a_a1bs>_N, cobox_a1bM = CO <Integer>_N,
                      cobox_a1bN = CO <a_a1bv>_N, cobox_a1bO = CO <Integer>_N,
                      cobox_a1bP = CO <a_a1by>_N, cobox_a1bQ = CO <Integer>_N,
                      cobox_a1bR = CO <a_a1bB>_N}
  current tybinds  = (t_a189, [t_a18b])
                     (t_a18b, a_a1bm)
                     (a_a1bm, a_a1bp)
                     (a_a1bp, a_a1bs)
                     (a_a1bs, a_a1bv)
                     (a_a1bv, a_a1by)
                     (a_a1by, a_a1bB)
  final wc = WC {wc_flat = [W] $dNum_a1bn :: Num
                                               a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CDictCan)}
writeMetaTyVar t_a189 := [t_a18b]
writeMetaTyVar t_a18b := a_a1bm
writeMetaTyVar a_a1bm := a_a1bp
writeMetaTyVar a_a1bp := a_a1bs
writeMetaTyVar a_a1bs := a_a1bv
writeMetaTyVar a_a1bv := a_a1by
writeMetaTyVar a_a1by := a_a1bB
Constraint solver steps = 19
Start solver pipeline {
  work item =  [W] $dNum_a1bn :: Num
                                   a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_a1bn :: Num
                                    a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_a1bn :: Num
                      a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
canEvNC:cls Num [a_a1bB]
canClass
  [W] $dNum_a1bn :: Num a_a1bB Num [a_a1bB]
  Num a_a1bB
  Just [W] $dNum_a1bn :: Num a_a1bB
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_a1bn :: Num
                                    a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dNum_a1bn :: Num
                                    a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
doTopReact
  [W] $dNum_a1bn :: Num
                      a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
matchClassInst
  pred = Num a_a1bB
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 0
          Solved funeqs 0
  untouchables= 0
matchClass not matching dict Num a_a1bB
end stage top-level reactions }
1[<C:0,F:0>] [W] $dNum_a1bn :: Num a_a1bB: Kept as inert
End solver pipeline (not discharged) }
  final_item =  [W] $dNum_a1bn :: Num
                                    a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
  a_a1bB
  inerts     =  Equalities:
                Type-function equalities:
                No-eqs: True
                Dictionaries:
                Irreds:
                Insolubles = {}
                Solved dicts 0
                Solved funeqs 0
insertInertItemTcS {
  Trying to insert new inert item: [W] $dNum_a1bn :: Num
                                                       a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
insertInertItemTcS }
Constraint solver steps = 1
simplifyWithApprox
  quant_pred_candidates = [Num a_a1bB]
  gbl_tvs= []
  zonked_tau_tvs= [(a1bB, a_a1bB)]
  pbound = [Num a_a1bB]
  bbound = []
  poly_qtvs = [(a1bB, a_a1bB)]
  constrained_tvs = [(a1bB, a_a1bB)]
  mr_bites = True
  qtvs = []
} simplifyInfer/no implication needed
addInlinePrags
  sL
  []
mkExport: check sig
  sL
  [a_a1bB]
  [a_a1bB]
u_tys 
  untch 0
  [a_a1bB] ~ [a_a1bB]
  a type equality [a_a1bB] ~ [a_a1bB]
u_tys 
  untch 0
  a_a1bB ~ a_a1bB
  a type equality [a_a1bB] ~ [a_a1bB]
u_tys yields no coercion
u_tys yields no coercion
simplifyTop { wanted =  WC {}
solveWantedsTcMWithEvBinds wanted= WC {}
solveWanteds { WC {}
solveFlats {
solveFlats end } {}
simpl_loop, iteration 1
solveWanteds }
  unsolved_flats   = {}
  unsolved_implics = {}
  current evbinds  = {}
  current tybinds  =
  final wc = WC {}
End simplifyTop }
reportUnsolved {
reportUnsolved }
Binding:
  <NotTopLevel>
  [(sL, [a_a1bB])]
csb2 [sL]
} End of bindings for
  [sL]
  NonRecursive
  sL [a_a1bB]
env2 [(sL, Identifier[sL::[a_a1bB], <NotTopLevel>])]
------------------------------------------------
Bindings for { [dim]
Generalisation plan InferGen True False
tcMatchesFun
  dim
  t_a1cf
tcGen
tcBody t_a1cf
Instantiating
  length with [a_a1ci]
              []
utype_defer
  cobox_a1cj
  Int
  t_a1cf
  a type equality Int ~ t_a1cf
  In the expression: length sL
  In an equation for ‘dim’: dim = length sL
tcPolyExprNC [a_a1ci]
tcGen
utype_defer
  cobox_a1ck
  [a_a1bB]
  [a_a1ci]
  a type equality [a_a1bB] ~ [a_a1ci]
  In the first argument of ‘length’, namely ‘sL’
  In the expression: length sL
simplifyInfer call
  [(dim, t_a1cf)]
  WC {wc_flat = [W] cobox_a1cj :: Int ~ t_a1cf [" a type equality Int
                                                                  ~
                                                                  t_a1cf " p4.hs:14:21-29] (CNonCanonical)
                [W] cobox_a1ck :: [a_a1bB] ~ [a_a1ci] [" a type equality [a_a1bB]
                                                                         ~
                                                                         [a_a1ci] " p4.hs:14:28-29] (CNonCanonical)}
simplifyInfer {
  binds = [(dim, t_a1cf)]
  closed = False
  apply_mr = True
  (unzonked) wanted = WC {wc_flat = [W] cobox_a1cj :: Int
                                                      ~ t_a1cf [" a type equality Int
                                                                                  ~
                                                                                  t_a1cf " p4.hs:14:21-29] (CNonCanonical)
                                    [W] cobox_a1ck :: [a_a1bB]
                                                      ~ [a_a1ci] [" a type equality [a_a1bB]
                                                                                    ~
                                                                                    [a_a1ci] " p4.hs:14:28-29] (CNonCanonical)}
solveWantedsTcMWithEvBinds
  wanted= WC {wc_flat = [W] cobox_a1cj :: Int
                                          ~ t_a1cf [" a type equality Int
                                                                      ~
                                                                      t_a1cf " p4.hs:14:21-29] (CNonCanonical)
                        [W] cobox_a1ck :: [a_a1bB] ~ [a_a1ci] [" a type equality [a_a1bB]
                                                                                 ~
                                                                                 [a_a1ci] " p4.hs:14:28-29] (CNonCanonical)}
solveWanteds {
  WC {wc_flat = [W] cobox_a1cj :: Int ~ t_a1cf [" a type equality Int
                                                                  ~
                                                                  t_a1cf " p4.hs:14:21-29] (CNonCanonical)
                [W] cobox_a1ck :: [a_a1bB] ~ [a_a1ci] [" a type equality [a_a1bB]
                                                                         ~
                                                                         [a_a1ci] " p4.hs:14:28-29] (CNonCanonical)}
solveFlats {
Start solver pipeline {
  work item =  [W] cobox_a1cj :: Int ~ t_a1cf [" a type equality Int
                                                                 ~
                                                                 t_a1cf " p4.hs:14:21-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1cj :: Int ~ t_a1cf [" a type equality Int
                                                                  ~
                                                                  t_a1cf " p4.hs:14:21-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1cj :: Int ~ t_a1cf [" a type equality Int
                                                    ~
                                                    t_a1cf " p4.hs:14:21-29] (CNonCanonical)
canEvNC:eq
  Int
  t_a1cf
can_eq_nc
  [W] cobox_a1cj :: Int ~ t_a1cf
  Int
  Int
  t_a1cf
  t_a1cf
canEqTyVar
  t_a1cf
  Int
  Is-swapped
newWantedEvVar/cache miss [W] cobox_a1cm :: t_a1cf ~ Int
setEvBind
  ev = cobox_a1cj
  tm  = CO Sym cobox_a1cm
rewriteEqEvidence
  [W] cobox_a1cj :: Int ~ t_a1cf
  t_a1cf
  Int
  Sym cobox_a1cm
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1cm :: t_a1cf ~ Int [" a type equality Int
                                                                  ~
                                                                  t_a1cf " p4.hs:14:21-29] (CTyEqCan)
Sneaky unification:
  Unifies: t_a1cf := Int
  Coercion: t_a1cf ~ Int
  Left Kind is: OpenKind
  Right Kind is: *
setWantedTyBind t_a1cf := Int
setEvBind
  ev = cobox_a1cm
  tm  = CO <Int>_N
kickOutRewritable
  tv =  t_a1cf
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
1[<C:0,F:0>] [W] cobox_a1cm :: t_a1cf ~ Int: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1ck :: [a_a1bB]
                                 ~ [a_a1ci] [" a type equality [a_a1bB]
                                                               ~
                                                               [a_a1ci] " p4.hs:14:28-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1ck :: [a_a1bB]
                                  ~ [a_a1ci] [" a type equality [a_a1bB]
                                                                ~
                                                                [a_a1ci] " p4.hs:14:28-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1ck :: [a_a1bB] ~ [a_a1ci] [" a type equality [a_a1bB]
                                                           ~
                                                           [a_a1ci] " p4.hs:14:28-29] (CNonCanonical)
canEvNC:eq
  [a_a1bB]
  [a_a1ci]
can_eq_nc
  [W] cobox_a1ck :: [a_a1bB] ~ [a_a1ci]
  [a_a1bB]
  [a_a1bB]
  [a_a1ci]
  [a_a1ci]
newWantedEvVar/cache miss [W] cobox_a1cn :: a_a1bB ~ a_a1ci
setEvBind
  ev = cobox_a1ck
  tm  = CO [cobox_a1cn]_N
canEvNC:eq
  a_a1bB
  a_a1ci
can_eq_nc
  [W] cobox_a1cn :: a_a1bB ~ a_a1ci
  a_a1bB
  a_a1bB
  a_a1ci
  a_a1ci
canEqTyVar
  a_a1bB
  a_a1ci
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1cn :: a_a1bB
                                  ~ a_a1ci [" a type equality [a_a1bB]
                                                              ~
                                                              [a_a1ci] " p4.hs:14:28-29] (CTyEqCan)
Sneaky unification:
  Unifies: a_a1ci := a_a1bB
  Coercion: a_a1ci ~ a_a1bB
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_a1ci := a_a1bB
setEvBind
  ev = cobox_a1cn
  tm  = CO <a_a1bB>_N
kickOutRewritable
  tv =  a_a1ci
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
2[<C:0,F:0>] [W] cobox_a1cn :: a_a1bB
                               ~ a_a1ci: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
solveFlats end } {}
simpl_loop, iteration 1
solveWanteds }
  unsolved_flats   = {}
  unsolved_implics = {}
  current evbinds  = {cobox_a1cj = CO Sym cobox_a1cm,
                      cobox_a1ck = CO [cobox_a1cn]_N, cobox_a1cm = CO <Int>_N,
                      cobox_a1cn = CO <a_a1bB>_N}
  current tybinds  = (t_a1cf, Int)
                     (a_a1ci, a_a1bB)
  final wc = WC {}
writeMetaTyVar t_a1cf := Int
writeMetaTyVar a_a1ci := a_a1bB
Constraint solver steps = 2
simplifyWithApprox
  quant_pred_candidates = []
  gbl_tvs= [(a1bB, a_a1bB)]
  zonked_tau_tvs= []
  pbound = []
  bbound = []
  poly_qtvs = []
  constrained_tvs = [(a1bB, a_a1bB)]
  mr_bites = False
  qtvs = []
} simplifyInfer/no implication needed
addInlinePrags
  dim
  []
mkExport: check sig
  dim
  Int
  Int
u_tys 
  untch 0
  Int ~ Int
  a type equality Int ~ Int
u_tys yields no coercion
simplifyTop { wanted =  WC {}
solveWantedsTcMWithEvBinds wanted= WC {}
solveWanteds { WC {}
solveFlats {
solveFlats end } {}
simpl_loop, iteration 1
solveWanteds }
  unsolved_flats   = {}
  unsolved_implics = {}
  current evbinds  = {}
  current tybinds  =
  final wc = WC {}
End simplifyTop }
reportUnsolved {
reportUnsolved }
Binding:
  <NotTopLevel>
  [(dim, Int)]
csb2 [dim]
} End of bindings for
  [dim]
  NonRecursive
  dim Int
env2 [(dim, Identifier[dim::Int, <NotTopLevel>])]
------------------------------------------------
Bindings for { [help]
Generalisation plan
  CheckGen help :: [FlatVector]
                   []
env2 []
tcMonoBinds
env2 []
tcRhs: fun bind
  help
  [FlatVector]
tcMatchesFun
  help
  [FlatVector]
tcGen
tcBody [FlatVector]
utype_defer
  cobox_a1ct
  [a_a1bB]
  [t_a1cs]
  a type equality [a_a1bB] ~ [t_a1cs]
  In the expression: sL
  In a stmt of a list comprehension: s <- sL
env2 [(s, Identifier[s::t_a1cs, <NotTopLevel>])]
utype_defer
  cobox_a1cu
  FlatVector
  FlatVector
  a type equality FlatVector ~ FlatVector
  In the expression: listFlatVector (1, s) [0 | i <- [1 .. s]]
  In the expression:
    [listFlatVector (1, s) [0 | i <- [1 .. s]] | s <- sL]
tcPolyExprNC (Int, Int)
tcGen
tcPolyExpr Int
tcPolyExprNC Int
tcGen
tcPolyExpr Int
tcPolyExprNC Int
tcGen
utype_defer
  cobox_a1cv
  t_a1cs
  Int
  a type equality t_a1cs ~ Int
  In the expression: s
  In the first argument of ‘listFlatVector’, namely ‘(1, s)’
tcPolyExprNC [Double]
tcGen
tcPolyExpr t_a1cw
tcPolyExprNC t_a1cw
tcGen
Instantiating
  fromInteger with [a_a1cx]
                   [Num a_a1cx]
instCallConstraints [$dNum_a1cy]
utype_defer
  cobox_a1cz
  Integer -> a_a1cx
  Integer -> t_a1cw
  a type equality Integer -> a_a1cx ~ Integer -> t_a1cw
  In the expression: 1
  In the expression: [1 .. s]
  In a stmt of a list comprehension: i <- [1 .. s]
tcPolyExpr t_a1cw
tcPolyExprNC t_a1cw
tcGen
utype_defer
  cobox_a1cA
  t_a1cs
  t_a1cw
  a type equality t_a1cs ~ t_a1cw
  In the expression: s
  In the expression: [1 .. s]
instCallConstraints [$dEnum_a1jn]
env2 [(i, Identifier[i::t_a1cw, <NotTopLevel>])]
addInlinePrags
  help
  []
csb2 [help]
} End of bindings for
  [help]
  NonRecursive
  help [FlatVector]
env2 [(help, Identifier[help::[FlatVector], <TopLevel>])]
------------------------------------------------
Bindings for { [tmp]
Generalisation plan
  CheckGen tmp :: Vector FlatVector
                  []
env2 []
tcMonoBinds
env2 []
tcRhs: fun bind
  tmp
  Vector FlatVector
tcMatchesFun
  tmp
  Vector FlatVector
tcGen
tcBody Vector FlatVector
Instantiating
  listVector with [a_a1jp]
                  []
utype_defer
  cobox_a1jq
  Vector a_a1jp
  Vector FlatVector
  a type equality Vector a_a1jp ~ Vector FlatVector
  In the expression: listVector (1, dim) help
  In an equation for ‘tmp’: tmp = listVector (1, dim) help
tcPolyExprNC (Int, Int)
tcGen
tcPolyExpr Int
tcPolyExprNC Int
tcGen
tcPolyExpr Int
tcPolyExprNC Int
tcGen
utype_defer
  cobox_a1jr
  Int
  Int
  a type equality Int ~ Int
  In the expression: dim
  In the first argument of ‘listVector’, namely ‘(1, dim)’
tcPolyExprNC [a_a1jp]
tcGen
utype_defer
  cobox_a1js
  [FlatVector]
  [a_a1jp]
  a type equality [FlatVector] ~ [a_a1jp]
  In the second argument of ‘listVector’, namely ‘help’
  In the expression: listVector (1, dim) help
addInlinePrags
  tmp
  []
csb2 [tmp]
} End of bindings for
  [tmp]
  NonRecursive
  tmp Vector FlatVector
env2 [(tmp, Identifier[tmp::Vector FlatVector, <TopLevel>])]
Instantiating
  >>= with [m_a1jy]
           [Monad m_a1jy]
instCallConstraints [$dMonad_a1jz]
utype_defer
  cobox_a1jD
  m_a1jy a_a1jA -> (a_a1jA -> m_a1jy b_a1jB) -> m_a1jy b_a1jB
  t_a1jt -> (t_a1ju -> t_a1jv) -> IO ()
  a type equality m_a1jy a_a1jA
                  -> (a_a1jA -> m_a1jy b_a1jB) -> m_a1jy b_a1jB
                  ~
                  t_a1jt -> (t_a1ju -> t_a1jv) -> IO ()
  In a stmt of a 'do' block: v <- thaw tmp
  In the expression:
    do { let sL = [1, 4, 6, 3, 2, 5]
             dim = length sL
             help :: [FlatVector]
             help = [listFlatVector (1, s) [0 | i <- [1 .. s]] | s <- sL]
             tmp :: Vector FlatVector
             tmp = listVector (1, dim) help;
         v <- thaw tmp;
         return () }
  In an equation for ‘main’:
      main
        = do { let sL = [1, 4, 6, 3, 2, 5]
                   dim = length sL
                   help :: [FlatVector]
                   help = [listFlatVector (1, s) [0 | i <- [1 .. s]] | s <- sL]
                   tmp :: Vector FlatVector
                   tmp = listVector (1, dim) help;
               v <- thaw tmp;
               return () }
Instantiating
  thaw with [a_a1jX, i_a1jY, e_a1jZ, m_a1k0, b_a1k1]
            [GHC.Arr.Ix i_a1jY, Data.Array.Base.IArray a_a1jX e_a1jZ,
             Data.Array.Base.MArray b_a1k1 e_a1jZ m_a1k0]
instCallConstraints [$dIx_a1k2, $dIArray_a1k3, $dMArray_a1k4]
utype_defer
  cobox_a1k5
  m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
  t_a1jt
  a type equality m_a1k0 (b_a1k1 i_a1jY e_a1jZ) ~ t_a1jt
  In a stmt of a 'do' block: v <- thaw tmp
  In the expression:
    do { let sL = [1, 4, 6, 3, 2, 5]
             dim = length sL
             help :: [FlatVector]
             help = [listFlatVector (1, s) [0 | i <- [1 .. s]] | s <- sL]
             tmp :: Vector FlatVector
             tmp = listVector (1, dim) help;
         v <- thaw tmp;
         return () }
tcPolyExprNC a_a1jX i_a1jY e_a1jZ
tcGen
utype_defer
  cobox_a1k6
  Vector FlatVector
  a_a1jX i_a1jY e_a1jZ
  a type equality Vector FlatVector ~ a_a1jX i_a1jY e_a1jZ
  In the first argument of ‘thaw’, namely ‘tmp’
  In a stmt of a 'do' block: v <- thaw tmp
env2 [(v, Identifier[v::t_a1ju, <NotTopLevel>])]
Instantiating
  return with [m_a1k8]
              [Monad m_a1k8]
instCallConstraints [$dMonad_a1k9]
utype_defer
  cobox_a1kc
  m_a1k8 a_a1ka
  t_a1jv
  a type equality m_a1k8 a_a1ka ~ t_a1jv
  In a stmt of a 'do' block: return ()
  In the expression:
    do { let sL = [1, 4, 6, 3, 2, 5]
             dim = length sL
             help :: [FlatVector]
             help = [listFlatVector (1, s) [0 | i <- [1 .. s]] | s <- sL]
             tmp :: Vector FlatVector
             tmp = listVector (1, dim) help;
         v <- thaw tmp;
         return () }
tcPolyExprNC a_a1ka
tcGen
utype_defer
  cobox_a1kd
  ()
  a_a1ka
  a type equality () ~ a_a1ka
  In the first argument of ‘return’, namely ‘()’
  In a stmt of a 'do' block: return ()
addInlinePrags
  main
  []
csb2 [main]
} End of bindings for
  [main]
  NonRecursive
  main IO ()
env2 [(main, Identifier[main::IO (), <TopLevel>])]
Tc6
env2 []
Tc7
End of tcVectDecls: LIE:
  WC {wc_flat = [W] $dIArray_a184 :: Data.Array.Base.IArray
                                       a_a183
                                       e_a182 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                [W] $dIx_a185 :: GHC.Arr.Ix
                                   i_a181 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                [W] cobox_a186 :: ((i_a181, i_a181)
                                   -> [e_a182] -> a_a183 i_a181 e_a182)
                                  ~ ((Int, Int)
                                     -> [Double] -> FlatVector) [" a type equality (i_a181, i_a181)
                                                                                   -> [e_a182]
                                                                                   -> a_a183 i_a181 e_a182
                                                                                   ~
                                                                                   (Int, Int)
                                                                                   -> [Double]
                                                                                   -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
                [W] $dNum_a1bn :: Num
                                    a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                [W] cobox_a1ct :: [a_a1bB] ~ [t_a1cs] [" a type equality [a_a1bB]
                                                                         ~
                                                                         [t_a1cs] " p4.hs:16:61-62] (CNonCanonical)
                [W] cobox_a1cu :: FlatVector
                                  ~ FlatVector [" a type equality FlatVector
                                                                  ~
                                                                  FlatVector " p4.hs:16:23-56] (CNonCanonical)
                [W] cobox_a1cv :: t_a1cs ~ Int [" a type equality t_a1cs
                                                                  ~
                                                                  Int " p4.hs:16:41] (CNonCanonical)
                [W] $dNum_a1cy :: Num
                                    a_a1cx [" the literal ‘1’ " p4.hs:16:51] (CNonCanonical)
                [W] cobox_a1cz :: (Integer -> a_a1cx)
                                  ~ (Integer -> t_a1cw) [" a type equality Integer -> a_a1cx
                                                                           ~
                                                                           Integer
                                                                           -> t_a1cw " p4.hs:16:51] (CNonCanonical)
                [W] cobox_a1cA :: t_a1cs ~ t_a1cw [" a type equality t_a1cs
                                                                     ~
                                                                     t_a1cw " p4.hs:16:54] (CNonCanonical)
                [W] $dEnum_a1jn :: Enum
                                     t_a1cw [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CNonCanonical)
                [W] cobox_a1jq :: Vector a_a1jp
                                  ~ Vector FlatVector [" a type equality Vector a_a1jp
                                                                         ~
                                                                         Vector
                                                                           FlatVector " p4.hs:18:21-43] (CNonCanonical)
                [W] cobox_a1jr :: Int ~ Int [" a type equality Int
                                                               ~
                                                               Int " p4.hs:18:35-37] (CNonCanonical)
                [W] cobox_a1js :: [FlatVector]
                                  ~ [a_a1jp] [" a type equality [FlatVector]
                                                                ~
                                                                [a_a1jp] " p4.hs:18:40-43] (CNonCanonical)
                [W] $dMonad_a1jz :: Monad
                                      m_a1jy [" a do statement " p4.hs:19:11-23] (CNonCanonical)
                [W] cobox_a1jD :: (m_a1jy a_a1jA
                                   -> (a_a1jA -> m_a1jy b_a1jB) -> m_a1jy b_a1jB)
                                  ~ (t_a1jt
                                     -> (t_a1ju -> t_a1jv)
                                     -> IO ()) [" a type equality m_a1jy a_a1jA
                                                                  -> (a_a1jA -> m_a1jy b_a1jB)
                                                                  -> m_a1jy b_a1jB
                                                                  ~
                                                                  t_a1jt
                                                                  -> (t_a1ju -> t_a1jv)
                                                                  -> IO
                                                                       () " p4.hs:19:11-23] (CNonCanonical)
                [W] $dIx_a1k2 :: GHC.Arr.Ix
                                   i_a1jY [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                [W] $dIArray_a1k3 :: Data.Array.Base.IArray
                                       a_a1jX
                                       e_a1jZ [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                [W] $dMArray_a1k4 :: Data.Array.Base.MArray
                                       b_a1k1
                                       e_a1jZ
                                       m_a1k0 [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                [W] cobox_a1k5 :: m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
                                  ~ t_a1jt [" a type equality m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
                                                              ~
                                                              t_a1jt " p4.hs:19:16-23] (CNonCanonical)
                [W] cobox_a1k6 :: Vector FlatVector
                                  ~ a_a1jX i_a1jY e_a1jZ [" a type equality Vector FlatVector
                                                                            ~
                                                                            a_a1jX i_a1jY e_a1jZ " p4.hs:19:21-23] (CNonCanonical)
                [W] $dMonad_a1k9 :: Monad
                                      m_a1k8 [" a use of ‘return’ " p4.hs:20:11-16] (CNonCanonical)
                [W] cobox_a1kc :: m_a1k8 a_a1ka
                                  ~ t_a1jv [" a type equality m_a1k8 a_a1ka
                                                              ~
                                                              t_a1jv " p4.hs:20:11-19] (CNonCanonical)
                [W] cobox_a1kd :: () ~ a_a1ka [" a type equality ()
                                                                 ~
                                                                 a_a1ka " p4.hs:20:18-19] (CNonCanonical)
      wc_impl = Implic {Untouchables = 1
                        Skolems = a
                        Flatten-skolems =
                        No-eqs = False
                        Given =
                        Wanted = WC {wc_flat = [W] $dIArray_a17W :: Data.Array.Base.IArray
                                                                      a_a17V
                                                                      e_a17U [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                               [W] $dIx_a17X :: GHC.Arr.Ix
                                                                  i_a17T [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                               [W] cobox_a17Y :: ((i_a17T, i_a17T)
                                                                  -> [e_a17U]
                                                                  -> a_a17V i_a17T e_a17U)
                                                                 ~ ((Int, Int)
                                                                    -> [a]
                                                                    -> Vector
                                                                         a) [" a type equality (i_a17T,
                                                                                                i_a17T)
                                                                                               -> [e_a17U]
                                                                                               -> a_a17V i_a17T e_a17U
                                                                                               ~
                                                                                               (Int,
                                                                                                Int)
                                                                                               -> [a]
                                                                                               -> Vector
                                                                                                    a " p4.hs:30:14-25] (CNonCanonical)}
                        Binds = EvBindsVar<a17Z>
                        the type signature for
                          listVector :: (Int, Int) -> [a] -> Vector a}}
Tc7a
checkMain found Main main
utype_defer
  cobox_a1kf
  IO ()
  IO t_a1ke
  a type equality IO () ~ IO t_a1ke
  In the expression: main
  When checking the type of the IO action ‘main’
Tc8
simplifyTop {
  wanted =  WC {wc_flat = [W] $dIArray_a184 :: Data.Array.Base.IArray
                                                 a_a183
                                                 e_a182 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                          [W] $dIx_a185 :: GHC.Arr.Ix
                                             i_a181 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                          [W] cobox_a186 :: ((i_a181, i_a181)
                                             -> [e_a182] -> a_a183 i_a181 e_a182)
                                            ~ ((Int, Int)
                                               -> [Double]
                                               -> FlatVector) [" a type equality (i_a181, i_a181)
                                                                                 -> [e_a182]
                                                                                 -> a_a183 i_a181 e_a182
                                                                                 ~
                                                                                 (Int, Int)
                                                                                 -> [Double]
                                                                                 -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
                          [W] $dNum_a1bn :: Num
                                              a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                          [W] cobox_a1ct :: [a_a1bB] ~ [t_a1cs] [" a type equality [a_a1bB]
                                                                                   ~
                                                                                   [t_a1cs] " p4.hs:16:61-62] (CNonCanonical)
                          [W] cobox_a1cu :: FlatVector
                                            ~ FlatVector [" a type equality FlatVector
                                                                            ~
                                                                            FlatVector " p4.hs:16:23-56] (CNonCanonical)
                          [W] cobox_a1cv :: t_a1cs ~ Int [" a type equality t_a1cs
                                                                            ~
                                                                            Int " p4.hs:16:41] (CNonCanonical)
                          [W] $dNum_a1cy :: Num
                                              a_a1cx [" the literal ‘1’ " p4.hs:16:51] (CNonCanonical)
                          [W] cobox_a1cz :: (Integer -> a_a1cx)
                                            ~ (Integer -> t_a1cw) [" a type equality Integer
                                                                                     -> a_a1cx
                                                                                     ~
                                                                                     Integer
                                                                                     -> t_a1cw " p4.hs:16:51] (CNonCanonical)
                          [W] cobox_a1cA :: t_a1cs ~ t_a1cw [" a type equality t_a1cs
                                                                               ~
                                                                               t_a1cw " p4.hs:16:54] (CNonCanonical)
                          [W] $dEnum_a1jn :: Enum
                                               t_a1cw [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CNonCanonical)
                          [W] cobox_a1jq :: Vector a_a1jp
                                            ~ Vector FlatVector [" a type equality Vector a_a1jp
                                                                                   ~
                                                                                   Vector
                                                                                     FlatVector " p4.hs:18:21-43] (CNonCanonical)
                          [W] cobox_a1jr :: Int ~ Int [" a type equality Int
                                                                         ~
                                                                         Int " p4.hs:18:35-37] (CNonCanonical)
                          [W] cobox_a1js :: [FlatVector]
                                            ~ [a_a1jp] [" a type equality [FlatVector]
                                                                          ~
                                                                          [a_a1jp] " p4.hs:18:40-43] (CNonCanonical)
                          [W] $dMonad_a1jz :: Monad
                                                m_a1jy [" a do statement " p4.hs:19:11-23] (CNonCanonical)
                          [W] cobox_a1jD :: (m_a1jy a_a1jA
                                             -> (a_a1jA -> m_a1jy b_a1jB) -> m_a1jy b_a1jB)
                                            ~ (t_a1jt
                                               -> (t_a1ju -> t_a1jv)
                                               -> IO ()) [" a type equality m_a1jy a_a1jA
                                                                            -> (a_a1jA
                                                                                -> m_a1jy b_a1jB)
                                                                            -> m_a1jy b_a1jB
                                                                            ~
                                                                            t_a1jt
                                                                            -> (t_a1ju -> t_a1jv)
                                                                            -> IO
                                                                                 () " p4.hs:19:11-23] (CNonCanonical)
                          [W] $dIx_a1k2 :: GHC.Arr.Ix
                                             i_a1jY [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                          [W] $dIArray_a1k3 :: Data.Array.Base.IArray
                                                 a_a1jX
                                                 e_a1jZ [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                          [W] $dMArray_a1k4 :: Data.Array.Base.MArray
                                                 b_a1k1
                                                 e_a1jZ
                                                 m_a1k0 [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                          [W] cobox_a1k5 :: m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
                                            ~ t_a1jt [" a type equality m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
                                                                        ~
                                                                        t_a1jt " p4.hs:19:16-23] (CNonCanonical)
                          [W] cobox_a1k6 :: Vector FlatVector
                                            ~ a_a1jX i_a1jY e_a1jZ [" a type equality Vector
                                                                                        FlatVector
                                                                                      ~
                                                                                      a_a1jX i_a1jY e_a1jZ " p4.hs:19:21-23] (CNonCanonical)
                          [W] $dMonad_a1k9 :: Monad
                                                m_a1k8 [" a use of ‘return’ " p4.hs:20:11-16] (CNonCanonical)
                          [W] cobox_a1kc :: m_a1k8 a_a1ka
                                            ~ t_a1jv [" a type equality m_a1k8 a_a1ka
                                                                        ~
                                                                        t_a1jv " p4.hs:20:11-19] (CNonCanonical)
                          [W] cobox_a1kd :: () ~ a_a1ka [" a type equality ()
                                                                           ~
                                                                           a_a1ka " p4.hs:20:18-19] (CNonCanonical)
                          [W] cobox_a1kf :: IO () ~ IO t_a1ke [" a type equality IO ()
                                                                                 ~
                                                                                 IO
                                                                                   t_a1ke " p4.hs:13:1] (CNonCanonical)
                wc_impl = Implic {Untouchables = 1
                                  Skolems = a
                                  Flatten-skolems =
                                  No-eqs = False
                                  Given =
                                  Wanted = WC {wc_flat = [W] $dIArray_a17W :: Data.Array.Base.IArray
                                                                                a_a17V
                                                                                e_a17U [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                                         [W] $dIx_a17X :: GHC.Arr.Ix
                                                                            i_a17T [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                                         [W] cobox_a17Y :: ((i_a17T, i_a17T)
                                                                            -> [e_a17U]
                                                                            -> a_a17V i_a17T e_a17U)
                                                                           ~ ((Int, Int)
                                                                              -> [a]
                                                                              -> Vector
                                                                                   a) [" a type equality (i_a17T,
                                                                                                          i_a17T)
                                                                                                         -> [e_a17U]
                                                                                                         -> a_a17V i_a17T e_a17U
                                                                                                         ~
                                                                                                         (Int,
                                                                                                          Int)
                                                                                                         -> [a]
                                                                                                         -> Vector
                                                                                                              a " p4.hs:30:14-25] (CNonCanonical)}
                                  Binds = EvBindsVar<a17Z>
                                  the type signature for
                                    listVector :: (Int, Int) -> [a] -> Vector a}}
solveWantedsTcMWithEvBinds
  wanted= WC {wc_flat = [W] $dIArray_a184 :: Data.Array.Base.IArray
                                               a_a183
                                               e_a182 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                        [W] $dIx_a185 :: GHC.Arr.Ix
                                           i_a181 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                        [W] cobox_a186 :: ((i_a181, i_a181)
                                           -> [e_a182] -> a_a183 i_a181 e_a182)
                                          ~ ((Int, Int)
                                             -> [Double] -> FlatVector) [" a type equality (i_a181,
                                                                                            i_a181)
                                                                                           -> [e_a182]
                                                                                           -> a_a183 i_a181 e_a182
                                                                                           ~
                                                                                           (Int,
                                                                                            Int)
                                                                                           -> [Double]
                                                                                           -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
                        [W] $dNum_a1bn :: Num
                                            a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                        [W] cobox_a1ct :: [a_a1bB] ~ [t_a1cs] [" a type equality [a_a1bB]
                                                                                 ~
                                                                                 [t_a1cs] " p4.hs:16:61-62] (CNonCanonical)
                        [W] cobox_a1cu :: FlatVector
                                          ~ FlatVector [" a type equality FlatVector
                                                                          ~
                                                                          FlatVector " p4.hs:16:23-56] (CNonCanonical)
                        [W] cobox_a1cv :: t_a1cs ~ Int [" a type equality t_a1cs
                                                                          ~
                                                                          Int " p4.hs:16:41] (CNonCanonical)
                        [W] $dNum_a1cy :: Num
                                            a_a1cx [" the literal ‘1’ " p4.hs:16:51] (CNonCanonical)
                        [W] cobox_a1cz :: (Integer -> a_a1cx)
                                          ~ (Integer -> t_a1cw) [" a type equality Integer -> a_a1cx
                                                                                   ~
                                                                                   Integer
                                                                                   -> t_a1cw " p4.hs:16:51] (CNonCanonical)
                        [W] cobox_a1cA :: t_a1cs ~ t_a1cw [" a type equality t_a1cs
                                                                             ~
                                                                             t_a1cw " p4.hs:16:54] (CNonCanonical)
                        [W] $dEnum_a1jn :: Enum
                                             t_a1cw [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CNonCanonical)
                        [W] cobox_a1jq :: Vector a_a1jp
                                          ~ Vector FlatVector [" a type equality Vector a_a1jp
                                                                                 ~
                                                                                 Vector
                                                                                   FlatVector " p4.hs:18:21-43] (CNonCanonical)
                        [W] cobox_a1jr :: Int ~ Int [" a type equality Int
                                                                       ~
                                                                       Int " p4.hs:18:35-37] (CNonCanonical)
                        [W] cobox_a1js :: [FlatVector]
                                          ~ [a_a1jp] [" a type equality [FlatVector]
                                                                        ~
                                                                        [a_a1jp] " p4.hs:18:40-43] (CNonCanonical)
                        [W] $dMonad_a1jz :: Monad
                                              m_a1jy [" a do statement " p4.hs:19:11-23] (CNonCanonical)
                        [W] cobox_a1jD :: (m_a1jy a_a1jA
                                           -> (a_a1jA -> m_a1jy b_a1jB) -> m_a1jy b_a1jB)
                                          ~ (t_a1jt
                                             -> (t_a1ju -> t_a1jv)
                                             -> IO ()) [" a type equality m_a1jy a_a1jA
                                                                          -> (a_a1jA
                                                                              -> m_a1jy b_a1jB)
                                                                          -> m_a1jy b_a1jB
                                                                          ~
                                                                          t_a1jt
                                                                          -> (t_a1ju -> t_a1jv)
                                                                          -> IO
                                                                               () " p4.hs:19:11-23] (CNonCanonical)
                        [W] $dIx_a1k2 :: GHC.Arr.Ix
                                           i_a1jY [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                        [W] $dIArray_a1k3 :: Data.Array.Base.IArray
                                               a_a1jX
                                               e_a1jZ [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                        [W] $dMArray_a1k4 :: Data.Array.Base.MArray
                                               b_a1k1
                                               e_a1jZ
                                               m_a1k0 [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                        [W] cobox_a1k5 :: m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
                                          ~ t_a1jt [" a type equality m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
                                                                      ~
                                                                      t_a1jt " p4.hs:19:16-23] (CNonCanonical)
                        [W] cobox_a1k6 :: Vector FlatVector
                                          ~ a_a1jX i_a1jY e_a1jZ [" a type equality Vector
                                                                                      FlatVector
                                                                                    ~
                                                                                    a_a1jX i_a1jY e_a1jZ " p4.hs:19:21-23] (CNonCanonical)
                        [W] $dMonad_a1k9 :: Monad
                                              m_a1k8 [" a use of ‘return’ " p4.hs:20:11-16] (CNonCanonical)
                        [W] cobox_a1kc :: m_a1k8 a_a1ka
                                          ~ t_a1jv [" a type equality m_a1k8 a_a1ka
                                                                      ~
                                                                      t_a1jv " p4.hs:20:11-19] (CNonCanonical)
                        [W] cobox_a1kd :: () ~ a_a1ka [" a type equality ()
                                                                         ~
                                                                         a_a1ka " p4.hs:20:18-19] (CNonCanonical)
                        [W] cobox_a1kf :: IO () ~ IO t_a1ke [" a type equality IO ()
                                                                               ~
                                                                               IO
                                                                                 t_a1ke " p4.hs:13:1] (CNonCanonical)
              wc_impl = Implic {Untouchables = 1
                                Skolems = a
                                Flatten-skolems =
                                No-eqs = False
                                Given =
                                Wanted = WC {wc_flat = [W] $dIArray_a17W :: Data.Array.Base.IArray
                                                                              a_a17V
                                                                              e_a17U [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                                       [W] $dIx_a17X :: GHC.Arr.Ix
                                                                          i_a17T [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                                       [W] cobox_a17Y :: ((i_a17T, i_a17T)
                                                                          -> [e_a17U]
                                                                          -> a_a17V i_a17T e_a17U)
                                                                         ~ ((Int, Int)
                                                                            -> [a]
                                                                            -> Vector
                                                                                 a) [" a type equality (i_a17T,
                                                                                                        i_a17T)
                                                                                                       -> [e_a17U]
                                                                                                       -> a_a17V i_a17T e_a17U
                                                                                                       ~
                                                                                                       (Int,
                                                                                                        Int)
                                                                                                       -> [a]
                                                                                                       -> Vector
                                                                                                            a " p4.hs:30:14-25] (CNonCanonical)}
                                Binds = EvBindsVar<a17Z>
                                the type signature for
                                  listVector :: (Int, Int) -> [a] -> Vector a}}
solveWanteds {
  WC {wc_flat = [W] $dIArray_a184 :: Data.Array.Base.IArray
                                       a_a183
                                       e_a182 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                [W] $dIx_a185 :: GHC.Arr.Ix
                                   i_a181 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                [W] cobox_a186 :: ((i_a181, i_a181)
                                   -> [e_a182] -> a_a183 i_a181 e_a182)
                                  ~ ((Int, Int)
                                     -> [Double] -> FlatVector) [" a type equality (i_a181, i_a181)
                                                                                   -> [e_a182]
                                                                                   -> a_a183 i_a181 e_a182
                                                                                   ~
                                                                                   (Int, Int)
                                                                                   -> [Double]
                                                                                   -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
                [W] $dNum_a1bn :: Num
                                    a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                [W] cobox_a1ct :: [a_a1bB] ~ [t_a1cs] [" a type equality [a_a1bB]
                                                                         ~
                                                                         [t_a1cs] " p4.hs:16:61-62] (CNonCanonical)
                [W] cobox_a1cu :: FlatVector
                                  ~ FlatVector [" a type equality FlatVector
                                                                  ~
                                                                  FlatVector " p4.hs:16:23-56] (CNonCanonical)
                [W] cobox_a1cv :: t_a1cs ~ Int [" a type equality t_a1cs
                                                                  ~
                                                                  Int " p4.hs:16:41] (CNonCanonical)
                [W] $dNum_a1cy :: Num
                                    a_a1cx [" the literal ‘1’ " p4.hs:16:51] (CNonCanonical)
                [W] cobox_a1cz :: (Integer -> a_a1cx)
                                  ~ (Integer -> t_a1cw) [" a type equality Integer -> a_a1cx
                                                                           ~
                                                                           Integer
                                                                           -> t_a1cw " p4.hs:16:51] (CNonCanonical)
                [W] cobox_a1cA :: t_a1cs ~ t_a1cw [" a type equality t_a1cs
                                                                     ~
                                                                     t_a1cw " p4.hs:16:54] (CNonCanonical)
                [W] $dEnum_a1jn :: Enum
                                     t_a1cw [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CNonCanonical)
                [W] cobox_a1jq :: Vector a_a1jp
                                  ~ Vector FlatVector [" a type equality Vector a_a1jp
                                                                         ~
                                                                         Vector
                                                                           FlatVector " p4.hs:18:21-43] (CNonCanonical)
                [W] cobox_a1jr :: Int ~ Int [" a type equality Int
                                                               ~
                                                               Int " p4.hs:18:35-37] (CNonCanonical)
                [W] cobox_a1js :: [FlatVector]
                                  ~ [a_a1jp] [" a type equality [FlatVector]
                                                                ~
                                                                [a_a1jp] " p4.hs:18:40-43] (CNonCanonical)
                [W] $dMonad_a1jz :: Monad
                                      m_a1jy [" a do statement " p4.hs:19:11-23] (CNonCanonical)
                [W] cobox_a1jD :: (m_a1jy a_a1jA
                                   -> (a_a1jA -> m_a1jy b_a1jB) -> m_a1jy b_a1jB)
                                  ~ (t_a1jt
                                     -> (t_a1ju -> t_a1jv)
                                     -> IO ()) [" a type equality m_a1jy a_a1jA
                                                                  -> (a_a1jA -> m_a1jy b_a1jB)
                                                                  -> m_a1jy b_a1jB
                                                                  ~
                                                                  t_a1jt
                                                                  -> (t_a1ju -> t_a1jv)
                                                                  -> IO
                                                                       () " p4.hs:19:11-23] (CNonCanonical)
                [W] $dIx_a1k2 :: GHC.Arr.Ix
                                   i_a1jY [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                [W] $dIArray_a1k3 :: Data.Array.Base.IArray
                                       a_a1jX
                                       e_a1jZ [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                [W] $dMArray_a1k4 :: Data.Array.Base.MArray
                                       b_a1k1
                                       e_a1jZ
                                       m_a1k0 [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                [W] cobox_a1k5 :: m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
                                  ~ t_a1jt [" a type equality m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
                                                              ~
                                                              t_a1jt " p4.hs:19:16-23] (CNonCanonical)
                [W] cobox_a1k6 :: Vector FlatVector
                                  ~ a_a1jX i_a1jY e_a1jZ [" a type equality Vector FlatVector
                                                                            ~
                                                                            a_a1jX i_a1jY e_a1jZ " p4.hs:19:21-23] (CNonCanonical)
                [W] $dMonad_a1k9 :: Monad
                                      m_a1k8 [" a use of ‘return’ " p4.hs:20:11-16] (CNonCanonical)
                [W] cobox_a1kc :: m_a1k8 a_a1ka
                                  ~ t_a1jv [" a type equality m_a1k8 a_a1ka
                                                              ~
                                                              t_a1jv " p4.hs:20:11-19] (CNonCanonical)
                [W] cobox_a1kd :: () ~ a_a1ka [" a type equality ()
                                                                 ~
                                                                 a_a1ka " p4.hs:20:18-19] (CNonCanonical)
                [W] cobox_a1kf :: IO () ~ IO t_a1ke [" a type equality IO ()
                                                                       ~
                                                                       IO
                                                                         t_a1ke " p4.hs:13:1] (CNonCanonical)
      wc_impl = Implic {Untouchables = 1
                        Skolems = a
                        Flatten-skolems =
                        No-eqs = False
                        Given =
                        Wanted = WC {wc_flat = [W] $dIArray_a17W :: Data.Array.Base.IArray
                                                                      a_a17V
                                                                      e_a17U [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                               [W] $dIx_a17X :: GHC.Arr.Ix
                                                                  i_a17T [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                               [W] cobox_a17Y :: ((i_a17T, i_a17T)
                                                                  -> [e_a17U]
                                                                  -> a_a17V i_a17T e_a17U)
                                                                 ~ ((Int, Int)
                                                                    -> [a]
                                                                    -> Vector
                                                                         a) [" a type equality (i_a17T,
                                                                                                i_a17T)
                                                                                               -> [e_a17U]
                                                                                               -> a_a17V i_a17T e_a17U
                                                                                               ~
                                                                                               (Int,
                                                                                                Int)
                                                                                               -> [a]
                                                                                               -> Vector
                                                                                                    a " p4.hs:30:14-25] (CNonCanonical)}
                        Binds = EvBindsVar<a17Z>
                        the type signature for
                          listVector :: (Int, Int) -> [a] -> Vector a}}
solveFlats {
Start solver pipeline {
  work item =  [W] cobox_a186 :: ((i_a181, i_a181)
                                  -> [e_a182] -> a_a183 i_a181 e_a182)
                                 ~ ((Int, Int)
                                    -> [Double] -> FlatVector) [" a type equality (i_a181, i_a181)
                                                                                  -> [e_a182]
                                                                                  -> a_a183 i_a181 e_a182
                                                                                  ~
                                                                                  (Int, Int)
                                                                                  -> [Double]
                                                                                  -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a186 :: ((i_a181, i_a181)
                                   -> [e_a182] -> a_a183 i_a181 e_a182)
                                  ~ ((Int, Int)
                                     -> [Double] -> FlatVector) [" a type equality (i_a181, i_a181)
                                                                                   -> [e_a182]
                                                                                   -> a_a183 i_a181 e_a182
                                                                                   ~
                                                                                   (Int, Int)
                                                                                   -> [Double]
                                                                                   -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a186 :: ((i_a181, i_a181)
                     -> [e_a182] -> a_a183 i_a181 e_a182)
                    ~ ((Int, Int)
                       -> [Double] -> FlatVector) [" a type equality (i_a181, i_a181)
                                                                     -> [e_a182]
                                                                     -> a_a183 i_a181 e_a182
                                                                     ~
                                                                     (Int, Int)
                                                                     -> [Double]
                                                                     -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canEvNC:eq
  (i_a181, i_a181) -> [e_a182] -> a_a183 i_a181 e_a182
  (Int, Int) -> [Double] -> FlatVector
can_eq_nc
  [W] cobox_a186 :: ((i_a181, i_a181)
                     -> [e_a182] -> a_a183 i_a181 e_a182)
                    ~ ((Int, Int) -> [Double] -> FlatVector)
  (i_a181, i_a181) -> [e_a182] -> a_a183 i_a181 e_a182
  (i_a181, i_a181) -> [e_a182] -> a_a183 i_a181 e_a182
  (Int, Int) -> [Double] -> FlatVector
  (Int, Int) -> [Double] -> FlatVector
newWantedEvVar/cache miss
  [W] cobox_a1lC :: (i_a181, i_a181) ~ (Int, Int)
newWantedEvVar/cache miss
  [W] cobox_a1lD :: ([e_a182] -> a_a183 i_a181 e_a182)
                    ~ ([Double] -> FlatVector)
setEvBind
  ev = cobox_a186
  tm  = CO cobox_a1lC -> cobox_a1lD
canEvNC:eq
  (i_a181, i_a181)
  (Int, Int)
can_eq_nc
  [W] cobox_a1lC :: (i_a181, i_a181) ~ (Int, Int)
  (i_a181, i_a181)
  (i_a181, i_a181)
  (Int, Int)
  (Int, Int)
newWantedEvVar/cache miss [W] cobox_a1lE :: i_a181 ~ Int
newWantedEvVar/cache miss [W] cobox_a1lF :: i_a181 ~ Int
setEvBind
  ev = cobox_a1lC
  tm  = CO (cobox_a1lE, cobox_a1lF)_N
canEvNC:eq
  i_a181
  Int
can_eq_nc
  [W] cobox_a1lE :: i_a181 ~ Int
  i_a181
  i_a181
  Int
  Int
canEqTyVar
  i_a181
  Int
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1lE :: i_a181
                                  ~ Int [" a type equality (i_a181, i_a181)
                                                           -> [e_a182] -> a_a183 i_a181 e_a182
                                                           ~
                                                           (Int, Int)
                                                           -> [Double]
                                                           -> FlatVector " p4.hs:25:18-29] (CTyEqCan)
Sneaky unification:
  Unifies: i_a181 := Int
  Coercion: i_a181 ~ Int
  Left Kind is: *
  Right Kind is: *
setWantedTyBind i_a181 := Int
setEvBind
  ev = cobox_a1lE
  tm  = CO <Int>_N
kickOutRewritable
  tv =  i_a181
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
1[<C:0,F:0>] [W] cobox_a1lE :: i_a181 ~ Int: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1lF :: i_a181
                                 ~ Int [" a type equality (i_a181, i_a181)
                                                          -> [e_a182] -> a_a183 i_a181 e_a182
                                                          ~
                                                          (Int, Int)
                                                          -> [Double]
                                                          -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1lF :: i_a181
                                  ~ Int [" a type equality (i_a181, i_a181)
                                                           -> [e_a182] -> a_a183 i_a181 e_a182
                                                           ~
                                                           (Int, Int)
                                                           -> [Double]
                                                           -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1lF :: i_a181 ~ Int [" a type equality (i_a181, i_a181)
                                                    -> [e_a182] -> a_a183 i_a181 e_a182
                                                    ~
                                                    (Int, Int)
                                                    -> [Double]
                                                    -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canEvNC:eq
  i_a181
  Int
can_eq_nc
  [W] cobox_a1lF :: i_a181 ~ Int
  i_a181
  i_a181
  Int
  Int
canEqTyVar
  i_a181
  Int
  Not-swapped
Following bound tyvar i_a181 = Int
canEqTyVar2
  i_a181
  Int
  Not-swapped
  Int
  <Int>_N
can_eq_nc
  [W] cobox_a1lF :: Int ~ Int
  Int
  Int
  Int
  Int
setEvBind
  ev = cobox_a1lF
  tm  = CO <Int>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1lD :: ([e_a182] -> a_a183 i_a181 e_a182)
                                 ~ ([Double] -> FlatVector) [" a type equality (i_a181, i_a181)
                                                                               -> [e_a182]
                                                                               -> a_a183 i_a181 e_a182
                                                                               ~
                                                                               (Int, Int)
                                                                               -> [Double]
                                                                               -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1lD :: ([e_a182] -> a_a183 i_a181 e_a182)
                                  ~ ([Double] -> FlatVector) [" a type equality (i_a181, i_a181)
                                                                                -> [e_a182]
                                                                                -> a_a183 i_a181 e_a182
                                                                                ~
                                                                                (Int, Int)
                                                                                -> [Double]
                                                                                -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1lD :: ([e_a182] -> a_a183 i_a181 e_a182)
                    ~ ([Double] -> FlatVector) [" a type equality (i_a181, i_a181)
                                                                  -> [e_a182]
                                                                  -> a_a183 i_a181 e_a182
                                                                  ~
                                                                  (Int, Int)
                                                                  -> [Double]
                                                                  -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canEvNC:eq
  [e_a182] -> a_a183 i_a181 e_a182
  [Double] -> FlatVector
can_eq_nc
  [W] cobox_a1lD :: ([e_a182] -> a_a183 i_a181 e_a182)
                    ~ ([Double] -> FlatVector)
  [e_a182] -> a_a183 i_a181 e_a182
  [e_a182] -> a_a183 i_a181 e_a182
  [Double] -> FlatVector
  [Double] -> FlatVector
newWantedEvVar/cache miss [W] cobox_a1lG :: [e_a182] ~ [Double]
newWantedEvVar/cache miss
  [W] cobox_a1lH :: a_a183 i_a181 e_a182 ~ FlatVector
setEvBind
  ev = cobox_a1lD
  tm  = CO cobox_a1lG -> cobox_a1lH
canEvNC:eq
  [e_a182]
  [Double]
can_eq_nc
  [W] cobox_a1lG :: [e_a182] ~ [Double]
  [e_a182]
  [e_a182]
  [Double]
  [Double]
newWantedEvVar/cache miss [W] cobox_a1lI :: e_a182 ~ Double
setEvBind
  ev = cobox_a1lG
  tm  = CO [cobox_a1lI]_N
canEvNC:eq
  e_a182
  Double
can_eq_nc
  [W] cobox_a1lI :: e_a182 ~ Double
  e_a182
  e_a182
  Double
  Double
canEqTyVar
  e_a182
  Double
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1lI :: e_a182
                                  ~ Double [" a type equality (i_a181, i_a181)
                                                              -> [e_a182] -> a_a183 i_a181 e_a182
                                                              ~
                                                              (Int, Int)
                                                              -> [Double]
                                                              -> FlatVector " p4.hs:25:18-29] (CTyEqCan)
Sneaky unification:
  Unifies: e_a182 := Double
  Coercion: e_a182 ~ Double
  Left Kind is: *
  Right Kind is: *
setWantedTyBind e_a182 := Double
setEvBind
  ev = cobox_a1lI
  tm  = CO <Double>_N
kickOutRewritable
  tv =  e_a182
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
3[<C:0,F:0>] [W] cobox_a1lI :: e_a182
                               ~ Double: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1lH :: a_a183 i_a181 e_a182
                                 ~ FlatVector [" a type equality (i_a181, i_a181)
                                                                 -> [e_a182] -> a_a183 i_a181 e_a182
                                                                 ~
                                                                 (Int, Int)
                                                                 -> [Double]
                                                                 -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1lH :: a_a183 i_a181 e_a182
                                  ~ FlatVector [" a type equality (i_a181, i_a181)
                                                                  -> [e_a182]
                                                                  -> a_a183 i_a181 e_a182
                                                                  ~
                                                                  (Int, Int)
                                                                  -> [Double]
                                                                  -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1lH :: a_a183 i_a181 e_a182
                    ~ FlatVector [" a type equality (i_a181, i_a181)
                                                    -> [e_a182] -> a_a183 i_a181 e_a182
                                                    ~
                                                    (Int, Int)
                                                    -> [Double]
                                                    -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canEvNC:eq
  a_a183 i_a181 e_a182
  FlatVector
can_eq_nc
  [W] cobox_a1lH :: a_a183 i_a181 e_a182 ~ FlatVector
  a_a183 i_a181 e_a182
  a_a183 i_a181 e_a182
  FlatVector
  FlatVector
can_eq_nc
  [W] cobox_a1lH :: a_a183 i_a181 e_a182 ~ FlatVector
  a_a183 i_a181 e_a182
  a_a183 i_a181 e_a182
  UArray Int Double
  FlatVector
can_eq_app 1
  [W] cobox_a1lH :: a_a183 i_a181 e_a182 ~ FlatVector
  Not-swapped
  a_a183 i_a181
  e_a182
  UArray Int Double
Following bound tyvar i_a181 = Int
flatten/appty
  a_a183
  i_a181
  a_a183
  <a_a183>_N
  Int
  <Int>_N
can_eq_app 2
  [W] cobox_a1lH :: a_a183 i_a181 e_a182 ~ FlatVector
  a_a183 Int
Following bound tyvar e_a182 = Double
can_eq_app 3
  [W] cobox_a1lH :: a_a183 i_a181 e_a182 ~ FlatVector
  a_a183 Int Double
  <a_a183 Int Double>_N
can_eq_app 4
  [W] cobox_a1lH :: a_a183 i_a181 e_a182 ~ FlatVector
  a_a183 Int Double
  <a_a183 Int Double>_N
can_eq_nc
  [W] cobox_a1lH :: a_a183 Int Double ~ FlatVector
  a_a183 Int Double
  a_a183 Int Double
  UArray Int Double
  FlatVector
can_eq_app 1
  [W] cobox_a1lH :: a_a183 Int Double ~ FlatVector
  Not-swapped
  a_a183 Int
  Double
  UArray Int Double
flatten/appty
  a_a183
  Int
  a_a183
  <a_a183>_N
  Int
  <Int>_N
can_eq_app 2
  [W] cobox_a1lH :: a_a183 Int Double ~ FlatVector
  a_a183 Int
newWantedEvVar/cache miss [W] cobox_a1lJ :: a_a183 Int ~ UArray Int
newWantedEvVar/cache miss [W] cobox_a1lK :: Double ~ Double
setEvBind
  ev = cobox_a1lH
  tm  = CO cobox_a1lJ cobox_a1lK
canEvNC:eq
  a_a183 Int
  UArray Int
can_eq_nc
  [W] cobox_a1lJ :: a_a183 Int ~ UArray Int
  a_a183 Int
  a_a183 Int
  UArray Int
  UArray Int
can_eq_app 1
  [W] cobox_a1lJ :: a_a183 Int ~ UArray Int
  Not-swapped
  a_a183
  Int
  UArray Int
can_eq_app 2
  [W] cobox_a1lJ :: a_a183 Int ~ UArray Int
  a_a183
newWantedEvVar/cache miss [W] cobox_a1lL :: a_a183 ~ UArray
newWantedEvVar/cache miss [W] cobox_a1lM :: Int ~ Int
setEvBind
  ev = cobox_a1lJ
  tm  = CO cobox_a1lL cobox_a1lM
canEvNC:eq
  a_a183
  UArray
can_eq_nc
  [W] cobox_a1lL :: a_a183 ~ UArray
  a_a183
  a_a183
  UArray
  UArray
canEqTyVar
  a_a183
  UArray
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1lL :: a_a183
                                  ~ UArray [" a type equality (i_a181, i_a181)
                                                              -> [e_a182] -> a_a183 i_a181 e_a182
                                                              ~
                                                              (Int, Int)
                                                              -> [Double]
                                                              -> FlatVector " p4.hs:25:18-29] (CTyEqCan)
Sneaky unification:
  Unifies: a_a183 := UArray
  Coercion: a_a183 ~ UArray
  Left Kind is: * -> * -> *
  Right Kind is: * -> * -> *
setWantedTyBind a_a183 := UArray
setEvBind
  ev = cobox_a1lL
  tm  = CO <UArray>_N
kickOutRewritable
  tv =  a_a183
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
4[<C:0,F:0>] [W] cobox_a1lL :: a_a183
                               ~ UArray: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1lM :: Int
                                 ~ Int [" a type equality (i_a181, i_a181)
                                                          -> [e_a182] -> a_a183 i_a181 e_a182
                                                          ~
                                                          (Int, Int)
                                                          -> [Double]
                                                          -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1lM :: Int
                                  ~ Int [" a type equality (i_a181, i_a181)
                                                           -> [e_a182] -> a_a183 i_a181 e_a182
                                                           ~
                                                           (Int, Int)
                                                           -> [Double]
                                                           -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1lM :: Int ~ Int [" a type equality (i_a181, i_a181)
                                                 -> [e_a182] -> a_a183 i_a181 e_a182
                                                 ~
                                                 (Int, Int)
                                                 -> [Double]
                                                 -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canEvNC:eq
  Int
  Int
can_eq_nc
  [W] cobox_a1lM :: Int ~ Int
  Int
  Int
  Int
  Int
setEvBind
  ev = cobox_a1lM
  tm  = CO <Int>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1lK :: Double
                                 ~ Double [" a type equality (i_a181, i_a181)
                                                             -> [e_a182] -> a_a183 i_a181 e_a182
                                                             ~
                                                             (Int, Int)
                                                             -> [Double]
                                                             -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1lK :: Double
                                  ~ Double [" a type equality (i_a181, i_a181)
                                                              -> [e_a182] -> a_a183 i_a181 e_a182
                                                              ~
                                                              (Int, Int)
                                                              -> [Double]
                                                              -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1lK :: Double ~ Double [" a type equality (i_a181,
                                                        i_a181)
                                                       -> [e_a182] -> a_a183 i_a181 e_a182
                                                       ~
                                                       (Int, Int)
                                                       -> [Double]
                                                       -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
canEvNC:eq
  Double
  Double
can_eq_nc
  [W] cobox_a1lK :: Double ~ Double
  Double
  Double
  Double
  Double
setEvBind
  ev = cobox_a1lK
  tm  = CO <Double>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1ct :: [a_a1bB]
                                 ~ [t_a1cs] [" a type equality [a_a1bB]
                                                               ~
                                                               [t_a1cs] " p4.hs:16:61-62] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1ct :: [a_a1bB]
                                  ~ [t_a1cs] [" a type equality [a_a1bB]
                                                                ~
                                                                [t_a1cs] " p4.hs:16:61-62] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1ct :: [a_a1bB] ~ [t_a1cs] [" a type equality [a_a1bB]
                                                           ~
                                                           [t_a1cs] " p4.hs:16:61-62] (CNonCanonical)
canEvNC:eq
  [a_a1bB]
  [t_a1cs]
can_eq_nc
  [W] cobox_a1ct :: [a_a1bB] ~ [t_a1cs]
  [a_a1bB]
  [a_a1bB]
  [t_a1cs]
  [t_a1cs]
newWantedEvVar/cache miss [W] cobox_a1lN :: a_a1bB ~ t_a1cs
setEvBind
  ev = cobox_a1ct
  tm  = CO [cobox_a1lN]_N
canEvNC:eq
  a_a1bB
  t_a1cs
can_eq_nc
  [W] cobox_a1lN :: a_a1bB ~ t_a1cs
  a_a1bB
  a_a1bB
  t_a1cs
  t_a1cs
canEqTyVar
  a_a1bB
  t_a1cs
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1lN :: a_a1bB
                                  ~ t_a1cs [" a type equality [a_a1bB]
                                                              ~
                                                              [t_a1cs] " p4.hs:16:61-62] (CTyEqCan)
Sneaky unification:
  Unifies: t_a1cs := a_a1bB
  Coercion: t_a1cs ~ a_a1bB
  Left Kind is: *
  Right Kind is: *
setWantedTyBind t_a1cs := a_a1bB
setEvBind
  ev = cobox_a1lN
  tm  = CO <a_a1bB>_N
kickOutRewritable
  tv =  t_a1cs
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
7[<C:0,F:0>] [W] cobox_a1lN :: a_a1bB
                               ~ t_a1cs: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1cu :: FlatVector
                                 ~ FlatVector [" a type equality FlatVector
                                                                 ~
                                                                 FlatVector " p4.hs:16:23-56] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1cu :: FlatVector
                                  ~ FlatVector [" a type equality FlatVector
                                                                  ~
                                                                  FlatVector " p4.hs:16:23-56] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1cu :: FlatVector
                    ~ FlatVector [" a type equality FlatVector
                                                    ~
                                                    FlatVector " p4.hs:16:23-56] (CNonCanonical)
canEvNC:eq
  FlatVector
  FlatVector
can_eq_nc
  [W] cobox_a1cu :: FlatVector ~ FlatVector
  FlatVector
  FlatVector
  FlatVector
  FlatVector
can_eq_nc
  [W] cobox_a1cu :: FlatVector ~ FlatVector
  UArray Int Double
  FlatVector
  FlatVector
  FlatVector
can_eq_nc
  [W] cobox_a1cu :: FlatVector ~ FlatVector
  UArray Int Double
  FlatVector
  UArray Int Double
  FlatVector
newWantedEvVar/cache miss [W] cobox_a1lO :: Int ~ Int
newWantedEvVar/cache miss [W] cobox_a1lP :: Double ~ Double
setEvBind
  ev = cobox_a1cu
  tm  = CO UArray cobox_a1lO cobox_a1lP_N
canEvNC:eq
  Int
  Int
can_eq_nc
  [W] cobox_a1lO :: Int ~ Int
  Int
  Int
  Int
  Int
setEvBind
  ev = cobox_a1lO
  tm  = CO <Int>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1lP :: Double
                                 ~ Double [" a type equality FlatVector
                                                             ~
                                                             FlatVector " p4.hs:16:23-56] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1lP :: Double
                                  ~ Double [" a type equality FlatVector
                                                              ~
                                                              FlatVector " p4.hs:16:23-56] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1lP :: Double ~ Double [" a type equality FlatVector
                                                       ~
                                                       FlatVector " p4.hs:16:23-56] (CNonCanonical)
canEvNC:eq
  Double
  Double
can_eq_nc
  [W] cobox_a1lP :: Double ~ Double
  Double
  Double
  Double
  Double
setEvBind
  ev = cobox_a1lP
  tm  = CO <Double>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1cv :: t_a1cs
                                 ~ Int [" a type equality t_a1cs
                                                          ~
                                                          Int " p4.hs:16:41] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1cv :: t_a1cs
                                  ~ Int [" a type equality t_a1cs
                                                           ~
                                                           Int " p4.hs:16:41] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1cv :: t_a1cs ~ Int [" a type equality t_a1cs
                                                    ~
                                                    Int " p4.hs:16:41] (CNonCanonical)
canEvNC:eq
  t_a1cs
  Int
can_eq_nc
  [W] cobox_a1cv :: t_a1cs ~ Int
  t_a1cs
  t_a1cs
  Int
  Int
canEqTyVar
  t_a1cs
  Int
  Not-swapped
Following bound tyvar t_a1cs = a_a1bB
canEqTyVar2
  t_a1cs
  Int
  Not-swapped
  a_a1bB
  <a_a1bB>_N
can_eq_nc
  [W] cobox_a1cv :: a_a1bB ~ Int
  a_a1bB
  a_a1bB
  Int
  Int
canEqTyVar
  a_a1bB
  Int
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1cv :: a_a1bB
                                  ~ Int [" a type equality t_a1cs ~ Int " p4.hs:16:41] (CTyEqCan)
Sneaky unification:
  Unifies: a_a1bB := Int
  Coercion: a_a1bB ~ Int
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_a1bB := Int
setEvBind
  ev = cobox_a1cv
  tm  = CO <Int>_N
kickOutRewritable
  tv =  a_a1bB
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
10[<C:0,F:0>] [W] cobox_a1cv :: a_a1bB ~ Int: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1cz :: (Integer -> a_a1cx)
                                 ~ (Integer -> t_a1cw) [" a type equality Integer -> a_a1cx
                                                                          ~
                                                                          Integer
                                                                          -> t_a1cw " p4.hs:16:51] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1cz :: (Integer -> a_a1cx)
                                  ~ (Integer -> t_a1cw) [" a type equality Integer -> a_a1cx
                                                                           ~
                                                                           Integer
                                                                           -> t_a1cw " p4.hs:16:51] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1cz :: (Integer -> a_a1cx)
                    ~ (Integer -> t_a1cw) [" a type equality Integer -> a_a1cx
                                                             ~
                                                             Integer
                                                             -> t_a1cw " p4.hs:16:51] (CNonCanonical)
canEvNC:eq
  Integer -> a_a1cx
  Integer -> t_a1cw
can_eq_nc
  [W] cobox_a1cz :: (Integer -> a_a1cx) ~ (Integer -> t_a1cw)
  Integer -> a_a1cx
  Integer -> a_a1cx
  Integer -> t_a1cw
  Integer -> t_a1cw
newWantedEvVar/cache miss [W] cobox_a1lQ :: Integer ~ Integer
newWantedEvVar/cache miss [W] cobox_a1lR :: a_a1cx ~ t_a1cw
setEvBind
  ev = cobox_a1cz
  tm  = CO cobox_a1lQ -> cobox_a1lR
canEvNC:eq
  Integer
  Integer
can_eq_nc
  [W] cobox_a1lQ :: Integer ~ Integer
  Integer
  Integer
  Integer
  Integer
setEvBind
  ev = cobox_a1lQ
  tm  = CO <Integer>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1lR :: a_a1cx
                                 ~ t_a1cw [" a type equality Integer -> a_a1cx
                                                             ~
                                                             Integer
                                                             -> t_a1cw " p4.hs:16:51] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1lR :: a_a1cx
                                  ~ t_a1cw [" a type equality Integer -> a_a1cx
                                                              ~
                                                              Integer
                                                              -> t_a1cw " p4.hs:16:51] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1lR :: a_a1cx ~ t_a1cw [" a type equality Integer
                                                       -> a_a1cx
                                                       ~
                                                       Integer
                                                       -> t_a1cw " p4.hs:16:51] (CNonCanonical)
canEvNC:eq
  a_a1cx
  t_a1cw
can_eq_nc
  [W] cobox_a1lR :: a_a1cx ~ t_a1cw
  a_a1cx
  a_a1cx
  t_a1cw
  t_a1cw
canEqTyVar
  a_a1cx
  t_a1cw
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1lR :: a_a1cx
                                  ~ t_a1cw [" a type equality Integer -> a_a1cx
                                                              ~
                                                              Integer
                                                              -> t_a1cw " p4.hs:16:51] (CTyEqCan)
Sneaky unification:
  Unifies: t_a1cw := a_a1cx
  Coercion: t_a1cw ~ a_a1cx
  Left Kind is: *
  Right Kind is: *
setWantedTyBind t_a1cw := a_a1cx
setEvBind
  ev = cobox_a1lR
  tm  = CO <a_a1cx>_N
kickOutRewritable
  tv =  t_a1cw
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
12[<C:0,F:0>] [W] cobox_a1lR :: a_a1cx
                                ~ t_a1cw: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1cA :: t_a1cs
                                 ~ t_a1cw [" a type equality t_a1cs
                                                             ~
                                                             t_a1cw " p4.hs:16:54] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1cA :: t_a1cs
                                  ~ t_a1cw [" a type equality t_a1cs
                                                              ~
                                                              t_a1cw " p4.hs:16:54] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1cA :: t_a1cs ~ t_a1cw [" a type equality t_a1cs
                                                       ~
                                                       t_a1cw " p4.hs:16:54] (CNonCanonical)
canEvNC:eq
  t_a1cs
  t_a1cw
can_eq_nc
  [W] cobox_a1cA :: t_a1cs ~ t_a1cw
  t_a1cs
  t_a1cs
  t_a1cw
  t_a1cw
canEqTyVar
  t_a1cs
  t_a1cw
  Not-swapped
Following bound tyvar t_a1cs = a_a1bB
canEqTyVar2
  t_a1cs
  t_a1cw
  Not-swapped
  a_a1bB
  <a_a1bB>_N
can_eq_nc
  [W] cobox_a1cA :: a_a1bB ~ t_a1cw
  a_a1bB
  a_a1bB
  t_a1cw
  t_a1cw
canEqTyVar
  a_a1bB
  t_a1cw
  Not-swapped
Following bound tyvar a_a1bB = Int
canEqTyVar2
  a_a1bB
  t_a1cw
  Not-swapped
  Int
  <Int>_N
can_eq_nc
  [W] cobox_a1cA :: Int ~ t_a1cw
  Int
  Int
  t_a1cw
  t_a1cw
canEqTyVar
  t_a1cw
  Int
  Is-swapped
Following bound tyvar t_a1cw = a_a1cx
newWantedEvVar/cache miss [W] cobox_a1lS :: a_a1cx ~ Int
setEvBind
  ev = cobox_a1cA
  tm  = CO Sym cobox_a1lS
rewriteEqEvidence
  [W] cobox_a1cA :: Int ~ t_a1cw
  a_a1cx
  Int
  Sym cobox_a1lS
canEqTyVar2
  t_a1cw
  Int
  Is-swapped
  a_a1cx
  <a_a1cx>_N
can_eq_nc
  [W] cobox_a1lS :: a_a1cx ~ Int
  a_a1cx
  a_a1cx
  Int
  Int
canEqTyVar
  a_a1cx
  Int
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1lS :: a_a1cx
                                  ~ Int [" a type equality t_a1cs ~ t_a1cw " p4.hs:16:54] (CTyEqCan)
Sneaky unification:
  Unifies: a_a1cx := Int
  Coercion: a_a1cx ~ Int
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_a1cx := Int
setEvBind
  ev = cobox_a1lS
  tm  = CO <Int>_N
kickOutRewritable
  tv =  a_a1cx
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
13[<C:0,F:0>] [W] cobox_a1lS :: a_a1cx ~ Int: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1jq :: Vector a_a1jp
                                 ~ Vector FlatVector [" a type equality Vector a_a1jp
                                                                        ~
                                                                        Vector
                                                                          FlatVector " p4.hs:18:21-43] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1jq :: Vector a_a1jp
                                  ~ Vector FlatVector [" a type equality Vector a_a1jp
                                                                         ~
                                                                         Vector
                                                                           FlatVector " p4.hs:18:21-43] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1jq :: Vector a_a1jp
                    ~ Vector FlatVector [" a type equality Vector a_a1jp
                                                           ~
                                                           Vector
                                                             FlatVector " p4.hs:18:21-43] (CNonCanonical)
canEvNC:eq
  Vector a_a1jp
  Vector FlatVector
can_eq_nc
  [W] cobox_a1jq :: Vector a_a1jp ~ Vector FlatVector
  Vector a_a1jp
  Vector a_a1jp
  Vector FlatVector
  Vector FlatVector
can_eq_nc
  [W] cobox_a1jq :: Vector a_a1jp ~ Vector FlatVector
  Array Int a_a1jp
  Vector a_a1jp
  Vector FlatVector
  Vector FlatVector
can_eq_nc
  [W] cobox_a1jq :: Vector a_a1jp ~ Vector FlatVector
  Array Int a_a1jp
  Vector a_a1jp
  Array Int FlatVector
  Vector FlatVector
newWantedEvVar/cache miss [W] cobox_a1lT :: Int ~ Int
newWantedEvVar/cache miss [W] cobox_a1lU :: a_a1jp ~ FlatVector
setEvBind
  ev = cobox_a1jq
  tm  = CO Array cobox_a1lT cobox_a1lU_N
canEvNC:eq
  Int
  Int
can_eq_nc
  [W] cobox_a1lT :: Int ~ Int
  Int
  Int
  Int
  Int
setEvBind
  ev = cobox_a1lT
  tm  = CO <Int>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1lU :: a_a1jp
                                 ~ FlatVector [" a type equality Vector a_a1jp
                                                                 ~
                                                                 Vector
                                                                   FlatVector " p4.hs:18:21-43] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1lU :: a_a1jp
                                  ~ FlatVector [" a type equality Vector a_a1jp
                                                                  ~
                                                                  Vector
                                                                    FlatVector " p4.hs:18:21-43] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1lU :: a_a1jp ~ FlatVector [" a type equality Vector
                                                             a_a1jp
                                                           ~
                                                           Vector
                                                             FlatVector " p4.hs:18:21-43] (CNonCanonical)
canEvNC:eq
  a_a1jp
  FlatVector
can_eq_nc
  [W] cobox_a1lU :: a_a1jp ~ FlatVector
  a_a1jp
  a_a1jp
  FlatVector
  FlatVector
can_eq_nc
  [W] cobox_a1lU :: a_a1jp ~ FlatVector
  a_a1jp
  a_a1jp
  UArray Int Double
  FlatVector
canEqTyVar
  a_a1jp
  UArray Int Double
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1lU :: a_a1jp
                                  ~ FlatVector [" a type equality Vector a_a1jp
                                                                  ~
                                                                  Vector
                                                                    FlatVector " p4.hs:18:21-43] (CTyEqCan)
Sneaky unification:
  Unifies: a_a1jp := FlatVector
  Coercion: a_a1jp ~ FlatVector
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_a1jp := FlatVector
setEvBind
  ev = cobox_a1lU
  tm  = CO <FlatVector>_N
kickOutRewritable
  tv =  a_a1jp
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
15[<C:0,F:0>] [W] cobox_a1lU :: a_a1jp
                                ~ FlatVector: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1jr :: Int ~ Int [" a type equality Int
                                                              ~
                                                              Int " p4.hs:18:35-37] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1jr :: Int ~ Int [" a type equality Int
                                                               ~
                                                               Int " p4.hs:18:35-37] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1jr :: Int ~ Int [" a type equality Int
                                                 ~
                                                 Int " p4.hs:18:35-37] (CNonCanonical)
canEvNC:eq
  Int
  Int
can_eq_nc
  [W] cobox_a1jr :: Int ~ Int
  Int
  Int
  Int
  Int
setEvBind
  ev = cobox_a1jr
  tm  = CO <Int>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1js :: [FlatVector]
                                 ~ [a_a1jp] [" a type equality [FlatVector]
                                                               ~
                                                               [a_a1jp] " p4.hs:18:40-43] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1js :: [FlatVector]
                                  ~ [a_a1jp] [" a type equality [FlatVector]
                                                                ~
                                                                [a_a1jp] " p4.hs:18:40-43] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1js :: [FlatVector]
                    ~ [a_a1jp] [" a type equality [FlatVector]
                                                  ~
                                                  [a_a1jp] " p4.hs:18:40-43] (CNonCanonical)
canEvNC:eq
  [FlatVector]
  [a_a1jp]
can_eq_nc
  [W] cobox_a1js :: [FlatVector] ~ [a_a1jp]
  [FlatVector]
  [FlatVector]
  [a_a1jp]
  [a_a1jp]
newWantedEvVar/cache miss [W] cobox_a1lV :: FlatVector ~ a_a1jp
setEvBind
  ev = cobox_a1js
  tm  = CO [cobox_a1lV]_N
canEvNC:eq
  FlatVector
  a_a1jp
can_eq_nc
  [W] cobox_a1lV :: FlatVector ~ a_a1jp
  FlatVector
  FlatVector
  a_a1jp
  a_a1jp
can_eq_nc
  [W] cobox_a1lV :: FlatVector ~ a_a1jp
  UArray Int Double
  FlatVector
  a_a1jp
  a_a1jp
canEqTyVar
  a_a1jp
  UArray Int Double
  Is-swapped
Following bound tyvar a_a1jp = FlatVector
newWantedEvVar/cache miss [W] cobox_a1lW :: FlatVector ~ FlatVector
setEvBind
  ev = cobox_a1lV
  tm  = CO Sym cobox_a1lW
rewriteEqEvidence
  [W] cobox_a1lV :: FlatVector ~ a_a1jp
  FlatVector
  FlatVector
  Sym cobox_a1lW
canEqTyVar2
  a_a1jp
  UArray Int Double
  Is-swapped
  FlatVector
  <FlatVector>_N
can_eq_nc
  [W] cobox_a1lW :: FlatVector ~ FlatVector
  FlatVector
  FlatVector
  UArray Int Double
  FlatVector
can_eq_nc
  [W] cobox_a1lW :: FlatVector ~ FlatVector
  UArray Int Double
  FlatVector
  UArray Int Double
  FlatVector
newWantedEvVar/cache miss [W] cobox_a1lX :: Int ~ Int
newWantedEvVar/cache miss [W] cobox_a1lY :: Double ~ Double
setEvBind
  ev = cobox_a1lW
  tm  = CO UArray cobox_a1lX cobox_a1lY_N
canEvNC:eq
  Int
  Int
can_eq_nc
  [W] cobox_a1lX :: Int ~ Int
  Int
  Int
  Int
  Int
setEvBind
  ev = cobox_a1lX
  tm  = CO <Int>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1lY :: Double
                                 ~ Double [" a type equality [FlatVector]
                                                             ~
                                                             [a_a1jp] " p4.hs:18:40-43] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1lY :: Double
                                  ~ Double [" a type equality [FlatVector]
                                                              ~
                                                              [a_a1jp] " p4.hs:18:40-43] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1lY :: Double ~ Double [" a type equality [FlatVector]
                                                       ~
                                                       [a_a1jp] " p4.hs:18:40-43] (CNonCanonical)
canEvNC:eq
  Double
  Double
can_eq_nc
  [W] cobox_a1lY :: Double ~ Double
  Double
  Double
  Double
  Double
setEvBind
  ev = cobox_a1lY
  tm  = CO <Double>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1jD :: (m_a1jy a_a1jA
                                  -> (a_a1jA -> m_a1jy b_a1jB) -> m_a1jy b_a1jB)
                                 ~ (t_a1jt
                                    -> (t_a1ju -> t_a1jv) -> IO ()) [" a type equality m_a1jy a_a1jA
                                                                                       -> (a_a1jA
                                                                                           -> m_a1jy b_a1jB)
                                                                                       -> m_a1jy b_a1jB
                                                                                       ~
                                                                                       t_a1jt
                                                                                       -> (t_a1ju
                                                                                           -> t_a1jv)
                                                                                       -> IO
                                                                                            () " p4.hs:19:11-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1jD :: (m_a1jy a_a1jA
                                   -> (a_a1jA -> m_a1jy b_a1jB) -> m_a1jy b_a1jB)
                                  ~ (t_a1jt
                                     -> (t_a1ju -> t_a1jv)
                                     -> IO ()) [" a type equality m_a1jy a_a1jA
                                                                  -> (a_a1jA -> m_a1jy b_a1jB)
                                                                  -> m_a1jy b_a1jB
                                                                  ~
                                                                  t_a1jt
                                                                  -> (t_a1ju -> t_a1jv)
                                                                  -> IO
                                                                       () " p4.hs:19:11-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1jD :: (m_a1jy a_a1jA
                     -> (a_a1jA -> m_a1jy b_a1jB) -> m_a1jy b_a1jB)
                    ~ (t_a1jt
                       -> (t_a1ju -> t_a1jv) -> IO ()) [" a type equality m_a1jy a_a1jA
                                                                          -> (a_a1jA
                                                                              -> m_a1jy b_a1jB)
                                                                          -> m_a1jy b_a1jB
                                                                          ~
                                                                          t_a1jt
                                                                          -> (t_a1ju -> t_a1jv)
                                                                          -> IO
                                                                               () " p4.hs:19:11-23] (CNonCanonical)
canEvNC:eq
  m_a1jy a_a1jA -> (a_a1jA -> m_a1jy b_a1jB) -> m_a1jy b_a1jB
  t_a1jt -> (t_a1ju -> t_a1jv) -> IO ()
can_eq_nc
  [W] cobox_a1jD :: (m_a1jy a_a1jA
                     -> (a_a1jA -> m_a1jy b_a1jB) -> m_a1jy b_a1jB)
                    ~ (t_a1jt -> (t_a1ju -> t_a1jv) -> IO ())
  m_a1jy a_a1jA -> (a_a1jA -> m_a1jy b_a1jB) -> m_a1jy b_a1jB
  m_a1jy a_a1jA -> (a_a1jA -> m_a1jy b_a1jB) -> m_a1jy b_a1jB
  t_a1jt -> (t_a1ju -> t_a1jv) -> IO ()
  t_a1jt -> (t_a1ju -> t_a1jv) -> IO ()
newWantedEvVar/cache miss [W] cobox_a1lZ :: m_a1jy a_a1jA ~ t_a1jt
newWantedEvVar/cache miss
  [W] cobox_a1m0 :: ((a_a1jA -> m_a1jy b_a1jB) -> m_a1jy b_a1jB)
                    ~ ((t_a1ju -> t_a1jv) -> IO ())
setEvBind
  ev = cobox_a1jD
  tm  = CO cobox_a1lZ -> cobox_a1m0
canEvNC:eq
  m_a1jy a_a1jA
  t_a1jt
can_eq_nc
  [W] cobox_a1lZ :: m_a1jy a_a1jA ~ t_a1jt
  m_a1jy a_a1jA
  m_a1jy a_a1jA
  t_a1jt
  t_a1jt
canEqTyVar
  t_a1jt
  m_a1jy a_a1jA
  Is-swapped
flatten/appty
  m_a1jy
  a_a1jA
  m_a1jy
  <m_a1jy>_N
  a_a1jA
  <a_a1jA>_N
newWantedEvVar/cache miss [W] cobox_a1m1 :: t_a1jt ~ m_a1jy a_a1jA
setEvBind
  ev = cobox_a1lZ
  tm  = CO Sym cobox_a1m1
rewriteEqEvidence
  [W] cobox_a1lZ :: m_a1jy a_a1jA ~ t_a1jt
  t_a1jt
  m_a1jy a_a1jA
  Sym cobox_a1m1
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1m1 :: t_a1jt
                                  ~ m_a1jy a_a1jA [" a type equality m_a1jy a_a1jA
                                                                     -> (a_a1jA -> m_a1jy b_a1jB)
                                                                     -> m_a1jy b_a1jB
                                                                     ~
                                                                     t_a1jt
                                                                     -> (t_a1ju -> t_a1jv)
                                                                     -> IO
                                                                          () " p4.hs:19:11-23] (CTyEqCan)
Sneaky unification:
  Unifies: t_a1jt := m_a1jy a_a1jA
  Coercion: t_a1jt ~ m_a1jy a_a1jA
  Left Kind is: *
  Right Kind is: *
setWantedTyBind t_a1jt := m_a1jy a_a1jA
setEvBind
  ev = cobox_a1m1
  tm  = CO <m_a1jy a_a1jA>_N
kickOutRewritable
  tv =  t_a1jt
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
19[<C:0,F:0>] [W] cobox_a1m1 :: t_a1jt
                                ~ m_a1jy a_a1jA: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1m0 :: ((a_a1jA -> m_a1jy b_a1jB)
                                  -> m_a1jy b_a1jB)
                                 ~ ((t_a1ju -> t_a1jv) -> IO ()) [" a type equality m_a1jy a_a1jA
                                                                                    -> (a_a1jA
                                                                                        -> m_a1jy b_a1jB)
                                                                                    -> m_a1jy b_a1jB
                                                                                    ~
                                                                                    t_a1jt
                                                                                    -> (t_a1ju
                                                                                        -> t_a1jv)
                                                                                    -> IO
                                                                                         () " p4.hs:19:11-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1m0 :: ((a_a1jA -> m_a1jy b_a1jB)
                                   -> m_a1jy b_a1jB)
                                  ~ ((t_a1ju -> t_a1jv) -> IO ()) [" a type equality m_a1jy a_a1jA
                                                                                     -> (a_a1jA
                                                                                         -> m_a1jy b_a1jB)
                                                                                     -> m_a1jy b_a1jB
                                                                                     ~
                                                                                     t_a1jt
                                                                                     -> (t_a1ju
                                                                                         -> t_a1jv)
                                                                                     -> IO
                                                                                          () " p4.hs:19:11-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1m0 :: ((a_a1jA -> m_a1jy b_a1jB) -> m_a1jy b_a1jB)
                    ~ ((t_a1ju -> t_a1jv) -> IO ()) [" a type equality m_a1jy a_a1jA
                                                                       -> (a_a1jA -> m_a1jy b_a1jB)
                                                                       -> m_a1jy b_a1jB
                                                                       ~
                                                                       t_a1jt
                                                                       -> (t_a1ju -> t_a1jv)
                                                                       -> IO
                                                                            () " p4.hs:19:11-23] (CNonCanonical)
canEvNC:eq
  (a_a1jA -> m_a1jy b_a1jB) -> m_a1jy b_a1jB
  (t_a1ju -> t_a1jv) -> IO ()
can_eq_nc
  [W] cobox_a1m0 :: ((a_a1jA -> m_a1jy b_a1jB) -> m_a1jy b_a1jB)
                    ~ ((t_a1ju -> t_a1jv) -> IO ())
  (a_a1jA -> m_a1jy b_a1jB) -> m_a1jy b_a1jB
  (a_a1jA -> m_a1jy b_a1jB) -> m_a1jy b_a1jB
  (t_a1ju -> t_a1jv) -> IO ()
  (t_a1ju -> t_a1jv) -> IO ()
newWantedEvVar/cache miss
  [W] cobox_a1m2 :: (a_a1jA -> m_a1jy b_a1jB) ~ (t_a1ju -> t_a1jv)
newWantedEvVar/cache miss [W] cobox_a1m3 :: m_a1jy b_a1jB ~ IO ()
setEvBind
  ev = cobox_a1m0
  tm  = CO cobox_a1m2 -> cobox_a1m3
canEvNC:eq
  a_a1jA -> m_a1jy b_a1jB
  t_a1ju -> t_a1jv
can_eq_nc
  [W] cobox_a1m2 :: (a_a1jA -> m_a1jy b_a1jB) ~ (t_a1ju -> t_a1jv)
  a_a1jA -> m_a1jy b_a1jB
  a_a1jA -> m_a1jy b_a1jB
  t_a1ju -> t_a1jv
  t_a1ju -> t_a1jv
newWantedEvVar/cache miss [W] cobox_a1m4 :: a_a1jA ~ t_a1ju
newWantedEvVar/cache miss [W] cobox_a1m5 :: m_a1jy b_a1jB ~ t_a1jv
setEvBind
  ev = cobox_a1m2
  tm  = CO cobox_a1m4 -> cobox_a1m5
canEvNC:eq
  a_a1jA
  t_a1ju
can_eq_nc
  [W] cobox_a1m4 :: a_a1jA ~ t_a1ju
  a_a1jA
  a_a1jA
  t_a1ju
  t_a1ju
canEqTyVar
  a_a1jA
  t_a1ju
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1m4 :: a_a1jA
                                  ~ t_a1ju [" a type equality m_a1jy a_a1jA
                                                              -> (a_a1jA -> m_a1jy b_a1jB)
                                                              -> m_a1jy b_a1jB
                                                              ~
                                                              t_a1jt
                                                              -> (t_a1ju -> t_a1jv)
                                                              -> IO () " p4.hs:19:11-23] (CTyEqCan)
Sneaky unification:
  Unifies: t_a1ju := a_a1jA
  Coercion: t_a1ju ~ a_a1jA
  Left Kind is: *
  Right Kind is: *
setWantedTyBind t_a1ju := a_a1jA
setEvBind
  ev = cobox_a1m4
  tm  = CO <a_a1jA>_N
kickOutRewritable
  tv =  t_a1ju
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
20[<C:0,F:0>] [W] cobox_a1m4 :: a_a1jA
                                ~ t_a1ju: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1m5 :: m_a1jy b_a1jB
                                 ~ t_a1jv [" a type equality m_a1jy a_a1jA
                                                             -> (a_a1jA -> m_a1jy b_a1jB)
                                                             -> m_a1jy b_a1jB
                                                             ~
                                                             t_a1jt
                                                             -> (t_a1ju -> t_a1jv)
                                                             -> IO
                                                                  () " p4.hs:19:11-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1m5 :: m_a1jy b_a1jB
                                  ~ t_a1jv [" a type equality m_a1jy a_a1jA
                                                              -> (a_a1jA -> m_a1jy b_a1jB)
                                                              -> m_a1jy b_a1jB
                                                              ~
                                                              t_a1jt
                                                              -> (t_a1ju -> t_a1jv)
                                                              -> IO
                                                                   () " p4.hs:19:11-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1m5 :: m_a1jy b_a1jB
                    ~ t_a1jv [" a type equality m_a1jy a_a1jA
                                                -> (a_a1jA -> m_a1jy b_a1jB) -> m_a1jy b_a1jB
                                                ~
                                                t_a1jt
                                                -> (t_a1ju -> t_a1jv)
                                                -> IO () " p4.hs:19:11-23] (CNonCanonical)
canEvNC:eq
  m_a1jy b_a1jB
  t_a1jv
can_eq_nc
  [W] cobox_a1m5 :: m_a1jy b_a1jB ~ t_a1jv
  m_a1jy b_a1jB
  m_a1jy b_a1jB
  t_a1jv
  t_a1jv
canEqTyVar
  t_a1jv
  m_a1jy b_a1jB
  Is-swapped
flatten/appty
  m_a1jy
  b_a1jB
  m_a1jy
  <m_a1jy>_N
  b_a1jB
  <b_a1jB>_N
newWantedEvVar/cache miss [W] cobox_a1m6 :: t_a1jv ~ m_a1jy b_a1jB
setEvBind
  ev = cobox_a1m5
  tm  = CO Sym cobox_a1m6
rewriteEqEvidence
  [W] cobox_a1m5 :: m_a1jy b_a1jB ~ t_a1jv
  t_a1jv
  m_a1jy b_a1jB
  Sym cobox_a1m6
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1m6 :: t_a1jv
                                  ~ m_a1jy b_a1jB [" a type equality m_a1jy a_a1jA
                                                                     -> (a_a1jA -> m_a1jy b_a1jB)
                                                                     -> m_a1jy b_a1jB
                                                                     ~
                                                                     t_a1jt
                                                                     -> (t_a1ju -> t_a1jv)
                                                                     -> IO
                                                                          () " p4.hs:19:11-23] (CTyEqCan)
Sneaky unification:
  Unifies: t_a1jv := m_a1jy b_a1jB
  Coercion: t_a1jv ~ m_a1jy b_a1jB
  Left Kind is: *
  Right Kind is: *
setWantedTyBind t_a1jv := m_a1jy b_a1jB
setEvBind
  ev = cobox_a1m6
  tm  = CO <m_a1jy b_a1jB>_N
kickOutRewritable
  tv =  t_a1jv
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
21[<C:0,F:0>] [W] cobox_a1m6 :: t_a1jv
                                ~ m_a1jy b_a1jB: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1m3 :: m_a1jy b_a1jB
                                 ~ IO () [" a type equality m_a1jy a_a1jA
                                                            -> (a_a1jA -> m_a1jy b_a1jB)
                                                            -> m_a1jy b_a1jB
                                                            ~
                                                            t_a1jt
                                                            -> (t_a1ju -> t_a1jv)
                                                            -> IO
                                                                 () " p4.hs:19:11-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1m3 :: m_a1jy b_a1jB
                                  ~ IO () [" a type equality m_a1jy a_a1jA
                                                             -> (a_a1jA -> m_a1jy b_a1jB)
                                                             -> m_a1jy b_a1jB
                                                             ~
                                                             t_a1jt
                                                             -> (t_a1ju -> t_a1jv)
                                                             -> IO
                                                                  () " p4.hs:19:11-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1m3 :: m_a1jy b_a1jB
                    ~ IO () [" a type equality m_a1jy a_a1jA
                                               -> (a_a1jA -> m_a1jy b_a1jB) -> m_a1jy b_a1jB
                                               ~
                                               t_a1jt
                                               -> (t_a1ju -> t_a1jv)
                                               -> IO () " p4.hs:19:11-23] (CNonCanonical)
canEvNC:eq
  m_a1jy b_a1jB
  IO ()
can_eq_nc
  [W] cobox_a1m3 :: m_a1jy b_a1jB ~ IO ()
  m_a1jy b_a1jB
  m_a1jy b_a1jB
  IO ()
  IO ()
can_eq_app 1
  [W] cobox_a1m3 :: m_a1jy b_a1jB ~ IO ()
  Not-swapped
  m_a1jy
  b_a1jB
  IO ()
can_eq_app 2
  [W] cobox_a1m3 :: m_a1jy b_a1jB ~ IO ()
  m_a1jy
newWantedEvVar/cache miss [W] cobox_a1m7 :: m_a1jy ~ IO
newWantedEvVar/cache miss [W] cobox_a1m8 :: b_a1jB ~ ()
setEvBind
  ev = cobox_a1m3
  tm  = CO cobox_a1m7 cobox_a1m8
canEvNC:eq
  m_a1jy
  IO
can_eq_nc
  [W] cobox_a1m7 :: m_a1jy ~ IO
  m_a1jy
  m_a1jy
  IO
  IO
canEqTyVar
  m_a1jy
  IO
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1m7 :: m_a1jy
                                  ~ IO [" a type equality m_a1jy a_a1jA
                                                          -> (a_a1jA -> m_a1jy b_a1jB)
                                                          -> m_a1jy b_a1jB
                                                          ~
                                                          t_a1jt
                                                          -> (t_a1ju -> t_a1jv)
                                                          -> IO () " p4.hs:19:11-23] (CTyEqCan)
Sneaky unification:
  Unifies: m_a1jy := IO
  Coercion: m_a1jy ~ IO
  Left Kind is: * -> *
  Right Kind is: * -> *
setWantedTyBind m_a1jy := IO
setEvBind
  ev = cobox_a1m7
  tm  = CO <IO>_N
kickOutRewritable
  tv =  m_a1jy
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
22[<C:0,F:0>] [W] cobox_a1m7 :: m_a1jy ~ IO: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1m8 :: b_a1jB
                                 ~ () [" a type equality m_a1jy a_a1jA
                                                         -> (a_a1jA -> m_a1jy b_a1jB)
                                                         -> m_a1jy b_a1jB
                                                         ~
                                                         t_a1jt
                                                         -> (t_a1ju -> t_a1jv)
                                                         -> IO () " p4.hs:19:11-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1m8 :: b_a1jB
                                  ~ () [" a type equality m_a1jy a_a1jA
                                                          -> (a_a1jA -> m_a1jy b_a1jB)
                                                          -> m_a1jy b_a1jB
                                                          ~
                                                          t_a1jt
                                                          -> (t_a1ju -> t_a1jv)
                                                          -> IO () " p4.hs:19:11-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1m8 :: b_a1jB ~ () [" a type equality m_a1jy a_a1jA
                                                   -> (a_a1jA -> m_a1jy b_a1jB) -> m_a1jy b_a1jB
                                                   ~
                                                   t_a1jt
                                                   -> (t_a1ju -> t_a1jv)
                                                   -> IO () " p4.hs:19:11-23] (CNonCanonical)
canEvNC:eq
  b_a1jB
  ()
can_eq_nc
  [W] cobox_a1m8 :: b_a1jB ~ ()
  b_a1jB
  b_a1jB
  ()
  ()
canEqTyVar
  b_a1jB
  ()
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1m8 :: b_a1jB
                                  ~ () [" a type equality m_a1jy a_a1jA
                                                          -> (a_a1jA -> m_a1jy b_a1jB)
                                                          -> m_a1jy b_a1jB
                                                          ~
                                                          t_a1jt
                                                          -> (t_a1ju -> t_a1jv)
                                                          -> IO () " p4.hs:19:11-23] (CTyEqCan)
Sneaky unification:
  Unifies: b_a1jB := ()
  Coercion: b_a1jB ~ ()
  Left Kind is: *
  Right Kind is: *
setWantedTyBind b_a1jB := ()
setEvBind
  ev = cobox_a1m8
  tm  = CO <()>_N
kickOutRewritable
  tv =  b_a1jB
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
23[<C:0,F:0>] [W] cobox_a1m8 :: b_a1jB ~ (): Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1k5 :: m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
                                 ~ t_a1jt [" a type equality m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
                                                             ~
                                                             t_a1jt " p4.hs:19:16-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1k5 :: m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
                                  ~ t_a1jt [" a type equality m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
                                                              ~
                                                              t_a1jt " p4.hs:19:16-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1k5 :: m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
                    ~ t_a1jt [" a type equality m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
                                                ~
                                                t_a1jt " p4.hs:19:16-23] (CNonCanonical)
canEvNC:eq
  m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
  t_a1jt
can_eq_nc
  [W] cobox_a1k5 :: m_a1k0 (b_a1k1 i_a1jY e_a1jZ) ~ t_a1jt
  m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
  m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
  t_a1jt
  t_a1jt
canEqTyVar
  t_a1jt
  m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
  Is-swapped
Following bound tyvar t_a1jt = m_a1jy a_a1jA
newWantedEvVar/cache miss
  [W] cobox_a1m9 :: m_a1jy a_a1jA ~ m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
setEvBind
  ev = cobox_a1k5
  tm  = CO Sym cobox_a1m9
rewriteEqEvidence
  [W] cobox_a1k5 :: m_a1k0 (b_a1k1 i_a1jY e_a1jZ) ~ t_a1jt
  m_a1jy a_a1jA
  m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
  Sym cobox_a1m9
canEqTyVar2
  t_a1jt
  m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
  Is-swapped
  m_a1jy a_a1jA
  <m_a1jy a_a1jA>_N
can_eq_nc
  [W] cobox_a1m9 :: m_a1jy a_a1jA ~ m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
  m_a1jy a_a1jA
  m_a1jy a_a1jA
  m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
  m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
can_eq_app 1
  [W] cobox_a1m9 :: m_a1jy a_a1jA ~ m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
  Not-swapped
  m_a1jy
  a_a1jA
  m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
Following bound tyvar m_a1jy = IO
can_eq_app 2
  [W] cobox_a1m9 :: m_a1jy a_a1jA ~ m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
  IO
can_eq_app 3
  [W] cobox_a1m9 :: m_a1jy a_a1jA ~ m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
  IO a_a1jA
  <IO a_a1jA>_N
can_eq_app 4
  [W] cobox_a1m9 :: m_a1jy a_a1jA ~ m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
  IO a_a1jA
  <IO a_a1jA>_N
can_eq_nc
  [W] cobox_a1m9 :: IO a_a1jA ~ m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
  IO a_a1jA
  IO a_a1jA
  m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
  m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
can_eq_app 1
  [W] cobox_a1m9 :: IO a_a1jA ~ m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
  Is-swapped
  m_a1k0
  b_a1k1 i_a1jY e_a1jZ
  IO a_a1jA
can_eq_app 2
  [W] cobox_a1m9 :: IO a_a1jA ~ m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
  m_a1k0
newWantedEvVar/cache miss [W] cobox_a1ma :: IO ~ m_a1k0
newWantedEvVar/cache miss
  [W] cobox_a1mb :: a_a1jA ~ b_a1k1 i_a1jY e_a1jZ
setEvBind
  ev = cobox_a1m9
  tm  = CO cobox_a1ma cobox_a1mb
canEvNC:eq
  IO
  m_a1k0
can_eq_nc
  [W] cobox_a1ma :: IO ~ m_a1k0
  IO
  IO
  m_a1k0
  m_a1k0
canEqTyVar
  m_a1k0
  IO
  Is-swapped
newWantedEvVar/cache miss [W] cobox_a1mc :: m_a1k0 ~ IO
setEvBind
  ev = cobox_a1ma
  tm  = CO Sym cobox_a1mc
rewriteEqEvidence
  [W] cobox_a1ma :: IO ~ m_a1k0
  m_a1k0
  IO
  Sym cobox_a1mc
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1mc :: m_a1k0
                                  ~ IO [" a type equality m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
                                                          ~
                                                          t_a1jt " p4.hs:19:16-23] (CTyEqCan)
Sneaky unification:
  Unifies: m_a1k0 := IO
  Coercion: m_a1k0 ~ IO
  Left Kind is: * -> *
  Right Kind is: * -> *
setWantedTyBind m_a1k0 := IO
setEvBind
  ev = cobox_a1mc
  tm  = CO <IO>_N
kickOutRewritable
  tv =  m_a1k0
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
24[<C:0,F:0>] [W] cobox_a1mc :: m_a1k0 ~ IO: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1mb :: a_a1jA
                                 ~ b_a1k1 i_a1jY e_a1jZ [" a type equality m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
                                                                           ~
                                                                           t_a1jt " p4.hs:19:16-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1mb :: a_a1jA
                                  ~ b_a1k1 i_a1jY e_a1jZ [" a type equality m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
                                                                            ~
                                                                            t_a1jt " p4.hs:19:16-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1mb :: a_a1jA
                    ~ b_a1k1 i_a1jY e_a1jZ [" a type equality m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
                                                              ~
                                                              t_a1jt " p4.hs:19:16-23] (CNonCanonical)
canEvNC:eq
  a_a1jA
  b_a1k1 i_a1jY e_a1jZ
can_eq_nc
  [W] cobox_a1mb :: a_a1jA ~ b_a1k1 i_a1jY e_a1jZ
  a_a1jA
  a_a1jA
  b_a1k1 i_a1jY e_a1jZ
  b_a1k1 i_a1jY e_a1jZ
canEqTyVar
  a_a1jA
  b_a1k1 i_a1jY e_a1jZ
  Not-swapped
flatten/appty
  b_a1k1
  i_a1jY
  b_a1k1
  <b_a1k1>_N
  i_a1jY
  <i_a1jY>_N
flatten/appty
  b_a1k1 i_a1jY
  e_a1jZ
  b_a1k1 i_a1jY
  <b_a1k1 i_a1jY>_N
  e_a1jZ
  <e_a1jZ>_N
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1mb :: a_a1jA
                                  ~ b_a1k1 i_a1jY e_a1jZ [" a type equality m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
                                                                            ~
                                                                            t_a1jt " p4.hs:19:16-23] (CTyEqCan)
Sneaky unification:
  Unifies: a_a1jA := b_a1k1 i_a1jY e_a1jZ
  Coercion: a_a1jA ~ b_a1k1 i_a1jY e_a1jZ
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_a1jA := b_a1k1 i_a1jY e_a1jZ
setEvBind
  ev = cobox_a1mb
  tm  = CO <b_a1k1 i_a1jY e_a1jZ>_N
kickOutRewritable
  tv =  a_a1jA
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
25[<C:0,F:0>] [W] cobox_a1mb :: a_a1jA
                                ~ b_a1k1 i_a1jY e_a1jZ: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1k6 :: Vector FlatVector
                                 ~ a_a1jX i_a1jY e_a1jZ [" a type equality Vector FlatVector
                                                                           ~
                                                                           a_a1jX i_a1jY e_a1jZ " p4.hs:19:21-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1k6 :: Vector FlatVector
                                  ~ a_a1jX i_a1jY e_a1jZ [" a type equality Vector FlatVector
                                                                            ~
                                                                            a_a1jX i_a1jY e_a1jZ " p4.hs:19:21-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1k6 :: Vector FlatVector
                    ~ a_a1jX i_a1jY e_a1jZ [" a type equality Vector FlatVector
                                                              ~
                                                              a_a1jX i_a1jY e_a1jZ " p4.hs:19:21-23] (CNonCanonical)
canEvNC:eq
  Vector FlatVector
  a_a1jX i_a1jY e_a1jZ
can_eq_nc
  [W] cobox_a1k6 :: Vector FlatVector ~ a_a1jX i_a1jY e_a1jZ
  Vector FlatVector
  Vector FlatVector
  a_a1jX i_a1jY e_a1jZ
  a_a1jX i_a1jY e_a1jZ
can_eq_nc
  [W] cobox_a1k6 :: Vector FlatVector ~ a_a1jX i_a1jY e_a1jZ
  Array Int FlatVector
  Vector FlatVector
  a_a1jX i_a1jY e_a1jZ
  a_a1jX i_a1jY e_a1jZ
can_eq_app 1
  [W] cobox_a1k6 :: Vector FlatVector ~ a_a1jX i_a1jY e_a1jZ
  Is-swapped
  a_a1jX i_a1jY
  e_a1jZ
  Array Int FlatVector
flatten/appty
  a_a1jX
  i_a1jY
  a_a1jX
  <a_a1jX>_N
  i_a1jY
  <i_a1jY>_N
can_eq_app 2
  [W] cobox_a1k6 :: Vector FlatVector ~ a_a1jX i_a1jY e_a1jZ
  a_a1jX i_a1jY
newWantedEvVar/cache miss
  [W] cobox_a1md :: Array Int ~ a_a1jX i_a1jY
newWantedEvVar/cache miss [W] cobox_a1me :: FlatVector ~ e_a1jZ
setEvBind
  ev = cobox_a1k6
  tm  = CO cobox_a1md cobox_a1me
canEvNC:eq
  Array Int
  a_a1jX i_a1jY
can_eq_nc
  [W] cobox_a1md :: Array Int ~ a_a1jX i_a1jY
  Array Int
  Array Int
  a_a1jX i_a1jY
  a_a1jX i_a1jY
can_eq_app 1
  [W] cobox_a1md :: Array Int ~ a_a1jX i_a1jY
  Is-swapped
  a_a1jX
  i_a1jY
  Array Int
can_eq_app 2
  [W] cobox_a1md :: Array Int ~ a_a1jX i_a1jY
  a_a1jX
newWantedEvVar/cache miss [W] cobox_a1mf :: Array ~ a_a1jX
newWantedEvVar/cache miss [W] cobox_a1mg :: Int ~ i_a1jY
setEvBind
  ev = cobox_a1md
  tm  = CO cobox_a1mf cobox_a1mg
canEvNC:eq
  Array
  a_a1jX
can_eq_nc
  [W] cobox_a1mf :: Array ~ a_a1jX
  Array
  Array
  a_a1jX
  a_a1jX
canEqTyVar
  a_a1jX
  Array
  Is-swapped
newWantedEvVar/cache miss [W] cobox_a1mh :: a_a1jX ~ Array
setEvBind
  ev = cobox_a1mf
  tm  = CO Sym cobox_a1mh
rewriteEqEvidence
  [W] cobox_a1mf :: Array ~ a_a1jX
  a_a1jX
  Array
  Sym cobox_a1mh
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1mh :: a_a1jX
                                  ~ Array [" a type equality Vector FlatVector
                                                             ~
                                                             a_a1jX i_a1jY e_a1jZ " p4.hs:19:21-23] (CTyEqCan)
Sneaky unification:
  Unifies: a_a1jX := Array
  Coercion: a_a1jX ~ Array
  Left Kind is: * -> * -> *
  Right Kind is: * -> * -> *
setWantedTyBind a_a1jX := Array
setEvBind
  ev = cobox_a1mh
  tm  = CO <Array>_N
kickOutRewritable
  tv =  a_a1jX
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
26[<C:0,F:0>] [W] cobox_a1mh :: a_a1jX
                                ~ Array: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1mg :: Int
                                 ~ i_a1jY [" a type equality Vector FlatVector
                                                             ~
                                                             a_a1jX i_a1jY e_a1jZ " p4.hs:19:21-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1mg :: Int
                                  ~ i_a1jY [" a type equality Vector FlatVector
                                                              ~
                                                              a_a1jX i_a1jY e_a1jZ " p4.hs:19:21-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1mg :: Int ~ i_a1jY [" a type equality Vector FlatVector
                                                    ~
                                                    a_a1jX i_a1jY e_a1jZ " p4.hs:19:21-23] (CNonCanonical)
canEvNC:eq
  Int
  i_a1jY
can_eq_nc
  [W] cobox_a1mg :: Int ~ i_a1jY
  Int
  Int
  i_a1jY
  i_a1jY
canEqTyVar
  i_a1jY
  Int
  Is-swapped
newWantedEvVar/cache miss [W] cobox_a1mi :: i_a1jY ~ Int
setEvBind
  ev = cobox_a1mg
  tm  = CO Sym cobox_a1mi
rewriteEqEvidence
  [W] cobox_a1mg :: Int ~ i_a1jY
  i_a1jY
  Int
  Sym cobox_a1mi
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1mi :: i_a1jY
                                  ~ Int [" a type equality Vector FlatVector
                                                           ~
                                                           a_a1jX i_a1jY e_a1jZ " p4.hs:19:21-23] (CTyEqCan)
Sneaky unification:
  Unifies: i_a1jY := Int
  Coercion: i_a1jY ~ Int
  Left Kind is: *
  Right Kind is: *
setWantedTyBind i_a1jY := Int
setEvBind
  ev = cobox_a1mi
  tm  = CO <Int>_N
kickOutRewritable
  tv =  i_a1jY
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
27[<C:0,F:0>] [W] cobox_a1mi :: i_a1jY ~ Int: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1me :: FlatVector
                                 ~ e_a1jZ [" a type equality Vector FlatVector
                                                             ~
                                                             a_a1jX i_a1jY e_a1jZ " p4.hs:19:21-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1me :: FlatVector
                                  ~ e_a1jZ [" a type equality Vector FlatVector
                                                              ~
                                                              a_a1jX i_a1jY e_a1jZ " p4.hs:19:21-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1me :: FlatVector ~ e_a1jZ [" a type equality Vector
                                                             FlatVector
                                                           ~
                                                           a_a1jX i_a1jY e_a1jZ " p4.hs:19:21-23] (CNonCanonical)
canEvNC:eq
  FlatVector
  e_a1jZ
can_eq_nc
  [W] cobox_a1me :: FlatVector ~ e_a1jZ
  FlatVector
  FlatVector
  e_a1jZ
  e_a1jZ
can_eq_nc
  [W] cobox_a1me :: FlatVector ~ e_a1jZ
  UArray Int Double
  FlatVector
  e_a1jZ
  e_a1jZ
canEqTyVar
  e_a1jZ
  UArray Int Double
  Is-swapped
newWantedEvVar/cache miss [W] cobox_a1mj :: e_a1jZ ~ FlatVector
setEvBind
  ev = cobox_a1me
  tm  = CO Sym cobox_a1mj
rewriteEqEvidence
  [W] cobox_a1me :: FlatVector ~ e_a1jZ
  e_a1jZ
  FlatVector
  Sym cobox_a1mj
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1mj :: e_a1jZ
                                  ~ FlatVector [" a type equality Vector FlatVector
                                                                  ~
                                                                  a_a1jX i_a1jY e_a1jZ " p4.hs:19:21-23] (CTyEqCan)
Sneaky unification:
  Unifies: e_a1jZ := FlatVector
  Coercion: e_a1jZ ~ FlatVector
  Left Kind is: *
  Right Kind is: *
setWantedTyBind e_a1jZ := FlatVector
setEvBind
  ev = cobox_a1mj
  tm  = CO <FlatVector>_N
kickOutRewritable
  tv =  e_a1jZ
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
28[<C:0,F:0>] [W] cobox_a1mj :: e_a1jZ
                                ~ FlatVector: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1kc :: m_a1k8 a_a1ka
                                 ~ t_a1jv [" a type equality m_a1k8 a_a1ka
                                                             ~
                                                             t_a1jv " p4.hs:20:11-19] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1kc :: m_a1k8 a_a1ka
                                  ~ t_a1jv [" a type equality m_a1k8 a_a1ka
                                                              ~
                                                              t_a1jv " p4.hs:20:11-19] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1kc :: m_a1k8 a_a1ka
                    ~ t_a1jv [" a type equality m_a1k8 a_a1ka
                                                ~
                                                t_a1jv " p4.hs:20:11-19] (CNonCanonical)
canEvNC:eq
  m_a1k8 a_a1ka
  t_a1jv
can_eq_nc
  [W] cobox_a1kc :: m_a1k8 a_a1ka ~ t_a1jv
  m_a1k8 a_a1ka
  m_a1k8 a_a1ka
  t_a1jv
  t_a1jv
canEqTyVar
  t_a1jv
  m_a1k8 a_a1ka
  Is-swapped
Following bound tyvar t_a1jv = m_a1jy b_a1jB
newWantedEvVar/cache miss
  [W] cobox_a1mk :: m_a1jy b_a1jB ~ m_a1k8 a_a1ka
setEvBind
  ev = cobox_a1kc
  tm  = CO Sym cobox_a1mk
rewriteEqEvidence
  [W] cobox_a1kc :: m_a1k8 a_a1ka ~ t_a1jv
  m_a1jy b_a1jB
  m_a1k8 a_a1ka
  Sym cobox_a1mk
canEqTyVar2
  t_a1jv
  m_a1k8 a_a1ka
  Is-swapped
  m_a1jy b_a1jB
  <m_a1jy b_a1jB>_N
can_eq_nc
  [W] cobox_a1mk :: m_a1jy b_a1jB ~ m_a1k8 a_a1ka
  m_a1jy b_a1jB
  m_a1jy b_a1jB
  m_a1k8 a_a1ka
  m_a1k8 a_a1ka
can_eq_app 1
  [W] cobox_a1mk :: m_a1jy b_a1jB ~ m_a1k8 a_a1ka
  Not-swapped
  m_a1jy
  b_a1jB
  m_a1k8 a_a1ka
Following bound tyvar m_a1jy = IO
can_eq_app 2
  [W] cobox_a1mk :: m_a1jy b_a1jB ~ m_a1k8 a_a1ka
  IO
Following bound tyvar b_a1jB = ()
can_eq_app 3
  [W] cobox_a1mk :: m_a1jy b_a1jB ~ m_a1k8 a_a1ka
  IO ()
  <IO ()>_N
can_eq_app 4
  [W] cobox_a1mk :: m_a1jy b_a1jB ~ m_a1k8 a_a1ka
  IO ()
  <IO ()>_N
can_eq_nc
  [W] cobox_a1mk :: IO () ~ m_a1k8 a_a1ka
  IO ()
  IO ()
  m_a1k8 a_a1ka
  m_a1k8 a_a1ka
can_eq_app 1
  [W] cobox_a1mk :: IO () ~ m_a1k8 a_a1ka
  Is-swapped
  m_a1k8
  a_a1ka
  IO ()
can_eq_app 2
  [W] cobox_a1mk :: IO () ~ m_a1k8 a_a1ka
  m_a1k8
newWantedEvVar/cache miss [W] cobox_a1ml :: IO ~ m_a1k8
newWantedEvVar/cache miss [W] cobox_a1mm :: () ~ a_a1ka
setEvBind
  ev = cobox_a1mk
  tm  = CO cobox_a1ml cobox_a1mm
canEvNC:eq
  IO
  m_a1k8
can_eq_nc
  [W] cobox_a1ml :: IO ~ m_a1k8
  IO
  IO
  m_a1k8
  m_a1k8
canEqTyVar
  m_a1k8
  IO
  Is-swapped
newWantedEvVar/cache miss [W] cobox_a1mn :: m_a1k8 ~ IO
setEvBind
  ev = cobox_a1ml
  tm  = CO Sym cobox_a1mn
rewriteEqEvidence
  [W] cobox_a1ml :: IO ~ m_a1k8
  m_a1k8
  IO
  Sym cobox_a1mn
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1mn :: m_a1k8
                                  ~ IO [" a type equality m_a1k8 a_a1ka
                                                          ~
                                                          t_a1jv " p4.hs:20:11-19] (CTyEqCan)
Sneaky unification:
  Unifies: m_a1k8 := IO
  Coercion: m_a1k8 ~ IO
  Left Kind is: * -> *
  Right Kind is: * -> *
setWantedTyBind m_a1k8 := IO
setEvBind
  ev = cobox_a1mn
  tm  = CO <IO>_N
kickOutRewritable
  tv =  m_a1k8
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
29[<C:0,F:0>] [W] cobox_a1mn :: m_a1k8 ~ IO: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1mm :: ()
                                 ~ a_a1ka [" a type equality m_a1k8 a_a1ka
                                                             ~
                                                             t_a1jv " p4.hs:20:11-19] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1mm :: ()
                                  ~ a_a1ka [" a type equality m_a1k8 a_a1ka
                                                              ~
                                                              t_a1jv " p4.hs:20:11-19] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1mm :: () ~ a_a1ka [" a type equality m_a1k8 a_a1ka
                                                   ~
                                                   t_a1jv " p4.hs:20:11-19] (CNonCanonical)
canEvNC:eq
  ()
  a_a1ka
can_eq_nc
  [W] cobox_a1mm :: () ~ a_a1ka
  ()
  ()
  a_a1ka
  a_a1ka
canEqTyVar
  a_a1ka
  ()
  Is-swapped
newWantedEvVar/cache miss [W] cobox_a1mo :: a_a1ka ~ ()
setEvBind
  ev = cobox_a1mm
  tm  = CO Sym cobox_a1mo
rewriteEqEvidence
  [W] cobox_a1mm :: () ~ a_a1ka
  a_a1ka
  ()
  Sym cobox_a1mo
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1mo :: a_a1ka
                                  ~ () [" a type equality m_a1k8 a_a1ka
                                                          ~
                                                          t_a1jv " p4.hs:20:11-19] (CTyEqCan)
Sneaky unification:
  Unifies: a_a1ka := ()
  Coercion: a_a1ka ~ ()
  Left Kind is: *
  Right Kind is: *
setWantedTyBind a_a1ka := ()
setEvBind
  ev = cobox_a1mo
  tm  = CO <()>_N
kickOutRewritable
  tv =  a_a1ka
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
30[<C:0,F:0>] [W] cobox_a1mo :: a_a1ka ~ (): Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1kd :: () ~ a_a1ka [" a type equality ()
                                                                ~
                                                                a_a1ka " p4.hs:20:18-19] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1kd :: () ~ a_a1ka [" a type equality ()
                                                                 ~
                                                                 a_a1ka " p4.hs:20:18-19] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1kd :: () ~ a_a1ka [" a type equality ()
                                                   ~
                                                   a_a1ka " p4.hs:20:18-19] (CNonCanonical)
canEvNC:eq
  ()
  a_a1ka
can_eq_nc
  [W] cobox_a1kd :: () ~ a_a1ka
  ()
  ()
  a_a1ka
  a_a1ka
canEqTyVar
  a_a1ka
  ()
  Is-swapped
Following bound tyvar a_a1ka = ()
newWantedEvVar/cache miss [W] cobox_a1mp :: () ~ ()
setEvBind
  ev = cobox_a1kd
  tm  = CO Sym cobox_a1mp
rewriteEqEvidence
  [W] cobox_a1kd :: () ~ a_a1ka
  ()
  ()
  Sym cobox_a1mp
canEqTyVar2
  a_a1ka
  ()
  Is-swapped
  ()
  <()>_N
can_eq_nc
  [W] cobox_a1mp :: () ~ ()
  ()
  ()
  ()
  ()
setEvBind
  ev = cobox_a1mp
  tm  = CO <()>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1kf :: IO ()
                                 ~ IO t_a1ke [" a type equality IO ()
                                                                ~
                                                                IO
                                                                  t_a1ke " p4.hs:13:1] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1kf :: IO ()
                                  ~ IO t_a1ke [" a type equality IO ()
                                                                 ~
                                                                 IO
                                                                   t_a1ke " p4.hs:13:1] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1kf :: IO () ~ IO t_a1ke [" a type equality IO ()
                                                         ~
                                                         IO t_a1ke " p4.hs:13:1] (CNonCanonical)
canEvNC:eq
  IO ()
  IO t_a1ke
can_eq_nc
  [W] cobox_a1kf :: IO () ~ IO t_a1ke
  IO ()
  IO ()
  IO t_a1ke
  IO t_a1ke
newWantedEvVar/cache miss [W] cobox_a1mq :: () ~ t_a1ke
setEvBind
  ev = cobox_a1kf
  tm  = CO IO cobox_a1mq_N
canEvNC:eq
  ()
  t_a1ke
can_eq_nc
  [W] cobox_a1mq :: () ~ t_a1ke
  ()
  ()
  t_a1ke
  t_a1ke
canEqTyVar
  t_a1ke
  ()
  Is-swapped
newWantedEvVar/cache miss [W] cobox_a1mr :: t_a1ke ~ ()
setEvBind
  ev = cobox_a1mq
  tm  = CO Sym cobox_a1mr
rewriteEqEvidence
  [W] cobox_a1mq :: () ~ t_a1ke
  t_a1ke
  ()
  Sym cobox_a1mr
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1mr :: t_a1ke ~ () [" a type equality IO
                                                                   ()
                                                                 ~
                                                                 IO t_a1ke " p4.hs:13:1] (CTyEqCan)
Sneaky unification:
  Unifies: t_a1ke := ()
  Coercion: t_a1ke ~ ()
  Left Kind is: *
  Right Kind is: *
setWantedTyBind t_a1ke := ()
setEvBind
  ev = cobox_a1mr
  tm  = CO <()>_N
kickOutRewritable
  tv =  t_a1ke
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
32[<C:0,F:0>] [W] cobox_a1mr :: t_a1ke ~ (): Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dIArray_a184 :: Data.Array.Base.IArray
                                      a_a183
                                      e_a182 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 0
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dIArray_a184 :: Data.Array.Base.IArray
                                       a_a183
                                       e_a182 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dIArray_a184 :: Data.Array.Base.IArray
                         a_a183
                         e_a182 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
canEvNC:cls Data.Array.Base.IArray [a_a183, e_a182]
Following bound tyvar a_a183 = UArray
Following bound tyvar e_a182 = Double
canClass
  [W] $dIArray_a184 :: Data.Array.Base.IArray
                         a_a183 e_a182 Data.Array.Base.IArray [a_a183, e_a182]
  Data.Array.Base.IArray UArray Double
  Just [W] $dIArray_a184 :: Data.Array.Base.IArray UArray Double
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dIArray_a184 :: Data.Array.Base.IArray
                                       UArray
                                       Double [" a use of ‘listArray’ " p4.hs:25:18-29] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dIArray_a184 :: Data.Array.Base.IArray
                                       UArray
                                       Double [" a use of ‘listArray’ " p4.hs:25:18-29] (CDictCan)
doTopReact
  [W] $dIArray_a184 :: Data.Array.Base.IArray
                         UArray Double [" a use of ‘listArray’ " p4.hs:25:18-29] (CDictCan)
matchClassInst
  pred = Data.Array.Base.IArray UArray Double
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 0
          Solved funeqs 0
  untouchables= 0
matchClass success
  dict Data.Array.Base.IArray UArray Double
  witness Data.Array.Base.$fIArrayUArrayDouble Data.Array.Base.IArray
                                                 UArray Double
updSolvedSetTcs:
  [W] $dIArray_a184 :: Data.Array.Base.IArray UArray Double
doTopReact/found nullary instance for $dIArray_a184
setEvBind
  ev = $dIArray_a184
  tm  = Data.Array.Base.$fIArrayUArrayDouble @[] []
33[<C:0,F:0>] [W] $dIArray_a184 :: Data.Array.Base.IArray
                                     UArray Double: Top react: Dict/Top (solved, no new work)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 1
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dIx_a185 :: GHC.Arr.Ix
                                  i_a181 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 1
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dIx_a185 :: GHC.Arr.Ix
                                   i_a181 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dIx_a185 :: GHC.Arr.Ix
                     i_a181 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
canEvNC:cls GHC.Arr.Ix [i_a181]
Following bound tyvar i_a181 = Int
canClass
  [W] $dIx_a185 :: GHC.Arr.Ix i_a181 GHC.Arr.Ix [i_a181]
  GHC.Arr.Ix Int
  Just [W] $dIx_a185 :: GHC.Arr.Ix Int
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dIx_a185 :: GHC.Arr.Ix
                                   Int [" a use of ‘listArray’ " p4.hs:25:18-29] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dIx_a185 :: GHC.Arr.Ix
                                   Int [" a use of ‘listArray’ " p4.hs:25:18-29] (CDictCan)
doTopReact
  [W] $dIx_a185 :: GHC.Arr.Ix
                     Int [" a use of ‘listArray’ " p4.hs:25:18-29] (CDictCan)
matchClassInst
  pred = GHC.Arr.Ix Int
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 1
          Solved funeqs 0
  untouchables= 0
matchClass success
  dict GHC.Arr.Ix Int
  witness GHC.Arr.$fIxInt GHC.Arr.Ix Int
updSolvedSetTcs: [W] $dIx_a185 :: GHC.Arr.Ix Int
doTopReact/found nullary instance for $dIx_a185
setEvBind
  ev = $dIx_a185
  tm  = GHC.Arr.$fIxInt @[] []
34[<C:0,F:0>] [W] $dIx_a185 :: GHC.Arr.Ix
                                 Int: Top react: Dict/Top (solved, no new work)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 2
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dNum_a1bn :: Num
                                   a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 2
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_a1bn :: Num
                                    a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_a1bn :: Num
                      a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
canEvNC:cls Num [a_a1bB]
Following bound tyvar a_a1bB = Int
canClass
  [W] $dNum_a1bn :: Num a_a1bB Num [a_a1bB]
  Num Int
  Just [W] $dNum_a1bn :: Num Int
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_a1bn :: Num
                                    Int [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dNum_a1bn :: Num
                                    Int [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
doTopReact
  [W] $dNum_a1bn :: Num
                      Int [" the literal ‘1’ " p4.hs:13:21] (CDictCan)
matchClassInst
  pred = Num Int
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 2
          Solved funeqs 0
  untouchables= 0
matchClass success
  dict Num Int
  witness GHC.Num.$fNumInt Num Int
updSolvedSetTcs: [W] $dNum_a1bn :: Num Int
doTopReact/found nullary instance for $dNum_a1bn
setEvBind
  ev = $dNum_a1bn
  tm  = GHC.Num.$fNumInt @[] []
35[<C:0,F:0>] [W] $dNum_a1bn :: Num
                                  Int: Top react: Dict/Top (solved, no new work)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 3
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dNum_a1cy :: Num
                                   a_a1cx [" the literal ‘1’ " p4.hs:16:51] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 3
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dNum_a1cy :: Num
                                    a_a1cx [" the literal ‘1’ " p4.hs:16:51] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dNum_a1cy :: Num
                      a_a1cx [" the literal ‘1’ " p4.hs:16:51] (CNonCanonical)
canEvNC:cls Num [a_a1cx]
Following bound tyvar a_a1cx = Int
canClass
  [W] $dNum_a1cy :: Num a_a1cx Num [a_a1cx]
  Num Int
  Just [W] $dNum_a1cy :: Num Int
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dNum_a1cy :: Num
                                    Int [" the literal ‘1’ " p4.hs:16:51] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dNum_a1cy :: Num
                                    Int [" the literal ‘1’ " p4.hs:16:51] (CDictCan)
doTopReact
  [W] $dNum_a1cy :: Num
                      Int [" the literal ‘1’ " p4.hs:16:51] (CDictCan)
setEvBind
  ev = $dNum_a1cy
  tm  = $dNum_a1bn
36[<C:0,F:0>] [W] $dNum_a1cy :: Num
                                  Int: Top react: Dict/Top (cached)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 3
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dEnum_a1jn :: Enum
                                    t_a1cw [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 3
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dEnum_a1jn :: Enum
                                     t_a1cw [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dEnum_a1jn :: Enum
                       t_a1cw [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CNonCanonical)
canEvNC:cls Enum [t_a1cw]
Following bound tyvar t_a1cw = a_a1cx
Following bound tyvar a_a1cx = Int
canClass
  [W] $dEnum_a1jn :: Enum t_a1cw Enum [t_a1cw]
  Enum Int
  Just [W] $dEnum_a1jn :: Enum Int
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dEnum_a1jn :: Enum
                                     Int [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dEnum_a1jn :: Enum
                                     Int [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CDictCan)
doTopReact
  [W] $dEnum_a1jn :: Enum
                       Int [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CDictCan)
matchClassInst
  pred = Enum Int
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 3
          Solved funeqs 0
  untouchables= 0
matchClass success
  dict Enum Int
  witness GHC.Enum.$fEnumInt Enum Int
updSolvedSetTcs: [W] $dEnum_a1jn :: Enum Int
doTopReact/found nullary instance for $dEnum_a1jn
setEvBind
  ev = $dEnum_a1jn
  tm  = GHC.Enum.$fEnumInt @[] []
37[<C:0,F:0>] [W] $dEnum_a1jn :: Enum
                                   Int: Top react: Dict/Top (solved, no new work)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 4
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dMonad_a1jz :: Monad
                                     m_a1jy [" a do statement " p4.hs:19:11-23] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 4
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dMonad_a1jz :: Monad
                                      m_a1jy [" a do statement " p4.hs:19:11-23] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dMonad_a1jz :: Monad
                        m_a1jy [" a do statement " p4.hs:19:11-23] (CNonCanonical)
canEvNC:cls Monad [m_a1jy]
Following bound tyvar m_a1jy = IO
canClass
  [W] $dMonad_a1jz :: Monad m_a1jy Monad [m_a1jy]
  Monad IO
  Just [W] $dMonad_a1jz :: Monad IO
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dMonad_a1jz :: Monad
                                      IO [" a do statement " p4.hs:19:11-23] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dMonad_a1jz :: Monad
                                      IO [" a do statement " p4.hs:19:11-23] (CDictCan)
doTopReact
  [W] $dMonad_a1jz :: Monad
                        IO [" a do statement " p4.hs:19:11-23] (CDictCan)
matchClassInst
  pred = Monad IO
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 4
          Solved funeqs 0
  untouchables= 0
matchClass success
  dict Monad IO
  witness GHC.Base.$fMonadIO Monad IO
updSolvedSetTcs: [W] $dMonad_a1jz :: Monad IO
doTopReact/found nullary instance for $dMonad_a1jz
setEvBind
  ev = $dMonad_a1jz
  tm  = GHC.Base.$fMonadIO @[] []
38[<C:0,F:0>] [W] $dMonad_a1jz :: Monad
                                    IO: Top react: Dict/Top (solved, no new work)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 5
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dIx_a1k2 :: GHC.Arr.Ix
                                  i_a1jY [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 5
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dIx_a1k2 :: GHC.Arr.Ix
                                   i_a1jY [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dIx_a1k2 :: GHC.Arr.Ix
                     i_a1jY [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
canEvNC:cls GHC.Arr.Ix [i_a1jY]
Following bound tyvar i_a1jY = Int
canClass
  [W] $dIx_a1k2 :: GHC.Arr.Ix i_a1jY GHC.Arr.Ix [i_a1jY]
  GHC.Arr.Ix Int
  Just [W] $dIx_a1k2 :: GHC.Arr.Ix Int
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dIx_a1k2 :: GHC.Arr.Ix
                                   Int [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dIx_a1k2 :: GHC.Arr.Ix
                                   Int [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
doTopReact
  [W] $dIx_a1k2 :: GHC.Arr.Ix
                     Int [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
setEvBind
  ev = $dIx_a1k2
  tm  = $dIx_a185
39[<C:0,F:0>] [W] $dIx_a1k2 :: GHC.Arr.Ix
                                 Int: Top react: Dict/Top (cached)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 5
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dIArray_a1k3 :: Data.Array.Base.IArray
                                      a_a1jX
                                      e_a1jZ [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 5
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dIArray_a1k3 :: Data.Array.Base.IArray
                                       a_a1jX
                                       e_a1jZ [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dIArray_a1k3 :: Data.Array.Base.IArray
                         a_a1jX e_a1jZ [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
canEvNC:cls Data.Array.Base.IArray [a_a1jX, e_a1jZ]
Following bound tyvar a_a1jX = Array
Following bound tyvar e_a1jZ = FlatVector
canClass
  [W] $dIArray_a1k3 :: Data.Array.Base.IArray
                         a_a1jX e_a1jZ Data.Array.Base.IArray [a_a1jX, e_a1jZ]
  Data.Array.Base.IArray Array FlatVector
  Just [W] $dIArray_a1k3 :: Data.Array.Base.IArray Array FlatVector
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dIArray_a1k3 :: Data.Array.Base.IArray
                                       Array
                                       FlatVector [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dIArray_a1k3 :: Data.Array.Base.IArray
                                       Array
                                       FlatVector [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
doTopReact
  [W] $dIArray_a1k3 :: Data.Array.Base.IArray
                         Array FlatVector [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
matchClassInst
  pred = Data.Array.Base.IArray Array FlatVector
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 5
          Solved funeqs 0
  untouchables= 0
matchClass success
  dict Data.Array.Base.IArray Array FlatVector
  witness Data.Array.Base.$fIArrayArraye forall e.
                                         Data.Array.Base.IArray Array e
updSolvedSetTcs:
  [W] $dIArray_a1k3 :: Data.Array.Base.IArray Array FlatVector
doTopReact/found nullary instance for $dIArray_a1k3
setEvBind
  ev = $dIArray_a1k3
  tm  = Data.Array.Base.$fIArrayArraye @[UArray Int Double] []
40[<C:0,F:0>] [W] $dIArray_a1k3 :: Data.Array.Base.IArray
                                     Array FlatVector: Top react: Dict/Top (solved, no new work)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dMArray_a1k4 :: Data.Array.Base.MArray
                                      b_a1k1
                                      e_a1jZ
                                      m_a1k0 [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dMArray_a1k4 :: Data.Array.Base.MArray
                                       b_a1k1
                                       e_a1jZ
                                       m_a1k0 [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dMArray_a1k4 :: Data.Array.Base.MArray
                         b_a1k1
                         e_a1jZ
                         m_a1k0 [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
canEvNC:cls Data.Array.Base.MArray [b_a1k1, e_a1jZ, m_a1k0]
Following bound tyvar e_a1jZ = FlatVector
Following bound tyvar m_a1k0 = IO
canClass
  [W] $dMArray_a1k4 :: Data.Array.Base.MArray
                         b_a1k1 e_a1jZ m_a1k0 Data.Array.Base.MArray [b_a1k1, e_a1jZ,
                                                                      m_a1k0]
  Data.Array.Base.MArray b_a1k1 FlatVector IO
  Just [W] $dMArray_a1k4 :: Data.Array.Base.MArray
                              b_a1k1 FlatVector IO
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dMArray_a1k4 :: Data.Array.Base.MArray
                                       b_a1k1
                                       FlatVector
                                       IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dMArray_a1k4 :: Data.Array.Base.MArray
                                       b_a1k1
                                       FlatVector
                                       IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
doTopReact
  [W] $dMArray_a1k4 :: Data.Array.Base.MArray
                         b_a1k1
                         FlatVector
                         IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
matchClassInst
  pred = Data.Array.Base.MArray b_a1k1 FlatVector IO
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 6
          Solved funeqs 0
  untouchables= 0
matchClass not matching
  dict Data.Array.Base.MArray b_a1k1 FlatVector IO
end stage top-level reactions }
41[<C:0,F:0>] [W] $dMArray_a1k4 :: Data.Array.Base.MArray
                                     b_a1k1 FlatVector IO: Kept as inert
End solver pipeline (not discharged) }
  final_item =  [W] $dMArray_a1k4 :: Data.Array.Base.MArray
                                       b_a1k1
                                       FlatVector
                                       IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
  (b_a1k1 :: * -> * -> *)
  inerts     =  Equalities:
                Type-function equalities:
                No-eqs: True
                Dictionaries:
                Irreds:
                Insolubles = {}
                Solved dicts 6
                Solved funeqs 0
insertInertItemTcS {
  Trying to insert new inert item: [W] $dMArray_a1k4 :: Data.Array.Base.MArray
                                                          b_a1k1
                                                          FlatVector
                                                          IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
insertInertItemTcS }
Start solver pipeline {
  work item =  [W] $dMonad_a1k9 :: Monad
                                     m_a1k8 [" a use of ‘return’ " p4.hs:20:11-16] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dMArray_a1k4 :: Data.Array.Base.MArray
                                                    b_a1k1
                                                    FlatVector
                                                    IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dMonad_a1k9 :: Monad
                                      m_a1k8 [" a use of ‘return’ " p4.hs:20:11-16] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dMonad_a1k9 :: Monad
                        m_a1k8 [" a use of ‘return’ " p4.hs:20:11-16] (CNonCanonical)
canEvNC:cls Monad [m_a1k8]
Following bound tyvar m_a1k8 = IO
canClass
  [W] $dMonad_a1k9 :: Monad m_a1k8 Monad [m_a1k8]
  Monad IO
  Just [W] $dMonad_a1k9 :: Monad IO
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dMonad_a1k9 :: Monad
                                      IO [" a use of ‘return’ " p4.hs:20:11-16] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dMonad_a1k9 :: Monad
                                      IO [" a use of ‘return’ " p4.hs:20:11-16] (CDictCan)
doTopReact
  [W] $dMonad_a1k9 :: Monad
                        IO [" a use of ‘return’ " p4.hs:20:11-16] (CDictCan)
setEvBind
  ev = $dMonad_a1k9
  tm  = $dMonad_a1jz
42[<C:0,F:0>] [W] $dMonad_a1k9 :: Monad
                                    IO: Top react: Dict/Top (cached)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries: [W] $dMArray_a1k4 :: Data.Array.Base.MArray
                                                    b_a1k1
                                                    FlatVector
                                                    IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
solveFlats end } {}
simpl_loop, iteration 1
solveNestedImplications starting {
  original inerts =  Equalities:
                     Type-function equalities:
                     No-eqs: True
                     Dictionaries: [W] $dMArray_a1k4 :: Data.Array.Base.MArray
                                                          b_a1k1
                                                          FlatVector
                                                          IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)
                     Irreds:
                     Insolubles = {}
                     Solved dicts 6
                     Solved funeqs 0
  thinner_inerts  =  Equalities:
                     Type-function equalities:
                     No-eqs: True
                     Dictionaries:
                     Irreds:
                     Insolubles = {}
                     Solved dicts 6
                     Solved funeqs 0
solveImplication {
  Implic {Untouchables = 1
          Skolems = a
          Flatten-skolems =
          No-eqs = False
          Given =
          Wanted = WC {wc_flat = [W] $dIArray_a17W :: Data.Array.Base.IArray
                                                        a_a17V
                                                        e_a17U [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                 [W] $dIx_a17X :: GHC.Arr.Ix
                                                    i_a17T [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                 [W] cobox_a17Y :: ((i_a17T, i_a17T)
                                                    -> [e_a17U] -> a_a17V i_a17T e_a17U)
                                                   ~ ((Int, Int)
                                                      -> [a]
                                                      -> Vector a) [" a type equality (i_a17T,
                                                                                       i_a17T)
                                                                                      -> [e_a17U]
                                                                                      -> a_a17V i_a17T e_a17U
                                                                                      ~
                                                                                      (Int, Int)
                                                                                      -> [a]
                                                                                      -> Vector
                                                                                           a " p4.hs:30:14-25] (CNonCanonical)}
          Binds = EvBindsVar<a17Z>
          the type signature for listVector :: (Int, Int) -> [a] -> Vector a}
solveWanteds {
  WC {wc_flat = [W] $dIArray_a17W :: Data.Array.Base.IArray
                                       a_a17V
                                       e_a17U [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                [W] $dIx_a17X :: GHC.Arr.Ix
                                   i_a17T [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                [W] cobox_a17Y :: ((i_a17T, i_a17T)
                                   -> [e_a17U] -> a_a17V i_a17T e_a17U)
                                  ~ ((Int, Int) -> [a] -> Vector a) [" a type equality (i_a17T,
                                                                                        i_a17T)
                                                                                       -> [e_a17U]
                                                                                       -> a_a17V i_a17T e_a17U
                                                                                       ~
                                                                                       (Int, Int)
                                                                                       -> [a]
                                                                                       -> Vector
                                                                                            a " p4.hs:30:14-25] (CNonCanonical)}
solveFlats {
Start solver pipeline {
  work item =  [W] cobox_a17Y :: ((i_a17T, i_a17T)
                                  -> [e_a17U] -> a_a17V i_a17T e_a17U)
                                 ~ ((Int, Int) -> [a] -> Vector a) [" a type equality (i_a17T,
                                                                                       i_a17T)
                                                                                      -> [e_a17U]
                                                                                      -> a_a17V i_a17T e_a17U
                                                                                      ~
                                                                                      (Int, Int)
                                                                                      -> [a]
                                                                                      -> Vector
                                                                                           a " p4.hs:30:14-25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a17Y :: ((i_a17T, i_a17T)
                                   -> [e_a17U] -> a_a17V i_a17T e_a17U)
                                  ~ ((Int, Int) -> [a] -> Vector a) [" a type equality (i_a17T,
                                                                                        i_a17T)
                                                                                       -> [e_a17U]
                                                                                       -> a_a17V i_a17T e_a17U
                                                                                       ~
                                                                                       (Int, Int)
                                                                                       -> [a]
                                                                                       -> Vector
                                                                                            a " p4.hs:30:14-25] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a17Y :: ((i_a17T, i_a17T)
                     -> [e_a17U] -> a_a17V i_a17T e_a17U)
                    ~ ((Int, Int) -> [a] -> Vector a) [" a type equality (i_a17T,
                                                                          i_a17T)
                                                                         -> [e_a17U]
                                                                         -> a_a17V i_a17T e_a17U
                                                                         ~
                                                                         (Int, Int)
                                                                         -> [a]
                                                                         -> Vector
                                                                              a " p4.hs:30:14-25] (CNonCanonical)
canEvNC:eq
  (i_a17T, i_a17T) -> [e_a17U] -> a_a17V i_a17T e_a17U
  (Int, Int) -> [a] -> Vector a
can_eq_nc
  [W] cobox_a17Y :: ((i_a17T, i_a17T)
                     -> [e_a17U] -> a_a17V i_a17T e_a17U)
                    ~ ((Int, Int) -> [a] -> Vector a)
  (i_a17T, i_a17T) -> [e_a17U] -> a_a17V i_a17T e_a17U
  (i_a17T, i_a17T) -> [e_a17U] -> a_a17V i_a17T e_a17U
  (Int, Int) -> [a] -> Vector a
  (Int, Int) -> [a] -> Vector a
newWantedEvVar/cache miss
  [W] cobox_a1Wj :: (i_a17T, i_a17T) ~ (Int, Int)
newWantedEvVar/cache miss
  [W] cobox_a1Wk :: ([e_a17U] -> a_a17V i_a17T e_a17U)
                    ~ ([a] -> Vector a)
setEvBind
  ev = cobox_a17Y
  tm  = CO cobox_a1Wj -> cobox_a1Wk
canEvNC:eq
  (i_a17T, i_a17T)
  (Int, Int)
can_eq_nc
  [W] cobox_a1Wj :: (i_a17T, i_a17T) ~ (Int, Int)
  (i_a17T, i_a17T)
  (i_a17T, i_a17T)
  (Int, Int)
  (Int, Int)
newWantedEvVar/cache miss [W] cobox_a1Wl :: i_a17T ~ Int
newWantedEvVar/cache miss [W] cobox_a1Wm :: i_a17T ~ Int
setEvBind
  ev = cobox_a1Wj
  tm  = CO (cobox_a1Wl, cobox_a1Wm)_N
canEvNC:eq
  i_a17T
  Int
can_eq_nc
  [W] cobox_a1Wl :: i_a17T ~ Int
  i_a17T
  i_a17T
  Int
  Int
canEqTyVar
  i_a17T
  Int
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1Wl :: i_a17T
                                  ~ Int [" a type equality (i_a17T, i_a17T)
                                                           -> [e_a17U] -> a_a17V i_a17T e_a17U
                                                           ~
                                                           (Int, Int)
                                                           -> [a]
                                                           -> Vector a " p4.hs:30:14-25] (CTyEqCan)
Sneaky unification:
  Unifies: i_a17T := Int
  Coercion: i_a17T ~ Int
  Left Kind is: *
  Right Kind is: *
setWantedTyBind i_a17T := Int
setEvBind
  ev = cobox_a1Wl
  tm  = CO <Int>_N
kickOutRewritable
  tv =  i_a17T
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
43[<C:0,F:0>] [W] cobox_a1Wl :: i_a17T ~ Int: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1Wm :: i_a17T
                                 ~ Int [" a type equality (i_a17T, i_a17T)
                                                          -> [e_a17U] -> a_a17V i_a17T e_a17U
                                                          ~
                                                          (Int, Int)
                                                          -> [a]
                                                          -> Vector
                                                               a " p4.hs:30:14-25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1Wm :: i_a17T
                                  ~ Int [" a type equality (i_a17T, i_a17T)
                                                           -> [e_a17U] -> a_a17V i_a17T e_a17U
                                                           ~
                                                           (Int, Int)
                                                           -> [a]
                                                           -> Vector
                                                                a " p4.hs:30:14-25] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1Wm :: i_a17T ~ Int [" a type equality (i_a17T, i_a17T)
                                                    -> [e_a17U] -> a_a17V i_a17T e_a17U
                                                    ~
                                                    (Int, Int)
                                                    -> [a]
                                                    -> Vector a " p4.hs:30:14-25] (CNonCanonical)
canEvNC:eq
  i_a17T
  Int
can_eq_nc
  [W] cobox_a1Wm :: i_a17T ~ Int
  i_a17T
  i_a17T
  Int
  Int
canEqTyVar
  i_a17T
  Int
  Not-swapped
Following bound tyvar i_a17T = Int
canEqTyVar2
  i_a17T
  Int
  Not-swapped
  Int
  <Int>_N
can_eq_nc
  [W] cobox_a1Wm :: Int ~ Int
  Int
  Int
  Int
  Int
setEvBind
  ev = cobox_a1Wm
  tm  = CO <Int>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1Wk :: ([e_a17U] -> a_a17V i_a17T e_a17U)
                                 ~ ([a] -> Vector a) [" a type equality (i_a17T, i_a17T)
                                                                        -> [e_a17U]
                                                                        -> a_a17V i_a17T e_a17U
                                                                        ~
                                                                        (Int, Int)
                                                                        -> [a]
                                                                        -> Vector
                                                                             a " p4.hs:30:14-25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1Wk :: ([e_a17U] -> a_a17V i_a17T e_a17U)
                                  ~ ([a] -> Vector a) [" a type equality (i_a17T, i_a17T)
                                                                         -> [e_a17U]
                                                                         -> a_a17V i_a17T e_a17U
                                                                         ~
                                                                         (Int, Int)
                                                                         -> [a]
                                                                         -> Vector
                                                                              a " p4.hs:30:14-25] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1Wk :: ([e_a17U] -> a_a17V i_a17T e_a17U)
                    ~ ([a] -> Vector a) [" a type equality (i_a17T, i_a17T)
                                                           -> [e_a17U] -> a_a17V i_a17T e_a17U
                                                           ~
                                                           (Int, Int)
                                                           -> [a]
                                                           -> Vector
                                                                a " p4.hs:30:14-25] (CNonCanonical)
canEvNC:eq
  [e_a17U] -> a_a17V i_a17T e_a17U
  [a] -> Vector a
can_eq_nc
  [W] cobox_a1Wk :: ([e_a17U] -> a_a17V i_a17T e_a17U)
                    ~ ([a] -> Vector a)
  [e_a17U] -> a_a17V i_a17T e_a17U
  [e_a17U] -> a_a17V i_a17T e_a17U
  [a] -> Vector a
  [a] -> Vector a
newWantedEvVar/cache miss [W] cobox_a1Wn :: [e_a17U] ~ [a]
newWantedEvVar/cache miss
  [W] cobox_a1Wo :: a_a17V i_a17T e_a17U ~ Vector a
setEvBind
  ev = cobox_a1Wk
  tm  = CO cobox_a1Wn -> cobox_a1Wo
canEvNC:eq
  [e_a17U]
  [a]
can_eq_nc
  [W] cobox_a1Wn :: [e_a17U] ~ [a]
  [e_a17U]
  [e_a17U]
  [a]
  [a]
newWantedEvVar/cache miss [W] cobox_a1Wp :: e_a17U ~ a
setEvBind
  ev = cobox_a1Wn
  tm  = CO [cobox_a1Wp]_N
canEvNC:eq
  e_a17U
  a
can_eq_nc
  [W] cobox_a1Wp :: e_a17U ~ a
  e_a17U
  e_a17U
  a
  a
canEqTyVar
  e_a17U
  a
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1Wp :: e_a17U
                                  ~ a [" a type equality (i_a17T, i_a17T)
                                                         -> [e_a17U] -> a_a17V i_a17T e_a17U
                                                         ~
                                                         (Int, Int)
                                                         -> [a]
                                                         -> Vector a " p4.hs:30:14-25] (CTyEqCan)
Sneaky unification:
  Unifies: e_a17U := a
  Coercion: e_a17U ~ a
  Left Kind is: *
  Right Kind is: *
setWantedTyBind e_a17U := a
setEvBind
  ev = cobox_a1Wp
  tm  = CO <a>_N
kickOutRewritable
  tv =  e_a17U
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
45[<C:0,F:0>] [W] cobox_a1Wp :: e_a17U ~ a: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1Wo :: a_a17V i_a17T e_a17U
                                 ~ Vector a [" a type equality (i_a17T, i_a17T)
                                                               -> [e_a17U] -> a_a17V i_a17T e_a17U
                                                               ~
                                                               (Int, Int)
                                                               -> [a]
                                                               -> Vector
                                                                    a " p4.hs:30:14-25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1Wo :: a_a17V i_a17T e_a17U
                                  ~ Vector a [" a type equality (i_a17T, i_a17T)
                                                                -> [e_a17U] -> a_a17V i_a17T e_a17U
                                                                ~
                                                                (Int, Int)
                                                                -> [a]
                                                                -> Vector
                                                                     a " p4.hs:30:14-25] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1Wo :: a_a17V i_a17T e_a17U
                    ~ Vector a [" a type equality (i_a17T, i_a17T)
                                                  -> [e_a17U] -> a_a17V i_a17T e_a17U
                                                  ~
                                                  (Int, Int)
                                                  -> [a]
                                                  -> Vector a " p4.hs:30:14-25] (CNonCanonical)
canEvNC:eq
  a_a17V i_a17T e_a17U
  Vector a
can_eq_nc
  [W] cobox_a1Wo :: a_a17V i_a17T e_a17U ~ Vector a
  a_a17V i_a17T e_a17U
  a_a17V i_a17T e_a17U
  Vector a
  Vector a
can_eq_nc
  [W] cobox_a1Wo :: a_a17V i_a17T e_a17U ~ Vector a
  a_a17V i_a17T e_a17U
  a_a17V i_a17T e_a17U
  Array Int a
  Vector a
can_eq_app 1
  [W] cobox_a1Wo :: a_a17V i_a17T e_a17U ~ Vector a
  Not-swapped
  a_a17V i_a17T
  e_a17U
  Array Int a
Following bound tyvar i_a17T = Int
flatten/appty
  a_a17V
  i_a17T
  a_a17V
  <a_a17V>_N
  Int
  <Int>_N
can_eq_app 2
  [W] cobox_a1Wo :: a_a17V i_a17T e_a17U ~ Vector a
  a_a17V Int
Following bound tyvar e_a17U = a
can_eq_app 3
  [W] cobox_a1Wo :: a_a17V i_a17T e_a17U ~ Vector a
  a_a17V Int a
  <a_a17V Int a>_N
can_eq_app 4
  [W] cobox_a1Wo :: a_a17V i_a17T e_a17U ~ Vector a
  a_a17V Int a
  <a_a17V Int a>_N
can_eq_nc
  [W] cobox_a1Wo :: a_a17V Int a ~ Vector a
  a_a17V Int a
  a_a17V Int a
  Array Int a
  Vector a
can_eq_app 1
  [W] cobox_a1Wo :: a_a17V Int a ~ Vector a
  Not-swapped
  a_a17V Int
  a
  Array Int a
flatten/appty
  a_a17V
  Int
  a_a17V
  <a_a17V>_N
  Int
  <Int>_N
can_eq_app 2
  [W] cobox_a1Wo :: a_a17V Int a ~ Vector a
  a_a17V Int
newWantedEvVar/cache miss [W] cobox_a1Wq :: a_a17V Int ~ Array Int
newWantedEvVar/cache miss [W] cobox_a1Wr :: a ~ a
setEvBind
  ev = cobox_a1Wo
  tm  = CO cobox_a1Wq cobox_a1Wr
canEvNC:eq
  a_a17V Int
  Array Int
can_eq_nc
  [W] cobox_a1Wq :: a_a17V Int ~ Array Int
  a_a17V Int
  a_a17V Int
  Array Int
  Array Int
can_eq_app 1
  [W] cobox_a1Wq :: a_a17V Int ~ Array Int
  Not-swapped
  a_a17V
  Int
  Array Int
can_eq_app 2
  [W] cobox_a1Wq :: a_a17V Int ~ Array Int
  a_a17V
newWantedEvVar/cache miss [W] cobox_a1Ws :: a_a17V ~ Array
newWantedEvVar/cache miss [W] cobox_a1Wt :: Int ~ Int
setEvBind
  ev = cobox_a1Wq
  tm  = CO cobox_a1Ws cobox_a1Wt
canEvNC:eq
  a_a17V
  Array
can_eq_nc
  [W] cobox_a1Ws :: a_a17V ~ Array
  a_a17V
  a_a17V
  Array
  Array
canEqTyVar
  a_a17V
  Array
  Not-swapped
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] cobox_a1Ws :: a_a17V
                                  ~ Array [" a type equality (i_a17T, i_a17T)
                                                             -> [e_a17U] -> a_a17V i_a17T e_a17U
                                                             ~
                                                             (Int, Int)
                                                             -> [a]
                                                             -> Vector
                                                                  a " p4.hs:30:14-25] (CTyEqCan)
Sneaky unification:
  Unifies: a_a17V := Array
  Coercion: a_a17V ~ Array
  Left Kind is: * -> * -> *
  Right Kind is: * -> * -> *
setWantedTyBind a_a17V := Array
setEvBind
  ev = cobox_a1Ws
  tm  = CO <Array>_N
kickOutRewritable
  tv =  a_a17V
  Kicked out = WorkList (eqs)   =  []
               WorkList (funeqs)=  []
               WorkList (rest)  =  []
46[<C:0,F:0>] [W] cobox_a1Ws :: a_a17V
                                ~ Array: Spontaneously solved
end stage interact with inerts }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1Wt :: Int
                                 ~ Int [" a type equality (i_a17T, i_a17T)
                                                          -> [e_a17U] -> a_a17V i_a17T e_a17U
                                                          ~
                                                          (Int, Int)
                                                          -> [a]
                                                          -> Vector
                                                               a " p4.hs:30:14-25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1Wt :: Int
                                  ~ Int [" a type equality (i_a17T, i_a17T)
                                                           -> [e_a17U] -> a_a17V i_a17T e_a17U
                                                           ~
                                                           (Int, Int)
                                                           -> [a]
                                                           -> Vector
                                                                a " p4.hs:30:14-25] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1Wt :: Int ~ Int [" a type equality (i_a17T, i_a17T)
                                                 -> [e_a17U] -> a_a17V i_a17T e_a17U
                                                 ~
                                                 (Int, Int)
                                                 -> [a]
                                                 -> Vector a " p4.hs:30:14-25] (CNonCanonical)
canEvNC:eq
  Int
  Int
can_eq_nc
  [W] cobox_a1Wt :: Int ~ Int
  Int
  Int
  Int
  Int
setEvBind
  ev = cobox_a1Wt
  tm  = CO <Int>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] cobox_a1Wr :: a ~ a [" a type equality (i_a17T,
                                                           i_a17T)
                                                          -> [e_a17U] -> a_a17V i_a17T e_a17U
                                                          ~
                                                          (Int, Int)
                                                          -> [a]
                                                          -> Vector
                                                               a " p4.hs:30:14-25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] cobox_a1Wr :: a ~ a [" a type equality (i_a17T,
                                                            i_a17T)
                                                           -> [e_a17U] -> a_a17V i_a17T e_a17U
                                                           ~
                                                           (Int, Int)
                                                           -> [a]
                                                           -> Vector
                                                                a " p4.hs:30:14-25] (CNonCanonical)
canonicalize (non-canonical)
  [W] cobox_a1Wr :: a ~ a [" a type equality (i_a17T, i_a17T)
                                             -> [e_a17U] -> a_a17V i_a17T e_a17U
                                             ~
                                             (Int, Int)
                                             -> [a] -> Vector a " p4.hs:30:14-25] (CNonCanonical)
canEvNC:eq
  a
  a
can_eq_nc
  [W] cobox_a1Wr :: a ~ a
  a
  a
  a
  a
canEqTyVar
  a
  a
  Not-swapped
setEvBind
  ev = cobox_a1Wr
  tm  = CO <a>_N
end stage canonicalization }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dIArray_a17W :: Data.Array.Base.IArray
                                      a_a17V
                                      e_a17U [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 6
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dIArray_a17W :: Data.Array.Base.IArray
                                       a_a17V
                                       e_a17U [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dIArray_a17W :: Data.Array.Base.IArray
                         a_a17V
                         e_a17U [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
canEvNC:cls Data.Array.Base.IArray [a_a17V, e_a17U]
Following bound tyvar a_a17V = Array
Following bound tyvar e_a17U = a
canClass
  [W] $dIArray_a17W :: Data.Array.Base.IArray
                         a_a17V e_a17U Data.Array.Base.IArray [a_a17V, e_a17U]
  Data.Array.Base.IArray Array a
  Just [W] $dIArray_a17W :: Data.Array.Base.IArray Array a
newSCWork/Derived impr_theta = []
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dIArray_a17W :: Data.Array.Base.IArray
                                       Array a [" a use of ‘listArray’ " p4.hs:30:14-25] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dIArray_a17W :: Data.Array.Base.IArray
                                       Array a [" a use of ‘listArray’ " p4.hs:30:14-25] (CDictCan)
doTopReact
  [W] $dIArray_a17W :: Data.Array.Base.IArray
                         Array a [" a use of ‘listArray’ " p4.hs:30:14-25] (CDictCan)
matchClassInst
  pred = Data.Array.Base.IArray Array a
  inerts= Equalities:
          Type-function equalities:
          No-eqs: True
          Dictionaries:
          Irreds:
          Insolubles = {}
          Solved dicts 6
          Solved funeqs 0
  untouchables= 1
matchClass success
  dict Data.Array.Base.IArray Array a
  witness Data.Array.Base.$fIArrayArraye forall e.
                                         Data.Array.Base.IArray Array e
updSolvedSetTcs:
  [W] $dIArray_a17W :: Data.Array.Base.IArray Array a
doTopReact/found nullary instance for $dIArray_a17W
setEvBind
  ev = $dIArray_a17W
  tm  = Data.Array.Base.$fIArrayArraye @[a] []
49[<C:0,F:0>] [W] $dIArray_a17W :: Data.Array.Base.IArray
                                     Array a: Top react: Dict/Top (solved, no new work)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 7
               Solved funeqs 0
Start solver pipeline {
  work item =  [W] $dIx_a17X :: GHC.Arr.Ix
                                  i_a17T [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 7
               Solved funeqs 0
runStage canonicalization {
  workitem   =  [W] $dIx_a17X :: GHC.Arr.Ix
                                   i_a17T [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
canonicalize (non-canonical)
  [W] $dIx_a17X :: GHC.Arr.Ix
                     i_a17T [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
canEvNC:cls GHC.Arr.Ix [i_a17T]
Following bound tyvar i_a17T = Int
canClass
  [W] $dIx_a17X :: GHC.Arr.Ix i_a17T GHC.Arr.Ix [i_a17T]
  GHC.Arr.Ix Int
  Just [W] $dIx_a17X :: GHC.Arr.Ix Int
end stage canonicalization }
runStage interact with inerts {
  workitem   =  [W] $dIx_a17X :: GHC.Arr.Ix
                                   Int [" a use of ‘listArray’ " p4.hs:30:14-25] (CDictCan)
end stage interact with inerts }
runStage top-level reactions {
  workitem   =  [W] $dIx_a17X :: GHC.Arr.Ix
                                   Int [" a use of ‘listArray’ " p4.hs:30:14-25] (CDictCan)
doTopReact
  [W] $dIx_a17X :: GHC.Arr.Ix
                     Int [" a use of ‘listArray’ " p4.hs:30:14-25] (CDictCan)
setEvBind
  ev = $dIx_a17X
  tm  = $dIx_a185
50[<C:0,F:0>] [W] $dIx_a17X :: GHC.Arr.Ix
                                 Int: Top react: Dict/Top (cached)
end stage top-level reactions }
End solver pipeline (discharged) }
  inerts    =  Equalities:
               Type-function equalities:
               No-eqs: True
               Dictionaries:
               Irreds:
               Insolubles = {}
               Solved dicts 7
               Solved funeqs 0
solveFlats end } {}
simpl_loop, iteration 1
solveWanteds }
  unsolved_flats   = {}
  unsolved_implics = {}
  current evbinds  = {$dIArray_a17W
                        = Data.Array.Base.$fIArrayArraye @[a] [],
                      $dIx_a17X = $dIx_a185, cobox_a17Y = CO cobox_a1Wj -> cobox_a1Wk,
                      cobox_a1Wj = CO (cobox_a1Wl, cobox_a1Wm)_N,
                      cobox_a1Wk = CO cobox_a1Wn -> cobox_a1Wo, cobox_a1Wl = CO <Int>_N,
                      cobox_a1Wm = CO <Int>_N, cobox_a1Wn = CO [cobox_a1Wp]_N,
                      cobox_a1Wo = CO cobox_a1Wq cobox_a1Wr, cobox_a1Wp = CO <a>_N,
                      cobox_a1Wq = CO cobox_a1Ws cobox_a1Wt, cobox_a1Wr = CO <a>_N,
                      cobox_a1Ws = CO <Array>_N, cobox_a1Wt = CO <Int>_N}
  current tybinds  = (i_a17T, Int)
                     (e_a17U, a)
                     (a_a17V, Array)
                     (i_a181, Int)
                     (e_a182, Double)
                     (a_a183, UArray)
                     (a_a1bB, Int)
                     (t_a1cs, a_a1bB)
                     (t_a1cw, a_a1cx)
                     (a_a1cx, Int)
                     (a_a1jp, FlatVector)
                     (t_a1jt, m_a1jy a_a1jA)
                     (t_a1ju, a_a1jA)
                     (t_a1jv, m_a1jy b_a1jB)
                     (m_a1jy, IO)
                     (a_a1jA, b_a1k1 i_a1jY e_a1jZ)
                     (b_a1jB, ())
                     (a_a1jX, Array)
                     (i_a1jY, Int)
                     (e_a1jZ, FlatVector)
                     (m_a1k0, IO)
                     (m_a1k8, IO)
                     (a_a1ka, ())
                     (t_a1ke, ())
  final wc = WC {}
floatEqualities
  Flats = {}
  Floated eqs = {}
  Ty binds = [(a17T, (i_a17T, Int)), (a17U, (e_a17U, a)),
              (a17V, (a_a17V, Array)), (a181, (i_a181, Int)),
              (a182, (e_a182, Double)), (a183, (a_a183, UArray)),
              (a1bB, (a_a1bB, Int)), (a1cs, (t_a1cs, a_a1bB)),
              (a1cw, (t_a1cw, a_a1cx)), (a1cx, (a_a1cx, Int)),
              (a1jp, (a_a1jp, FlatVector)), (a1jt, (t_a1jt, m_a1jy a_a1jA)),
              (a1ju, (t_a1ju, a_a1jA)), (a1jv, (t_a1jv, m_a1jy b_a1jB)),
              (a1jy, (m_a1jy, IO)), (a1jA, (a_a1jA, b_a1k1 i_a1jY e_a1jZ)),
              (a1jB, (b_a1jB, ())), (a1jX, (a_a1jX, Array)),
              (a1jY, (i_a1jY, Int)), (a1jZ, (e_a1jZ, FlatVector)),
              (a1k0, (m_a1k0, IO)), (a1k8, (m_a1k8, IO)), (a1ka, (a_a1ka, ())),
              (a1ke, (t_a1ke, ()))]
solveImplication end }
  no_given_eqs = True
  floated_eqs = {}
  new_fsks = []
  res_implic = {}
  implication evbinds =  {$dIArray_a184
                            = Data.Array.Base.$fIArrayUArrayDouble @[] [],
                          $dIx_a185 = GHC.Arr.$fIxInt @[] [],
                          cobox_a186 = CO cobox_a1lC -> cobox_a1lD,
                          $dNum_a1bn = GHC.Num.$fNumInt @[] [],
                          cobox_a1ct = CO [cobox_a1lN]_N,
                          cobox_a1cu = CO UArray cobox_a1lO cobox_a1lP_N,
                          cobox_a1cv = CO <Int>_N, $dNum_a1cy = $dNum_a1bn,
                          cobox_a1cz = CO cobox_a1lQ -> cobox_a1lR,
                          cobox_a1cA = CO Sym cobox_a1lS,
                          $dEnum_a1jn = GHC.Enum.$fEnumInt @[] [],
                          cobox_a1jq = CO Array cobox_a1lT cobox_a1lU_N,
                          cobox_a1jr = CO <Int>_N, cobox_a1js = CO [cobox_a1lV]_N,
                          $dMonad_a1jz = GHC.Base.$fMonadIO @[] [],
                          cobox_a1jD = CO cobox_a1lZ -> cobox_a1m0, $dIx_a1k2 = $dIx_a185,
                          $dIArray_a1k3
                            = Data.Array.Base.$fIArrayArraye @[UArray Int Double] [],
                          cobox_a1k5 = CO Sym cobox_a1m9,
                          cobox_a1k6 = CO cobox_a1md cobox_a1me, $dMonad_a1k9 = $dMonad_a1jz,
                          cobox_a1kc = CO Sym cobox_a1mk, cobox_a1kd = CO Sym cobox_a1mp,
                          cobox_a1kf = CO IO cobox_a1mq_N,
                          cobox_a1lC = CO (cobox_a1lE, cobox_a1lF)_N,
                          cobox_a1lD = CO cobox_a1lG -> cobox_a1lH, cobox_a1lE = CO <Int>_N,
                          cobox_a1lF = CO <Int>_N, cobox_a1lG = CO [cobox_a1lI]_N,
                          cobox_a1lH = CO cobox_a1lJ cobox_a1lK, cobox_a1lI = CO <Double>_N,
                          cobox_a1lJ = CO cobox_a1lL cobox_a1lM, cobox_a1lK = CO <Double>_N,
                          cobox_a1lL = CO <UArray>_N, cobox_a1lM = CO <Int>_N,
                          cobox_a1lN = CO <a_a1bB>_N, cobox_a1lO = CO <Int>_N,
                          cobox_a1lP = CO <Double>_N, cobox_a1lQ = CO <Integer>_N,
                          cobox_a1lR = CO <a_a1cx>_N, cobox_a1lS = CO <Int>_N,
                          cobox_a1lT = CO <Int>_N, cobox_a1lU = CO <FlatVector>_N,
                          cobox_a1lV = CO Sym cobox_a1lW,
                          cobox_a1lW = CO UArray cobox_a1lX cobox_a1lY_N,
                          cobox_a1lX = CO <Int>_N, cobox_a1lY = CO <Double>_N,
                          cobox_a1lZ = CO Sym cobox_a1m1,
                          cobox_a1m0 = CO cobox_a1m2 -> cobox_a1m3,
                          cobox_a1m1 = CO <m_a1jy a_a1jA>_N,
                          cobox_a1m2 = CO cobox_a1m4 -> cobox_a1m5,
                          cobox_a1m3 = CO cobox_a1m7 cobox_a1m8, cobox_a1m4 = CO <a_a1jA>_N,
                          cobox_a1m5 = CO Sym cobox_a1m6, cobox_a1m6 = CO <m_a1jy b_a1jB>_N,
                          cobox_a1m7 = CO <IO>_N, cobox_a1m8 = CO <()>_N,
                          cobox_a1m9 = CO cobox_a1ma cobox_a1mb,
                          cobox_a1ma = CO Sym cobox_a1mc,
                          cobox_a1mb = CO <b_a1k1 i_a1jY e_a1jZ>_N, cobox_a1mc = CO <IO>_N,
                          cobox_a1md = CO cobox_a1mf cobox_a1mg,
                          cobox_a1me = CO Sym cobox_a1mj, cobox_a1mf = CO Sym cobox_a1mh,
                          cobox_a1mg = CO Sym cobox_a1mi, cobox_a1mh = CO <Array>_N,
                          cobox_a1mi = CO <Int>_N, cobox_a1mj = CO <FlatVector>_N,
                          cobox_a1mk = CO cobox_a1ml cobox_a1mm,
                          cobox_a1ml = CO Sym cobox_a1mn, cobox_a1mm = CO Sym cobox_a1mo,
                          cobox_a1mn = CO <IO>_N, cobox_a1mo = CO <()>_N,
                          cobox_a1mp = CO <()>_N, cobox_a1mq = CO Sym cobox_a1mr,
                          cobox_a1mr = CO <()>_N}
solveNestedImplications end }
  all floated_eqs = {}
  unsolved_implics = {}
solveWanteds }
  unsolved_flats   = {[W] $dMArray_a1k4 :: Data.Array.Base.MArray
                                             b_a1k1
                                             FlatVector
                                             IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)}
  unsolved_implics = {}
  current evbinds  = {$dIArray_a184
                        = Data.Array.Base.$fIArrayUArrayDouble @[] [],
                      $dIx_a185 = GHC.Arr.$fIxInt @[] [],
                      cobox_a186 = CO cobox_a1lC -> cobox_a1lD,
                      $dNum_a1bn = GHC.Num.$fNumInt @[] [],
                      cobox_a1ct = CO [cobox_a1lN]_N,
                      cobox_a1cu = CO UArray cobox_a1lO cobox_a1lP_N,
                      cobox_a1cv = CO <Int>_N, $dNum_a1cy = $dNum_a1bn,
                      cobox_a1cz = CO cobox_a1lQ -> cobox_a1lR,
                      cobox_a1cA = CO Sym cobox_a1lS,
                      $dEnum_a1jn = GHC.Enum.$fEnumInt @[] [],
                      cobox_a1jq = CO Array cobox_a1lT cobox_a1lU_N,
                      cobox_a1jr = CO <Int>_N, cobox_a1js = CO [cobox_a1lV]_N,
                      $dMonad_a1jz = GHC.Base.$fMonadIO @[] [],
                      cobox_a1jD = CO cobox_a1lZ -> cobox_a1m0, $dIx_a1k2 = $dIx_a185,
                      $dIArray_a1k3
                        = Data.Array.Base.$fIArrayArraye @[UArray Int Double] [],
                      cobox_a1k5 = CO Sym cobox_a1m9,
                      cobox_a1k6 = CO cobox_a1md cobox_a1me, $dMonad_a1k9 = $dMonad_a1jz,
                      cobox_a1kc = CO Sym cobox_a1mk, cobox_a1kd = CO Sym cobox_a1mp,
                      cobox_a1kf = CO IO cobox_a1mq_N,
                      cobox_a1lC = CO (cobox_a1lE, cobox_a1lF)_N,
                      cobox_a1lD = CO cobox_a1lG -> cobox_a1lH, cobox_a1lE = CO <Int>_N,
                      cobox_a1lF = CO <Int>_N, cobox_a1lG = CO [cobox_a1lI]_N,
                      cobox_a1lH = CO cobox_a1lJ cobox_a1lK, cobox_a1lI = CO <Double>_N,
                      cobox_a1lJ = CO cobox_a1lL cobox_a1lM, cobox_a1lK = CO <Double>_N,
                      cobox_a1lL = CO <UArray>_N, cobox_a1lM = CO <Int>_N,
                      cobox_a1lN = CO <a_a1bB>_N, cobox_a1lO = CO <Int>_N,
                      cobox_a1lP = CO <Double>_N, cobox_a1lQ = CO <Integer>_N,
                      cobox_a1lR = CO <a_a1cx>_N, cobox_a1lS = CO <Int>_N,
                      cobox_a1lT = CO <Int>_N, cobox_a1lU = CO <FlatVector>_N,
                      cobox_a1lV = CO Sym cobox_a1lW,
                      cobox_a1lW = CO UArray cobox_a1lX cobox_a1lY_N,
                      cobox_a1lX = CO <Int>_N, cobox_a1lY = CO <Double>_N,
                      cobox_a1lZ = CO Sym cobox_a1m1,
                      cobox_a1m0 = CO cobox_a1m2 -> cobox_a1m3,
                      cobox_a1m1 = CO <m_a1jy a_a1jA>_N,
                      cobox_a1m2 = CO cobox_a1m4 -> cobox_a1m5,
                      cobox_a1m3 = CO cobox_a1m7 cobox_a1m8, cobox_a1m4 = CO <a_a1jA>_N,
                      cobox_a1m5 = CO Sym cobox_a1m6, cobox_a1m6 = CO <m_a1jy b_a1jB>_N,
                      cobox_a1m7 = CO <IO>_N, cobox_a1m8 = CO <()>_N,
                      cobox_a1m9 = CO cobox_a1ma cobox_a1mb,
                      cobox_a1ma = CO Sym cobox_a1mc,
                      cobox_a1mb = CO <b_a1k1 i_a1jY e_a1jZ>_N, cobox_a1mc = CO <IO>_N,
                      cobox_a1md = CO cobox_a1mf cobox_a1mg,
                      cobox_a1me = CO Sym cobox_a1mj, cobox_a1mf = CO Sym cobox_a1mh,
                      cobox_a1mg = CO Sym cobox_a1mi, cobox_a1mh = CO <Array>_N,
                      cobox_a1mi = CO <Int>_N, cobox_a1mj = CO <FlatVector>_N,
                      cobox_a1mk = CO cobox_a1ml cobox_a1mm,
                      cobox_a1ml = CO Sym cobox_a1mn, cobox_a1mm = CO Sym cobox_a1mo,
                      cobox_a1mn = CO <IO>_N, cobox_a1mo = CO <()>_N,
                      cobox_a1mp = CO <()>_N, cobox_a1mq = CO Sym cobox_a1mr,
                      cobox_a1mr = CO <()>_N}
  current tybinds  = (i_a17T, Int)
                     (e_a17U, a)
                     (a_a17V, Array)
                     (i_a181, Int)
                     (e_a182, Double)
                     (a_a183, UArray)
                     (a_a1bB, Int)
                     (t_a1cs, a_a1bB)
                     (t_a1cw, a_a1cx)
                     (a_a1cx, Int)
                     (a_a1jp, FlatVector)
                     (t_a1jt, m_a1jy a_a1jA)
                     (t_a1ju, a_a1jA)
                     (t_a1jv, m_a1jy b_a1jB)
                     (m_a1jy, IO)
                     (a_a1jA, b_a1k1 i_a1jY e_a1jZ)
                     (b_a1jB, ())
                     (a_a1jX, Array)
                     (i_a1jY, Int)
                     (e_a1jZ, FlatVector)
                     (m_a1k0, IO)
                     (m_a1k8, IO)
                     (a_a1ka, ())
                     (t_a1ke, ())
  final wc = WC {wc_flat = [W] $dMArray_a1k4 :: Data.Array.Base.MArray
                                                  b_a1k1
                                                  FlatVector
                                                  IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)}
applyDefaultingRules { 
  wanteds = {[W] $dMArray_a1k4 :: Data.Array.Base.MArray
                                    b_a1k1
                                    FlatVector
                                    IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CDictCan)}
findDefaultableGroups
  groups= []
  info= ([Integer, Double], (False, False))
applyDefaultingRules } []
writeMetaTyVar i_a17T := Int
writeMetaTyVar e_a17U := a
writeMetaTyVar a_a17V := Array
writeMetaTyVar i_a181 := Int
writeMetaTyVar e_a182 := Double
writeMetaTyVar a_a183 := UArray
writeMetaTyVar a_a1bB := Int
writeMetaTyVar t_a1cs := a_a1bB
writeMetaTyVar t_a1cw := a_a1cx
writeMetaTyVar a_a1cx := Int
writeMetaTyVar a_a1jp := FlatVector
writeMetaTyVar t_a1jt := m_a1jy a_a1jA
writeMetaTyVar t_a1ju := a_a1jA
writeMetaTyVar t_a1jv := m_a1jy b_a1jB
writeMetaTyVar m_a1jy := IO
writeMetaTyVar a_a1jA := b_a1k1 i_a1jY e_a1jZ
writeMetaTyVar b_a1jB := ()
writeMetaTyVar a_a1jX := Array
writeMetaTyVar i_a1jY := Int
writeMetaTyVar e_a1jZ := FlatVector
writeMetaTyVar m_a1k0 := IO
writeMetaTyVar m_a1k8 := IO
writeMetaTyVar a_a1ka := ()
writeMetaTyVar t_a1ke := ()
Constraint solver steps = 50
End simplifyTop }
reportUnsolved {
reportUnsolved (before unflattening)
  WC {wc_flat = [W] $dMArray_a1k4 :: Data.Array.Base.MArray
                                       b_a1k1
                                       FlatVector
                                       IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)}
reportUnsolved (after unflattening):
  (b_a1k1 :: * -> * -> *)
  WC {wc_flat = [W] $dMArray_a1k4 :: Data.Array.Base.MArray
                                       b_a1k1
                                       FlatVector
                                       IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)}
reportFlats
  Flats = {}
  Suppress = False
tryReporters { []
tryReporters: no Utterly wrong
tryReporters: no Holes
tryReporters: no Skolem equalities
tryReporters: no Equalities
tryReporters: no Implicit params
tryReporters: no Irreds
tryReporters: no Dicts
tryReporters }
reportFlats
  Flats = {}
  Suppress = False
tryReporters { []
tryReporters: no Utterly wrong
tryReporters: no Holes
tryReporters: no Skolem equalities
tryReporters: no Equalities
tryReporters: no Implicit params
tryReporters: no Irreds
tryReporters: no Dicts
tryReporters }
reportFlats
  Flats = {[W] $dMArray_a1k4 :: Data.Array.Base.MArray
                                  b0
                                  FlatVector
                                  IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)}
  Suppress = False
tryReporters {
  [[W] $dMArray_a1k4 :: Data.Array.Base.MArray
                          b0
                          FlatVector
                          IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)]
tryReporters: no Utterly wrong
tryReporters: no Holes
tryReporters: no Skolem equalities
tryReporters: no Equalities
tryReporters: no Implicit params
tryReporters: no Irreds
tryReporters: yes
  Dicts [[W] $dMArray_a1k4 :: Data.Array.Base.MArray
                                b0
                                FlatVector
                                IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)]
relevantBindings
  [tmp, help, dim, sL, main, listFlatVector, listVector]
mk_dict_err
  [W] $dMArray_a1k4 :: Data.Array.Base.MArray
                         b0
                         FlatVector
                         IO [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
  True
  The type variable ‘b0’ is ambiguous
Adding error:
  p4.hs:19:16:
      No instance for (Data.Array.Base.MArray b0 FlatVector IO)
        arising from a use of ‘thaw’
      The type variable ‘b0’ is ambiguous
      Note: there is a potential instance available:
        instance Data.Array.Base.MArray GHC.IOArray.IOArray e IO
          -- Defined in ‘Data.Array.Base’
      In a stmt of a 'do' block: v <- thaw tmp
      In the expression:
        do { let sL = ...
                 dim = length sL
                 ....;
             v <- thaw tmp;
             return () }
      In an equation for ‘main’:
          main
            = do { let sL = ...
                       ....;
                   v <- thaw tmp;
                   return () }
tryReporters }
reportUnsolved }
originalCts (simplifyTop)
  fvars =  [(a17T, i_a17T), (a17U, e_a17U), (a17V, a_a17V),
            (a181, i_a181), (a182, e_a182), (a183, a_a183), (a1bB, a_a1bB),
            (a1cs, t_a1cs), (a1cw, t_a1cw), (a1cx, a_a1cx), (a1jp, a_a1jp),
            (a1jt, t_a1jt), (a1ju, t_a1ju), (a1jv, t_a1jv), (a1jy, m_a1jy),
            (a1jA, a_a1jA), (a1jB, b_a1jB), (a1jX, a_a1jX), (a1jY, i_a1jY),
            (a1jZ, e_a1jZ), (a1k0, m_a1k0), (a1k1, b_a1k1), (a1k8, m_a1k8),
            (a1ka, a_a1ka), (a1ke, t_a1ke)]
  wanted =  WC {wc_flat = [W] $dIArray_a184 :: Data.Array.Base.IArray
                                                 a_a183
                                                 e_a182 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                          [W] $dIx_a185 :: GHC.Arr.Ix
                                             i_a181 [" a use of ‘listArray’ " p4.hs:25:18-29] (CNonCanonical)
                          [W] cobox_a186 :: ((i_a181, i_a181)
                                             -> [e_a182] -> a_a183 i_a181 e_a182)
                                            ~ ((Int, Int)
                                               -> [Double]
                                               -> FlatVector) [" a type equality (i_a181, i_a181)
                                                                                 -> [e_a182]
                                                                                 -> a_a183 i_a181 e_a182
                                                                                 ~
                                                                                 (Int, Int)
                                                                                 -> [Double]
                                                                                 -> FlatVector " p4.hs:25:18-29] (CNonCanonical)
                          [W] $dNum_a1bn :: Num
                                              a_a1bB [" the literal ‘1’ " p4.hs:13:21] (CNonCanonical)
                          [W] cobox_a1ct :: [a_a1bB] ~ [t_a1cs] [" a type equality [a_a1bB]
                                                                                   ~
                                                                                   [t_a1cs] " p4.hs:16:61-62] (CNonCanonical)
                          [W] cobox_a1cu :: FlatVector
                                            ~ FlatVector [" a type equality FlatVector
                                                                            ~
                                                                            FlatVector " p4.hs:16:23-56] (CNonCanonical)
                          [W] cobox_a1cv :: t_a1cs ~ Int [" a type equality t_a1cs
                                                                            ~
                                                                            Int " p4.hs:16:41] (CNonCanonical)
                          [W] $dNum_a1cy :: Num
                                              a_a1cx [" the literal ‘1’ " p4.hs:16:51] (CNonCanonical)
                          [W] cobox_a1cz :: (Integer -> a_a1cx)
                                            ~ (Integer -> t_a1cw) [" a type equality Integer
                                                                                     -> a_a1cx
                                                                                     ~
                                                                                     Integer
                                                                                     -> t_a1cw " p4.hs:16:51] (CNonCanonical)
                          [W] cobox_a1cA :: t_a1cs ~ t_a1cw [" a type equality t_a1cs
                                                                               ~
                                                                               t_a1cw " p4.hs:16:54] (CNonCanonical)
                          [W] $dEnum_a1jn :: Enum
                                               t_a1cw [" the arithmetic sequence ‘1 .. s’ " p4.hs:16:50-55] (CNonCanonical)
                          [W] cobox_a1jq :: Vector a_a1jp
                                            ~ Vector FlatVector [" a type equality Vector a_a1jp
                                                                                   ~
                                                                                   Vector
                                                                                     FlatVector " p4.hs:18:21-43] (CNonCanonical)
                          [W] cobox_a1jr :: Int ~ Int [" a type equality Int
                                                                         ~
                                                                         Int " p4.hs:18:35-37] (CNonCanonical)
                          [W] cobox_a1js :: [FlatVector]
                                            ~ [a_a1jp] [" a type equality [FlatVector]
                                                                          ~
                                                                          [a_a1jp] " p4.hs:18:40-43] (CNonCanonical)
                          [W] $dMonad_a1jz :: Monad
                                                m_a1jy [" a do statement " p4.hs:19:11-23] (CNonCanonical)
                          [W] cobox_a1jD :: (m_a1jy a_a1jA
                                             -> (a_a1jA -> m_a1jy b_a1jB) -> m_a1jy b_a1jB)
                                            ~ (t_a1jt
                                               -> (t_a1ju -> t_a1jv)
                                               -> IO ()) [" a type equality m_a1jy a_a1jA
                                                                            -> (a_a1jA
                                                                                -> m_a1jy b_a1jB)
                                                                            -> m_a1jy b_a1jB
                                                                            ~
                                                                            t_a1jt
                                                                            -> (t_a1ju -> t_a1jv)
                                                                            -> IO
                                                                                 () " p4.hs:19:11-23] (CNonCanonical)
                          [W] $dIx_a1k2 :: GHC.Arr.Ix
                                             i_a1jY [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                          [W] $dIArray_a1k3 :: Data.Array.Base.IArray
                                                 a_a1jX
                                                 e_a1jZ [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                          [W] $dMArray_a1k4 :: Data.Array.Base.MArray
                                                 b_a1k1
                                                 e_a1jZ
                                                 m_a1k0 [" a use of ‘thaw’ " p4.hs:19:16-19] (CNonCanonical)
                          [W] cobox_a1k5 :: m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
                                            ~ t_a1jt [" a type equality m_a1k0 (b_a1k1 i_a1jY e_a1jZ)
                                                                        ~
                                                                        t_a1jt " p4.hs:19:16-23] (CNonCanonical)
                          [W] cobox_a1k6 :: Vector FlatVector
                                            ~ a_a1jX i_a1jY e_a1jZ [" a type equality Vector
                                                                                        FlatVector
                                                                                      ~
                                                                                      a_a1jX i_a1jY e_a1jZ " p4.hs:19:21-23] (CNonCanonical)
                          [W] $dMonad_a1k9 :: Monad
                                                m_a1k8 [" a use of ‘return’ " p4.hs:20:11-16] (CNonCanonical)
                          [W] cobox_a1kc :: m_a1k8 a_a1ka
                                            ~ t_a1jv [" a type equality m_a1k8 a_a1ka
                                                                        ~
                                                                        t_a1jv " p4.hs:20:11-19] (CNonCanonical)
                          [W] cobox_a1kd :: () ~ a_a1ka [" a type equality ()
                                                                           ~
                                                                           a_a1ka " p4.hs:20:18-19] (CNonCanonical)
                          [W] cobox_a1kf :: IO () ~ IO t_a1ke [" a type equality IO ()
                                                                                 ~
                                                                                 IO
                                                                                   t_a1ke " p4.hs:13:1] (CNonCanonical)
                wc_impl = Implic {Untouchables = 1
                                  Skolems = a
                                  Flatten-skolems =
                                  No-eqs = False
                                  Given =
                                  Wanted = WC {wc_flat = [W] $dIArray_a17W :: Data.Array.Base.IArray
                                                                                a_a17V
                                                                                e_a17U [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                                         [W] $dIx_a17X :: GHC.Arr.Ix
                                                                            i_a17T [" a use of ‘listArray’ " p4.hs:30:14-25] (CNonCanonical)
                                                         [W] cobox_a17Y :: ((i_a17T, i_a17T)
                                                                            -> [e_a17U]
                                                                            -> a_a17V i_a17T e_a17U)
                                                                           ~ ((Int, Int)
                                                                              -> [a]
                                                                              -> Vector
                                                                                   a) [" a type equality (i_a17T,
                                                                                                          i_a17T)
                                                                                                         -> [e_a17U]
                                                                                                         -> a_a17V i_a17T e_a17U
                                                                                                         ~
                                                                                                         (Int,
                                                                                                          Int)
                                                                                                         -> [a]
                                                                                                         -> Vector
                                                                                                              a " p4.hs:30:14-25] (CNonCanonical)}
                                  Binds = EvBindsVar<a17Z>
                                  the type signature for
                                    listVector :: (Int, Int) -> [a] -> Vector a}}
Tc9

p4.hs:19:16:
    No instance for (Data.Array.Base.MArray b0 FlatVector IO)
      arising from a use of ‘thaw’
    The type variable ‘b0’ is ambiguous
    Note: there is a potential instance available:
      instance Data.Array.Base.MArray GHC.IOArray.IOArray e IO
        -- Defined in ‘Data.Array.Base’
    In a stmt of a 'do' block: v <- thaw tmp
    In the expression:
      do { let sL = ...
               dim = length sL
               ....;
           v <- thaw tmp;
           return () }
    In an equation for ‘main’:
        main
          = do { let sL = ...
                     ....;
                 v <- thaw tmp;
                 return () }
