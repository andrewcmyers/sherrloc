// CUP specification for a set-based constraint language (no actions)
package constraint.parse;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import constraint.ast.Bottom;
import constraint.ast.Constraint;
import constraint.ast.Constructor;
import constraint.ast.ComplexElement;
import constraint.ast.Element;
import constraint.ast.Environment;
import constraint.ast.JoinElement;
import constraint.ast.MeetElement;
import constraint.ast.Relation;
import constraint.ast.Top;
import constraint.ast.Variable;
import constraint.ast.Position;
import diagnostic.DiagnosisInput;

action code {: 
				public Map<String, Constructor> constructors = new HashMap<String, Constructor>( );
				Map<String, Variable> variables = new HashMap<String, Variable>(); 
				Environment env = new Environment();
			:};
						
/* Terminals (tokens returned by the scanner). */
terminal 			SEPERATION;
terminal            CONSTRUCTOR;
terminal            EQ, LEQ, GEQ, SEMICOLON, ARROW, LARROW, LPAREN, RPAREN, LBRACK, RBRACK, COMMA, JOIN, MEET, DASH, COLON, LBRACE, RBRACE;
terminal Integer    INTEGER_LITERAL;
terminal String     IDENTIFIER, STRING_LITERAL;

/* Non terminals */
non terminal DiagnosisInput     cons_spec;
non terminal Set<Constraint>	equations;
non terminal Environment 		env;
non terminal 					constructors, constructor;
non terminal				    assumptions;
non terminal Constraint 		equation;
non terminal Element			term, element, cons;
non terminal String           	id;
non terminal Integer			arity;
non terminal List<Element>		ele_list;
non terminal Position           range, position;

/* Precedences */
precedence right ARROW, LARROW, MEET, JOIN;
precedence left  COMMA;

/* The grammar */
cons_spec 	::= constructors 	
			{: 
					constructors.put("arrow", new Constructor("arrow", 2, false));
					constructors.put("larrow", new Constructor("larrow", 2, true));
					constructors.put("pair",  new Constructor("pair", 2, false));
					constructors.put("_",  new Bottom()); 
					constructors.put("*",  new Top()); 
			:} 
				SEPERATION assumptions SEPERATION equations:l
			{: RESULT = new DiagnosisInput (env, l); :}			
			| 	constructors 
			{: 
					constructors.put("arrow", new Constructor("arrow", 2, false));
					constructors.put("larrow", new Constructor("larrow", 2, true));
					constructors.put("pair",  new Constructor("pair", 2, false)); 
					constructors.put("_",  new Bottom()); 
					constructors.put("*",  new Top()); 
			:} 
				equations:l
			{: RESULT = new DiagnosisInput (env, l); :}
			;

constructors ::= constructors constructor
			| constructor;
			
constructor  ::= CONSTRUCTOR id:s arity:a
			{: constructors.put( s, new Constructor(s, a, false)); :}
			;

id        	::= IDENTIFIER:s
			{: RESULT = s; :} 
			;
			
arity		::= INTEGER_LITERAL:a
			{: RESULT = a; :};
			
assumptions ::= assumptions equation:e
            {: env.addAssertion(e); :}
            | 
            equation:e
            {: env.addAssertion(e); :}
            ;

equations 	::= equations:s equation:e 
            {: s.add(e); RESULT = s; :}
            | 
            equation:e
            {: Set<Constraint> set = new HashSet<Constraint>(); set.add(e); RESULT = set; :}
            ;
            
equation 	::= term:e1 EQ term:e2 env:e SEMICOLON position:p
			{: RESULT = new Constraint (e1, e2, Relation.EQ, e, p); :}  
            | term:e1 LEQ term:e2 env:e SEMICOLON position:p
         	{: RESULT = new Constraint (e1, e2, Relation.LEQ, e, p); :}
            | term:e1 GEQ  term:e2 env:e SEMICOLON position:p
            {: RESULT = new Constraint (e2, e1, Relation.LEQ, e, p); :}
            ;
            
env         ::= LBRACE equations:l RBRACE
			{: Environment e = new Environment(); 
			   for (Constraint c : l)
			       e.addAssertion(c);
			   RESULT = e; 
			:}
			| LBRACE RBRACE
			{:
			   RESULT = new Environment();
			:}
			|
			{:
			   RESULT = new Environment();
			:}
			;
						
position	::= LBRACK STRING_LITERAL:snippet COLON range:p RBRACK
			{: 
			   p.setSnippet(snippet); 
			   RESULT = p; 
			:}
			| LBRACK range:p RBRACK
			{: 
			   RESULT = p; 
			:}
			|
			{:
			   RESULT = Position.EmptyPosition();
			:}
			;
			
range		::= INTEGER_LITERAL:d1 COMMA INTEGER_LITERAL:d2 DASH INTEGER_LITERAL:d3
			{:
			    RESULT = new Position ("", d1, d2, d1, d3);
			:}
			|   INTEGER_LITERAL:d1 COMMA INTEGER_LITERAL:d2 DASH INTEGER_LITERAL:d3 COMMA INTEGER_LITERAL:d4
			{:
			    RESULT = new Position ("", d1, d2, d3, d4);
			:}
			|   IDENTIFIER:s /* identifiers are currently ignored */
			{:  RESULT = Position.EmptyPosition(); :}
			| /* no position */
			{:  RESULT = Position.EmptyPosition(); :}
			;
            
/* term_pos    ::= term:t1 position:p 
			{:
				t1.setPosition(p);
				RESULT = t1;
			:}
			;*/

term     	::=  term:t1 ARROW position:p term:t2
			{: 	List<Element> l = new ArrayList<Element>();
				l.add(t1);
				l.add(t2);  
				ComplexElement e = new ComplexElement ("", constructors.get("arrow"), l);
				e.setPosition(p);
				RESULT = e.getInstance();
			:}
			|
				term:t1 LARROW position:p term:t2
			{: 	List<Element> l = new ArrayList<Element>();
				l.add(t1);
				l.add(t2);  
				ComplexElement e = new ComplexElement ("", constructors.get("larrow"), l);
				e.setPosition(p);
				RESULT = e.getInstance();
			:}
			| term:t1 COMMA position:p term:t2
			{: 	
				List<Element> l = new ArrayList<Element>();
				l.add(t1);
				l.add(t2);  
				ComplexElement e = new ComplexElement ("", constructors.get("pair"), l); 
				e.setPosition(p);
				RESULT = e.getInstance();
			:}
			| term:t1 JOIN position:p term:t2
			{: 	
				List<Element> l = new ArrayList<Element>();
				l.add(t1);
				l.add(t2);  
				JoinElement e = new JoinElement ("", l);
				e.setPosition(p);
				RESULT =  e.getInstance();
			:}
			| term:t1 MEET position:p term:t2
			{: 	
				List<Element> l = new ArrayList<Element>();
				l.add(t1);
				l.add(t2);  
				MeetElement e = new MeetElement ("", l);
				e.setPosition(p);
				RESULT = e.getInstance(); 
			:}
			| ele_list:l
			{: 	
			    Element e = l.remove(0);
			    if (l.size()==0) {
			        RESULT = e;
			    }
			    else {
			        if (!(e instanceof Constructor))
			            throw new Error("\""+e+"\"" + " is not a constructor");
			        Constructor c = (Constructor) e;
				    if (c.getArity() != l.size()) throw new Error("Constructor "+c+" takes wrong number of parameters: "+
			   						"expecting "+c.getArity()+" getting "+l.size());
			        ComplexElement ret = new ComplexElement ("", c, l);
			        RESULT = ret.getInstance();
			    } 
			:}
/*			| element:e position:p
			{:  e.setPosition(p);
			    RESULT = e; :}*/
			;
		
ele_list ::= ele_list:l element:e position:p
			{: 
			    e.setPosition(p);
			    l.add(e); 
			    RESULT = l; 
			:}
			| element:e position:p
			{: 
			    List<Element> l = new ArrayList<Element>();  
			    l.add(e); 
			    RESULT = l; 
			:}
			;
			
/* cons		::= IDENTIFIER:s
			{:
				if (constructors.containsKey(s)) {
					RESULT = constructors.get(s).getInstance();
				} 
			   	else throw new Error("\""+s+"\"" + " is not a constructor");
			:}
			; */

/* a single element is either a variable or a constructor with 0 arity */
element		::= IDENTIFIER:s
			{: 	
				if (constructors.containsKey(s)) {
					RESULT = constructors.get(s).getInstance();
				} 
			   	else {
			   		if (!(variables.containsKey(s)))
			   			variables.put (s, new Variable(s,Position.EmptyPosition()));
			   		RESULT = variables.get(s);
			   	}			   	  
			 :}
			 | LPAREN term:t RPAREN 
			 {:  RESULT = t; :}
			 ;